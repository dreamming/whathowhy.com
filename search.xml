<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式-适配器</title>
    <url>/2023/02/26/AdapterDesign/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/49.png" class="full-image" />

<p>如果你来自中国大陆，正计划去中国澳门旅游，那你一定要记得带上电源转接头，因为澳门的插座无法兼容中国大陆使用的插头，如果你没有电源转接头，那你的手机在澳门就无法充电喽，那为什么不在澳门安装支持中国大陆插头的插座呢？这种重构成本太高了吧。。。在软件系统开发中，同样会存在接口不兼容的问题，这时候我们可以使用 <strong>适配器（包装器）</strong> 设计模式来解决兼容问题</p>
<span id="more"></span>


<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>适配器模式属于结构型模式，可以在不修改现有代码的情况下，将一个或多个类的接口转换为所需的接口。适配器涉及三个角色：目标接口、适配器和适配者。目标接口是使用方期望的接口，适配器将适配者接口转换为目标接口，适配者是需要被适配的对象。适配器模式有三种不同变体：类适配器、对象适配器、接口适配器（或缺省适配器）。在本博客中我们将使用电源转接头事例子，来说明这三种适配器模式的不同</p>
<h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><p>在类适配器中，适配器通过 <strong>继承适配者</strong> 进行目标适配</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/adapter/class_adapter.png" alt="imag"></p>
<h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><p>在对象适配器中，适配器通过 <strong>组合适配者</strong> 进行目标适配<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/adapter/object_adapter.png" alt="imag"></p>
<h2 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h2><p>接口适配器通过 <strong>抽象类实现</strong> 目标接口，使用方通过创建匿名类进行方法的按需适配<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/adapter/inteface_adapter.png" alt="imag"></p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>适配器模式主要用于解决接口功能兼容问题，无需改变现有代码。常见使用场景有</p>
<ol>
<li>重构：在代码重构时，我们可能需要修改接口，但是修改可能会影响到现有的代码，导致接口依赖方发生不可知错误，因此可以通过适配器模式来进行重构，同时也能兼容现有代码</li>
<li>系统集成：在不同系统之间集成时，可能存在不同的接口，这时也可以使用适配器模式将不同的接口转换成统一的接口</li>
</ol>
]]></content>
      <categories>
        <category>Design Pattern</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Bean Validation</title>
    <url>/2019/04/27/BeanValidation/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/16.png" class="full-image" />

<h1 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h1><p>Bean Validation 是一个java规范。可以通过注解的方式约束定义的对象模型或约束方法的入参和出参对象</p>
<h2 id="Bean-Validation-1-0"><a href="#Bean-Validation-1-0" class="headerlink" title="Bean Validation 1.0"></a>Bean Validation 1.0</h2><p>Bean Validation 1.0（JSR303）是最早的一版java标准对象验证规范，是Java EE 6的一部分。认证的具体实现有：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Hibernate Validator</td>
<td>4.3.1.Final</td>
</tr>
<tr>
<td>Apache BVal</td>
<td>0.5</td>
</tr>
</tbody></table>
<h2 id="Bean-Validation-1-1"><a href="#Bean-Validation-1-1" class="headerlink" title="Bean Validation 1.1"></a>Bean Validation 1.1</h2><p>Bean Validation 1.1（JSR349）是Java EE 7的一部分。<br>认证的具体实现有：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Hibernate Validator</td>
<td>4.3.1.Final</td>
</tr>
<tr>
<td>Apache BVal</td>
<td>1.1.2</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>较JSR303新增</p>
<ul>
<li>方法级别上的约束，包括入参、出参</li>
<li>DI and CDI（JSR346） 集成</li>
<li>支持组转换</li>
<li>违反约束消息支持EL表达式(JSR341)</li>
<li>集成其他规范，如验证 JAX-RS: Java API for RESTful Web Services</li>
<li><a href="https://beanvalidation.org/1.1/changes/#dependency-injection">more details</a></li>
</ul>
<h2 id="Bean-Validation-2-0"><a href="#Bean-Validation-2-0" class="headerlink" title="Bean Validation 2.0"></a>Bean Validation 2.0</h2><p>Bean Validation 2.0（JSR380）是Java EE 8的一部分。<br>认证的具体实现有：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Hibernate Validator</td>
<td>6.0.1.Final</td>
</tr>
</tbody></table>
<p>较JSR380新增</p>
<ul>
<li>可针对容器中的元素进行约束</li>
<li>支持date&#x2F;time 的@Past、@Future约束</li>
<li>新的内置约束注解，如：@Email, @NotEmpty, @NotBlank, @Positive, @PositiveOrZero, @Negative, @NegativeOrZero, @PastOrPresent and @FutureOrPresent</li>
<li><strong>可以通过反射取得字段值（field的注解约束不需要实现getter方法也可以进行约束校验，1.0和1.1必须实现getter方法）</strong></li>
<li><a href="https://beanvalidation.org/2.0/spec/#whatsnew-20">more details</a></li>
</ul>
<h1 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h1><p>为什么要使用Bean Validation ?<br><strong>验证参数 BEFORE</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Book book = new Book();</span><br><span class="line">if (book != null </span><br><span class="line">        &amp;&amp; book.getCategory() != null</span><br><span class="line">        &amp;&amp; book.getCategory().trim().length() != 0</span><br><span class="line">        &amp;&amp; book.getTitle() != null</span><br><span class="line">        &amp;&amp; book.getTitle().trim().length() != 0</span><br><span class="line">        &amp;&amp; book.getWriter() != null</span><br><span class="line">        &amp;&amp; book.getWriter().trim().length() != 0) &#123;</span><br><span class="line">    // TODO</span><br><span class="line">&#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
<p><strong>验证参数 AFTER</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line"></span><br><span class="line">    @NotBlank</span><br><span class="line">    private String title;</span><br><span class="line">    @NotBlank</span><br><span class="line">    private String writer;</span><br><span class="line">    @NotBlank</span><br><span class="line">    private String category;</span><br><span class="line"></span><br><span class="line">    // setter/getter</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> validator.validate(new Book())</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<ul>
<li>减少频繁、冗余的if判断</li>
<li>Constrain once，validate everywhere</li>
</ul>
<h1 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h1><p>Bean Validation 怎么用？</p>
<ul>
<li>Requirements（选择 Hibernate Validator实现）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAVEN依赖：</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;6.0.1.Final&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.glassfish&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.el&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.1-b06&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>常用的注解约束解释</p>
<h3 id="基本约束"><a href="#基本约束" class="headerlink" title="基本约束"></a>基本约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BeanForValidate &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 元素： CharSequence</span><br><span class="line">     * 约束：不能为null, 至少包含一个非空字符</span><br><span class="line">     */</span><br><span class="line">    @NotBlank</span><br><span class="line">    private String blankStr = &quot;  &quot;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 元素：CharSequence(length)、Collection(size)、Map(size)、Array(length)</span><br><span class="line">     * 约束：不能为null, 不能为空</span><br><span class="line">     */</span><br><span class="line">    @NotEmpty</span><br><span class="line">    private String emptyStr = &quot;  &quot;;</span><br><span class="line">    @NotEmpty</span><br><span class="line">    private List&lt;Integer&gt; emptyList;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 元素：BigDecimal、BigInteger、byte、short、int、long（包括原型的包装类）</span><br><span class="line">     * 约束：min &lt;= element &lt;=max , null 合法</span><br><span class="line">     */</span><br><span class="line">    @Min(value = 11)</span><br><span class="line">    @Max(value = 21)</span><br><span class="line">    // 11&lt;=size&lt;=21</span><br><span class="line">    private Integer minMaxInt = 10;</span><br><span class="line">    @Min(value = 21)</span><br><span class="line">    private BigDecimal minDecimal = new BigDecimal(&quot;20.9&quot;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 元素：BigDecimal、BigInteger、CharSequence、byte、short、int、long（包括原型的包装类）</span><br><span class="line">     * 约束：element &gt;= DecimalMin, null 合法</span><br><span class="line">     */</span><br><span class="line">    @DecimalMin(value = &quot;100.2&quot;)</span><br><span class="line">    private String decimalMinDecimal = &quot;100.1&quot;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 元素：CharSequence(length)、Collection(size)、Map(size)、Array(length)</span><br><span class="line">     * 约束：size(min) &lt;= element &gt;= size(max)，null 合法</span><br><span class="line">     */</span><br><span class="line">    @Size(min = 1, max = 3)</span><br><span class="line">    // 1&lt;=size&lt;=3</span><br><span class="line">    private String sizeStr = &quot;size&quot;;</span><br><span class="line">    @Size(min = 1)</span><br><span class="line">    @NotNull</span><br><span class="line">    private List&lt;String&gt; nullSizeList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        nullSizeList.add(&quot;A&quot;);</span><br><span class="line">        nullSizeList.add(&quot;B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 元素：BigDecimal、BigInteger、byte、short、int、long、float、double（包括原型的包装类）</span><br><span class="line">     * 约束：必须是正数, 0非法 ,null 合法</span><br><span class="line">     */</span><br><span class="line">    @Positive</span><br><span class="line">    private Integer positive = -1;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 元素：BigDecimal、BigInteger、CharSequence、byte、short、int、long（包括原型的包装类）</span><br><span class="line">     * 约束：element整数位数=integer , element小数位数=fraction ，null 合法</span><br><span class="line">     */</span><br><span class="line">    @Digits(integer = 3, fraction = 2)</span><br><span class="line">    // 只允许在3位整数和2位小数范围内</span><br><span class="line">    private String digits = &quot;99.212&quot;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 元素：Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、</span><br><span class="line">     * OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate</span><br><span class="line">     * 约束：时间是在未来，当前时间默认的是 JVM的时间，null 合法</span><br><span class="line">     */</span><br><span class="line">    @Future</span><br><span class="line">    private Date passTime;</span><br><span class="line">    &#123;</span><br><span class="line">        Calendar instance = Calendar.getInstance();</span><br><span class="line">        instance.add(Calendar.DAY_OF_YEAR, -1);</span><br><span class="line">        passTime = instance.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 元素：CharSequence</span><br><span class="line">     * 约束：是否符合正则表达式，null 合法</span><br><span class="line">     */</span><br><span class="line">    @Pattern(message = &quot;身份证账号格式错误&quot;, regexp = &quot;(^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\\d&#123;5&#125;\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;$)/&quot;)</span><br><span class="line">    // 身份证号验证</span><br><span class="line">    private String idCard = &quot;92002199902137720&quot;;</span><br><span class="line">    @Email</span><br><span class="line">    @NotBlank</span><br><span class="line">    private String mail = &quot;12.12@com.com&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">校验：</span><br><span class="line"></span><br><span class="line">        BeanForValidate beanForValidate = new BeanForValidate();</span><br><span class="line">        Validator validator = Validation.buildDefaultValidatorFactory().getValidator();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;BeanForValidate&gt;&gt; result = validator.validate(beanForValidate);</span><br><span class="line">        List&lt;String&gt; message</span><br><span class="line">                = result.stream().map(v -&gt; v.getPropertyPath() + &quot; &quot; + v.getMessage() + &quot;: &quot; + v.getInvalidValue())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">                               </span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">positive must be greater than 0: -1</span><br><span class="line">minMaxInt 最小不能小于11: 10</span><br><span class="line">minDecimal 最小不能小于21: 20.9</span><br><span class="line">decimalMinDecimal 必须大于或等于100.2: 100.1</span><br><span class="line">idCard 身份证账号格式错误: 92002199902137720</span><br><span class="line">sizeStr 个数必须在1和3之间: size</span><br><span class="line">emptyList 不能为空: null</span><br><span class="line">passTime 需要是一个将来的时间: Fri Apr 19 18:06:18 CST 2019</span><br><span class="line">blankStr 不能为空:   </span><br><span class="line">digits 数字的值超出了允许范围(只允许在3位整数和2位小数范围内): 999.212</span><br></pre></td></tr></table></figure>

<h3 id="嵌套约束"><a href="#嵌套约束" class="headerlink" title="嵌套约束"></a>嵌套约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BeanGraphForValidate &#123;</span><br><span class="line"></span><br><span class="line">    @NotEmpty</span><br><span class="line">    private List&lt;@Valid BeanForValidate&gt; beanForValidates; // Bean Validation 2.0</span><br><span class="line"></span><br><span class="line">//    OR</span><br><span class="line"></span><br><span class="line">//    @NotEmpty</span><br><span class="line">//    @Valid  嵌套校验需要指定 @Valid注解</span><br><span class="line">//    private List&lt;BeanForValidate&gt; beanForValidatess;</span><br><span class="line"></span><br><span class="line">    @NotEmpty</span><br><span class="line">    private Map&lt;String, @Valid BeanForValidate&gt; beanForValidateMap; // Bean Validation 2.0</span><br><span class="line"></span><br><span class="line">//    OR</span><br><span class="line"></span><br><span class="line">//    @NotEmpty</span><br><span class="line">//    @Valid</span><br><span class="line">//    private Map&lt;String,BeanForValidate&gt; beanForValidateMapM;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        beanForValidates = new ArrayList&lt;&gt;();</span><br><span class="line">        BeanForValidate beanForValidate = new BeanForValidate();</span><br><span class="line">        beanForValidates.add(beanForValidate);</span><br><span class="line">        beanForValidateMap = new HashMap&lt;&gt;();</span><br><span class="line">        beanForValidateMap.put(&quot;map&quot;, beanForValidate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">校验：</span><br><span class="line"></span><br><span class="line">        ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class)</span><br><span class="line">        .configure().failFast(false).buildValidatorFactory();</span><br><span class="line">        Validator validator = validatorFactory.getValidator();        </span><br><span class="line">        BeanGraphForValidate beanGraphForValidate = new BeanGraphForValidate();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;BeanGraphForValidate&gt;&gt; result = validator.validate(beanGraphForValidate);</span><br><span class="line">        List&lt;String&gt; message</span><br><span class="line">                = result.stream().map(v -&gt; v.getPropertyPath() + &quot; &quot; + v.getMessage() + &quot;: &quot; + v.getInvalidValue())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        for (String str : message) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">beanForValidateMap[map].emptyList 不能为空: null</span><br><span class="line">beanForValidates[0].sizeStr validated size size: size</span><br><span class="line">beanForValidateMap[map].blankStr 不能为空:   </span><br><span class="line">beanForValidateMap[map].property 不能为空: null</span><br><span class="line">beanForValidateMap[map].passTime 需要是一个将来的时间: Mon Apr 22 00:44:45 CST 2019</span><br><span class="line">beanForValidates[0].minDecimal the element is 20.9, but need element &lt; 21: 20.9</span><br><span class="line">beanForValidateMap[map].minMaxInt 最小不能小于11: 10</span><br><span class="line">beanForValidates[0].decimalMinDecimal 必须大于或等于100.2: 100.1</span><br><span class="line">beanForValidateMap[map].idCard 身份证账号格式错误: 92002199902137720</span><br><span class="line">beanForValidates[0].positive must be greater than 0: -1</span><br><span class="line">beanForValidateMap[map].digits 数字的值超出了允许范围(只允许在3位整数和2位小数范围内): 99.212</span><br><span class="line">beanForValidates[0].minMaxInt 最小不能小于11: 10</span><br><span class="line">beanForValidateMap[map].minDecimal the element is 20.9, but need element &lt; 21: 20.9</span><br><span class="line">beanForValidates[0].idCard 身份证账号格式错误: 92002199902137720</span><br><span class="line">beanForValidates[0].property 不能为空: null</span><br><span class="line">beanForValidates[0].passTime 需要是一个将来的时间: Mon Apr 22 00:44:45 CST 2019</span><br><span class="line">beanForValidateMap[map].sizeStr validated size size: size</span><br><span class="line">beanForValidates[0].blankStr 不能为空:   </span><br><span class="line">beanForValidates[0].digits 数字的值超出了允许范围(只允许在3位整数和2位小数范围内): 99.212</span><br><span class="line">beanForValidateMap[map].positive must be greater than 0: -1</span><br><span class="line">beanForValidateMap[map].decimalMinDecimal 必须大于或等于100.2: 100.1</span><br><span class="line">beanForValidates[0].emptyList 不能为空: null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="分组约束"><a href="#分组约束" class="headerlink" title="分组约束"></a>分组约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BeanForGroupValidate &#123;</span><br><span class="line"></span><br><span class="line">    interface ListGroup &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface MapGroup &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NotNull(groups = ListGroup.class, message = &quot;listGroup&quot;) // 用于指定需要校验的组</span><br><span class="line">    private List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    @NotNull(groups = MapGroup.class, message = &quot;mapGroup&quot;)</span><br><span class="line">    private Map&lt;String, String&gt; map;</span><br><span class="line"></span><br><span class="line">    @NotNull(message = &quot;belong defaultGroup&quot;) // 未指明分组则为缺省组 Default.class</span><br><span class="line">    private Map&lt;String, String&gt; defaultMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">校验：</span><br><span class="line">validator.validate(beanGraphForValidate)</span><br><span class="line">结果：</span><br><span class="line">defaultMap belong to defaultGroup: null</span><br><span class="line"></span><br><span class="line">校验：validator.validate(beanGraphForValidate, BeanForGroupValidate.ListGroup.class)</span><br><span class="line">结果：</span><br><span class="line">list listGroup: null</span><br><span class="line"></span><br><span class="line">校验：</span><br><span class="line">validator.validate(beanGraphForValidate, BeanForGroupValidate.MapGroup.class)</span><br><span class="line">结果：</span><br><span class="line">map mapGroup: null</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法参数约束"><a href="#方法参数约束" class="headerlink" title="方法参数约束"></a>方法参数约束</h3><ul>
<li>入参</li>
<li>出参</li>
<li>构造器参数</li>
<li>构造器返回<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MethodValidate &#123;</span><br><span class="line"></span><br><span class="line">    @NotBlank</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @NotNull</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    @NotNull</span><br><span class="line">    public MethodValidate(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public MethodValidate(@NotNull Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Size(min = 2, max = 2)</span><br><span class="line">    public List&lt;String&gt; getPeopleName() &#123;</span><br><span class="line">        List&lt;String&gt; peoples = new ArrayList&lt;&gt;();</span><br><span class="line">        peoples.add(name);</span><br><span class="line">        return peoples;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPeopleName(@NotBlank String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">校验：</span><br><span class="line"></span><br><span class="line">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();</span><br><span class="line">        ExecutableValidator executableValidator = factory.getValidator().forExecutables();</span><br><span class="line"></span><br><span class="line">        MethodValidate methodValidate = new MethodValidate(&quot;Mary&quot;);</span><br><span class="line">        Method method = MethodValidate.class.getMethod( &quot;setPeopleName&quot;, String.class );</span><br><span class="line">        Object[] parameterValues = &#123; &quot;&quot; &#125;;</span><br><span class="line">        Set&lt;ConstraintViolation&lt;MethodValidate&gt;&gt; validateSetPeopleName = executableValidator.validateParameters(</span><br><span class="line">                methodValidate,</span><br><span class="line">                method,</span><br><span class="line">                parameterValues</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; messages</span><br><span class="line">                = validateSetPeopleName.stream().map(v -&gt; v.getPropertyPath() + &quot; &quot; + v.getMessage() + &quot;: &quot; + v.getInvalidValue())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(messages);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        method = MethodValidate.class.getMethod(&quot;getPeopleName&quot;);</span><br><span class="line">        List&lt;String&gt; peoples = new ArrayList&lt;&gt;();</span><br><span class="line">        peoples.add(&quot;Mary&quot;);</span><br><span class="line">        Set&lt;ConstraintViolation&lt;MethodValidate&gt;&gt; validateGetPeopleName = executableValidator.validateReturnValue(</span><br><span class="line">                methodValidate,</span><br><span class="line">                method,</span><br><span class="line">                peoples</span><br><span class="line">        );</span><br><span class="line">        messages</span><br><span class="line">                = validateGetPeopleName.stream().map(v -&gt; v.getPropertyPath() + &quot; &quot; + v.getMessage() + &quot;: &quot; + v.getInvalidValue())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(messages);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Constructor&lt;MethodValidate&gt; constructorParams = MethodValidate.class.getConstructor(Integer.class);</span><br><span class="line">        Object[] params = &#123;null&#125;;</span><br><span class="line">        Set&lt;ConstraintViolation&lt;MethodValidate&gt;&gt; validateConstructor = executableValidator.validateConstructorParameters(</span><br><span class="line">                constructorParams,</span><br><span class="line">                params</span><br><span class="line">        );</span><br><span class="line">        messages</span><br><span class="line">                = validateConstructor.stream().map(v -&gt; v.getPropertyPath() + &quot; &quot; + v.getMessage() + &quot;: &quot; + v.getInvalidValue())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(messages);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Constructor&lt;MethodValidate&gt; constructorReturn = MethodValidate.class.getConstructor(String.class);</span><br><span class="line">        MethodValidate createdBean = new MethodValidate(18);</span><br><span class="line">        Set&lt;ConstraintViolation&lt;MethodValidate&gt;&gt; validateConstructorReturn = executableValidator.validateConstructorReturnValue(</span><br><span class="line">                constructorReturn,</span><br><span class="line">                createdBean</span><br><span class="line">        );</span><br><span class="line">        messages</span><br><span class="line">                = validateConstructorReturn.stream().map(v -&gt; v.getPropertyPath() + &quot; &quot; + v.getMessage() + &quot;: &quot; + v.getInvalidValue())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(messages);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">[setPeopleName.arg0 不能为空: ]</span><br><span class="line">[getPeopleName.&lt;return value&gt; 个数必须在2和2之间: [Mary]]</span><br><span class="line">[MethodValidate.arg0 不能为null: null]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>如何将Bean Validation集成到Spring MVC框架中？</p>
<ul>
<li>Requirements<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAVEN依赖：</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;6.0.1.Final&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.glassfish&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.el&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.1-b06&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebMvcConfiguration implements WebMvcConfigurer &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Validator validator() &#123;</span><br><span class="line">        ValidatorFactory vf = Validation.byProvider(HibernateValidator.class)</span><br><span class="line">                .configure().failFast(true)</span><br><span class="line">                .buildValidatorFactory();</span><br><span class="line">        return vf.getValidator();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controller方法参数校验"><a href="#Controller方法参数校验" class="headerlink" title="Controller方法参数校验"></a>Controller方法参数校验</h3><ul>
<li><p>Requirements<br>Spring 容器中需要创建Bean：<strong>LocalValidatorFactoryBean</strong>，<strong>LocalValidatorFactoryBean</strong>包含Bean Validation的实现类（通过SPI加载Bean Validation的实现，本文使用hibernate-validator实现）</p>
</li>
<li><p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @RequestMapping(value = &quot;/beanValidation&quot;, method = RequestMethod.POST)</span><br><span class="line">    public void testBeanValidation(@Valid BeanForValidate beanForValidate)</span><br><span class="line">    </span><br><span class="line">// 分组</span><br><span class="line">    @RequestMapping(value = &quot;/beanValidation&quot;, method = RequestMethod.POST)</span><br><span class="line">    public void testBeanValidation(@Validated(value = Default.class) BeanForValidate beanForValidate)</span><br></pre></td></tr></table></figure>
</li>
<li><p>原理</p>
<blockquote>
<p>SpringMVC在创建<strong>RequestMappingHandlerAdapter</strong>时会将<strong>OptionalValidatorFactoryBean</strong>设置到<strong>WebBindingInitializer</strong>属性中，<strong>RequestResponseBodyMethodProcessor</strong>在解析参数的时候通过<strong>WebBindingInitializer</strong>将<strong>OptionalValidatorFactoryBean</strong>绑定到<strong>WebDataBinder</strong>中，<strong>WebDataBinder</strong>通过判断参数是否含有@Valid或@Validated来决定是否进行参数校验</p>
</blockquote>
</li>
<li><p>异常<br><strong>MethodArgumentNotValidException</strong></p>
</li>
</ul>
<h3 id="校验任意方法"><a href="#校验任意方法" class="headerlink" title="校验任意方法"></a>校验任意方法</h3><ul>
<li><p>Requirements<br>Spring 容器中需要创建Bean：<strong>MethodValidationPostProcessor</strong></p>
</li>
<li><p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Validated</span><br><span class="line">public interface BeanValidationService &#123;</span><br><span class="line">    void testBeanValidation(@Valid BeanForValidate beanForValidate);</span><br><span class="line">    </span><br><span class="line">// 分组</span><br><span class="line">@Validated</span><br><span class="line">public interface BeanValidationService &#123;</span><br><span class="line">    @Validated(value = Default.class)</span><br><span class="line">    void testBeanValidation(@Valid BeanForValidate beanForValidate);</span><br></pre></td></tr></table></figure></li>
<li><p>原理<br><strong>MethodValidationPostProcessor</strong>会对含有@Validated的类或接口做AOP增强</p>
</li>
<li><p>异常<br><strong>ConstraintViolationException</strong></p>
</li>
</ul>
<h3 id="Valid-VS-Validated"><a href="#Valid-VS-Validated" class="headerlink" title="@Valid VS @Validated"></a>@Valid VS @Validated</h3><ul>
<li>@Valid<br>由validation-api定义，主要用于Bean的嵌套验证使用，也可用于判断Controller方法中的参数是否需要Bean Validation</li>
<li>Validated<br>由Spring定义，用于判断Controller方法中的参数是否需要Bean Validation以及用于开启Bean Validation的方法增强的标志。@Validated能够指定validation groups</li>
</ul>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> If you’re too afraid to make a mistake, you’ll never play anything truly great. - Terence</p>
<p><a href="https://movie.douban.com/subject/25773932/">Whiplash</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>JSR</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JSR</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-桥接</title>
    <url>/2023/03/01/BridgeDesign/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/50.png" class="full-image" />

<p>桥接模式可以将抽象与实现解耦，使得抽象和实现这两部分可以独立变化，这能够提高系统的扩展性和可维护性。桥接模式是一种结构型模式，这种结构能够帮助我们更好的组织和管理代码。在本博客中我们将通过跨平台应用的实例来说明桥接模式的特点</p>
<span id="more"></span>


<h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><p>下图展示了跨平台应用的简单架构实现，通过继承的方式进行平台、应用程序的扩展</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/bridge/normal.png" alt="imag"></p>
<p>这种架构抽象方式非常简单，但如果需要进行平台的扩展、新应用的开发，将会非常困难</p>
<ul>
<li><p>新增支持 IOS、Android 平台，则需要在新增的平台上创建所有应用程序类<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/bridge/normal_extend1.png" alt="imag"></p>
</li>
<li><p>新增应用程序，则需要在所有平台创建新增的应用程序类<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/bridge/normal_extend2.png" alt="imag"></p>
</li>
</ul>
<p>这种方式的扩展不仅会导致类的数量剧增且难以维护，同时对于平台的扩展，也会影响到具体应用程序类的代码，这也违反了 <strong>SRP</strong> 设计原则</p>
<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接模式的核心思想是将抽象部分与实现部分解耦，主要包含以下几个角色</p>
<ul>
<li>Abstraction: 抽象类，定义抽象部分接口</li>
<li>RefineAbstraction: 扩展抽象类，增加新的行为或特性</li>
<li>Implementor: 定义实现部分的接口</li>
<li>ConcreteImplementor: 具体实现类，实现具体的操作，该类包含了抽象所需的全部功能</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/bridge/bridge.png" alt="imag"></p>
<p>这里的 Client 表示使用方，使用方依赖抽象而不是具体实现，这同时也符合 <strong>DIP</strong> 设计原则。我们来看看桥接实现方式，是如何体现出更好的系统扩展性</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/bridge/bridge_demo.png" alt="imag"></p>
<p>扩展平台和应用程序更简单，互不影响，符合 <strong>SRP</strong> 设计原则</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/bridge/bridge_extend.png" alt="imag"></p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>桥接模式适用于需要处理多种实现方式的场景</p>
<ol>
<li>跨平台应用程序：需要在 Windows、Linux、Mac操作系统中运行的应用程序，可以通过桥接方式处理不同平台之间的差异</li>
<li>不同用户界面：需要支持 Windows界面和 WEB界面的系统，可以通过桥接方式来解决不同界面间的差异</li>
<li>多数据库系统：需要支持 Mysql、Oracle、SQL Server 数据库系统，可以通过桥接方式解决不同数据库之间的差异</li>
</ol>
]]></content>
      <categories>
        <category>Design Pattern</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Clean Architecture</title>
    <url>/2023/05/10/CleanArchitecture/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/55.png" class="full-image" />

<p>软件架构设计的主要目标是支撑软件系统的生命周期，良好的架构设计可以使系统便于理解、易于修改、方便维护，并且能轻松部署。软件架构的终极目标是最大化程序员的生产力，同时最小化系统的总运营成本。软件架构设计是一项需要持续进行的工作，需要根据团队规模、系统规模的变化，以及开发阶段的不同而进行相应的架构调整。以下是软件架构设计中的一些指导</p>
<span id="more"></span>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>每一行代码都是软件架构的一部分</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/architecture/code.png" alt="imag"></p>
<h1 id="组件-模块"><a href="#组件-模块" class="headerlink" title="组件&#x2F;模块"></a>组件&#x2F;模块</h1><p>SOLID原则基于代码逻辑之上，帮助我们定义软件架构中的组件和模块</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/architecture/module.png" alt="imag"></p>
<h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><p>利用组件&#x2F;模块构建系统</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/architecture/system.png" alt="imag"></p>
<p><strong>推荐书籍</strong>：<a href="https://book.douban.com/subject/30333919/">架构整洁之道</a></p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>Clean Code</title>
    <url>/2023/02/03/CleanCode/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/44.png" class="full-image" />

<p>程序员如何才能写出高质量的代码，以提高团队的开发效率和代码的可维护性？<br><i class="fa fa-arrow-down" aria-hidden="true"></i><br>试试如下几点！</p>
<blockquote>
<ol>
<li>可读：代码应该便于自己理解，更应该便于他人理解</li>
<li>简洁：消除冗余代码，DRY（ Don’t Repeat Yourself ）</li>
<li>命名：使用清晰有意义且能自我解释的命名。包括：包、类、方法、变量等</li>
<li>异常：编写清晰的异常处理代码，不要忽略异常</li>
<li>注释：注释可作为代码上下文的补充，不要过多的使用注释，尽量使代码能够自我解释</li>
<li>测试：代码应该是容易测试的，并且是能够快速测试的</li>
<li>重构：定期重构，消除过往的烂代码</li>
<li>指引：学习成功经验，使用设计模式</li>
</ol>
</blockquote>
<p>按照如上几点去写代码，就一定会写出高质量的代码嘛？<br><i class="fa fa-arrow-down" aria-hidden="true"></i><br>不会！</p>
<blockquote>
<p>能否写出高质量的代码，最核心的问题是：你是否想成为优秀的程序员？</p>
</blockquote>
<p><strong>推荐书籍</strong>：<a href="https://book.douban.com/subject/4199741/">代码整洁之道</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>If you find yourself in a hole, stop digging. - Law of holes</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Deploying ClickHouse - 1S-2R</title>
    <url>/2023/08/31/ClickHouse1S2R/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/58.png" class="full-image">

<p><a href="https://whathowhy.com/2023/08/31/ClickHouseStandalone/">ClickHouse Stand-alone</a> 虽然搭建简单，但存在单点问题，生产环境不建议使用。ClickHouse 提供了数据副本集群模式，我们可以通过增加数据副本的方式，来提高服务的可用性。本文记录 1S-2R （一个分片两个副本）的高可用集群搭建，以及常用操作</p>
<span id="more"></span>

<h1 id="ClickHouse-1S-2R"><a href="#ClickHouse-1S-2R" class="headerlink" title="ClickHouse 1S-2R"></a>ClickHouse 1S-2R</h1><p>如下架构图描述</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/clickhouse/clickhouse_1S_2R.png" alt="imag"></p>
<h2 id="Modify-Xml-File"><a href="#Modify-Xml-File" class="headerlink" title="Modify Xml File"></a>Modify Xml File</h2><p>详细配置信息参考官方文档 <a href="https://clickhouse.com/docs/en/architecture/replication">Replication for fault tolerance</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">modify config.xml | clickhouse-01 和 clickhouse-02 的通用配置</span></span><br><span class="line">    &lt;remote_servers &gt;</span><br><span class="line">        &lt;cluster_1S_2R&gt;</span><br><span class="line">            &lt;shard&gt;</span><br><span class="line">                &lt;internal_replication&gt;true&lt;/internal_replication&gt;</span><br><span class="line">                &lt;replica&gt;</span><br><span class="line">                    &lt;host&gt;clickhouse-01&lt;/host&gt;</span><br><span class="line">                    &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">                &lt;/replica&gt;</span><br><span class="line">                &lt;replica&gt;</span><br><span class="line">                    &lt;host&gt;clickhouse-02&lt;/host&gt;</span><br><span class="line">                    &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">                &lt;/replica&gt;               </span><br><span class="line">            &lt;/shard&gt;</span><br><span class="line">        &lt;/cluster_1S_2R&gt;</span><br><span class="line">    &lt;/remote_servers&gt;</span><br><span class="line">    &lt;zookeeper&gt;</span><br><span class="line">        &lt;node&gt;</span><br><span class="line">            &lt;host&gt;clickhouse-keeper-01&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9181&lt;/port&gt;</span><br><span class="line">        &lt;/node&gt;</span><br><span class="line">        &lt;node&gt;</span><br><span class="line">            &lt;host&gt;clickhouse-keeper-02&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9181&lt;/port&gt;</span><br><span class="line">        &lt;/node&gt;</span><br><span class="line">        &lt;node&gt;</span><br><span class="line">            &lt;host&gt;clickhouse-keeper-03&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9181&lt;/port&gt;</span><br><span class="line">        &lt;/node&gt;</span><br><span class="line">    &lt;/zookeeper&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">clickhouse-01 和 clickhouse-02 config.xml 分别配置对应 macros</span></span><br><span class="line">    &lt;macros&gt;</span><br><span class="line">        &lt;shard&gt;01&lt;/shard&gt;</span><br><span class="line">        &lt;replica&gt;01&lt;/replica&gt; # clickhouse-01</span><br><span class="line">        # &lt;replica&gt;02&lt;/replica&gt; # clickhouse-02</span><br><span class="line">        &lt;cluster&gt;cluster_1S_2R&lt;/cluster&gt;</span><br><span class="line">    &lt;/macros&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">modify keeper_config.xml</span> </span><br><span class="line">        &lt;raft_configuration&gt;</span><br><span class="line">            &lt;server&gt;</span><br><span class="line">                &lt;id&gt;1&lt;/id&gt;</span><br><span class="line">                &lt;hostname&gt;clickhouse-keeper-01&lt;/hostname&gt;</span><br><span class="line">                &lt;port&gt;9234&lt;/port&gt;</span><br><span class="line">            &lt;/server&gt;</span><br><span class="line">            &lt;server&gt;</span><br><span class="line">                &lt;id&gt;2&lt;/id&gt;</span><br><span class="line">                &lt;hostname&gt;clickhouse-keeper-02&lt;/hostname&gt;</span><br><span class="line">                &lt;port&gt;9234&lt;/port&gt;</span><br><span class="line">            &lt;/server&gt;</span><br><span class="line">            &lt;server&gt;</span><br><span class="line">                &lt;id&gt;3&lt;/id&gt;</span><br><span class="line">                &lt;hostname&gt;clickhouse-keeper-03&lt;/hostname&gt;</span><br><span class="line">                &lt;port&gt;9234&lt;/port&gt;</span><br><span class="line">            &lt;/server&gt;</span><br><span class="line">        &lt;/raft_configuration&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Up-ClickHouse-Server"><a href="#Up-ClickHouse-Server" class="headerlink" title="Up ClickHouse Server"></a>Up ClickHouse Server</h2><p>通过 docker compose 创建 ClickHouse Server 1S-2R 集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker-compose.yml contents</span></span><br><span class="line">version: &#x27;3.8&#x27;</span><br><span class="line">services:</span><br><span class="line">  clickhouse-01:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-server:$&#123;CHVER:-latest&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-01</span><br><span class="line">    hostname: clickhouse-01</span><br><span class="line">    networks:</span><br><span class="line">      - cluster_1S_2R_ch_proxy</span><br><span class="line">    volumes:</span><br><span class="line">      - ./ck-01/config.d/config.xml:/etc/clickhouse-server/config.d/config.xml</span><br><span class="line">      - ./ck-01/users.d/users.xml:/etc/clickhouse-server/users.d/users.xml</span><br><span class="line">      - ./ck-01/data:/var/lib/clickhouse:rw</span><br><span class="line">      - ./ck-01/logs:/var/log/clickhouse-server</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;127.0.0.1:18123:8123&quot;</span><br><span class="line">      - &quot;127.0.0.1:19000:9000&quot;</span><br><span class="line">    depends_on:</span><br><span class="line">      - clickhouse-keeper-01</span><br><span class="line">      - clickhouse-keeper-02</span><br><span class="line">      - clickhouse-keeper-03</span><br><span class="line"></span><br><span class="line">  clickhouse-02:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-server:$&#123;CHVER:-latest&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-02</span><br><span class="line">    hostname: clickhouse-02</span><br><span class="line">    networks:</span><br><span class="line">      - cluster_1S_2R_ch_proxy</span><br><span class="line">    volumes:</span><br><span class="line">      - ./ck-02/config.d/config.xml:/etc/clickhouse-server/config.d/config.xml</span><br><span class="line">      - ./ck-02/users.d/users.xml:/etc/clickhouse-server/users.d/users.xml</span><br><span class="line">      - ./ck-02/data:/var/lib/clickhouse:rw</span><br><span class="line">      - ./ck-02/logs:/var/log/clickhouse-server</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;127.0.0.1:18124:8123&quot;</span><br><span class="line">      - &quot;127.0.0.1:19001:9000&quot;</span><br><span class="line">    depends_on:</span><br><span class="line">      - clickhouse-keeper-01</span><br><span class="line">      - clickhouse-keeper-02</span><br><span class="line">      - clickhouse-keeper-03    </span><br><span class="line"></span><br><span class="line">  clickhouse-keeper-01:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-keeper:$&#123;CHKVER:-latest-alpine&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-keeper-01</span><br><span class="line">    hostname: clickhouse-keeper-01</span><br><span class="line">    networks:</span><br><span class="line">      - cluster_1S_2R_ch_proxy   </span><br><span class="line">    volumes:</span><br><span class="line">     - ./ck-kp-01/config/keeper_config.xml:/etc/clickhouse-keeper/keeper_config.xml</span><br><span class="line">     - ./ck-kp-01/config/coordination:/var/lib/clickhouse/coordination</span><br><span class="line">     - ./ck-kp-01/config/log:/var/log/clickhouse-keeper     </span><br><span class="line">    ports:</span><br><span class="line">        - &quot;127.0.0.1:19181:9181&quot;</span><br><span class="line"></span><br><span class="line">  clickhouse-keeper-02:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-keeper:$&#123;CHKVER:-latest-alpine&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-keeper-02</span><br><span class="line">    hostname: clickhouse-keeper-02</span><br><span class="line">    networks:</span><br><span class="line">      - cluster_1S_2R_ch_proxy  </span><br><span class="line">    volumes:</span><br><span class="line">     - ./ck-kp-02/config/keeper_config.xml:/etc/clickhouse-keeper/keeper_config.xml</span><br><span class="line">     - ./ck-kp-02/config/coordination:/var/lib/clickhouse/coordination</span><br><span class="line">     - ./ck-kp-02/config/log:/var/log/clickhouse-keeper</span><br><span class="line">    ports:</span><br><span class="line">        - &quot;127.0.0.1:19182:9181&quot;</span><br><span class="line">        </span><br><span class="line">  clickhouse-keeper-03:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-keeper:$&#123;CHKVER:-latest-alpine&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-keeper-03</span><br><span class="line">    hostname: clickhouse-keeper-03</span><br><span class="line">    networks:</span><br><span class="line">      - cluster_1S_2R_ch_proxy   </span><br><span class="line">    volumes:</span><br><span class="line">     - ./ck-kp-03/config/keeper_config.xml:/etc/clickhouse-keeper/keeper_config.xml</span><br><span class="line">     - ./ck-kp-03/config/coordination:/var/lib/clickhouse/coordination</span><br><span class="line">     - ./ck-kp-03/config/log:/var/log/clickhouse-keeper     </span><br><span class="line">    ports:</span><br><span class="line">        - &quot;127.0.0.1:19183:9181&quot;</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  cluster_1S_2R_ch_proxy:</span><br><span class="line">    driver: bridge</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">up server</span></span><br><span class="line">docker compose -f &quot;docker-compose.yml&quot; up -d --build </span><br></pre></td></tr></table></figure>

<h2 id="Verify-ClickHouse-Keeper"><a href="#Verify-ClickHouse-Keeper" class="headerlink" title="Verify ClickHouse Keeper"></a>Verify ClickHouse Keeper</h2><p>验证 ClickHouse Keeper 是否启动成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">****@**** ~ % echo mntr | nc localhost 19181</span><br><span class="line">zk_version      v23.7.4.5-stable-bd2fcd445534e57cc5aa8c170cc25b7479b79c1c</span><br><span class="line">zk_avg_latency  3</span><br><span class="line">zk_max_latency  71</span><br><span class="line">zk_min_latency  0</span><br><span class="line">zk_packets_received     325</span><br><span class="line">zk_packets_sent 325</span><br><span class="line">zk_num_alive_connections        3</span><br><span class="line">zk_outstanding_requests 0</span><br><span class="line">zk_server_state leader</span><br><span class="line">zk_znode_count  258</span><br><span class="line">zk_watch_count  9</span><br><span class="line">zk_ephemerals_count     6</span><br><span class="line">zk_approximate_data_size        82531</span><br><span class="line">zk_key_arena_size       28672</span><br><span class="line">zk_latest_snapshot_size 0</span><br><span class="line">zk_open_file_descriptor_count   62</span><br><span class="line">zk_max_file_descriptor_count    18446744073709551615</span><br><span class="line">zk_followers    2</span><br><span class="line">zk_synced_followers     2</span><br></pre></td></tr></table></figure>

<h2 id="Cluster-Info"><a href="#Cluster-Info" class="headerlink" title="Cluster Info"></a>Cluster Info</h2><p>查看集群信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">login clickhouse server</span></span><br><span class="line">docker exec -it clickhouse-03 clickhouse client --user default --password 123456</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">show cluster infos</span></span><br><span class="line">SELECT</span><br><span class="line">    cluster,</span><br><span class="line">    shard_num,</span><br><span class="line">    replica_num,</span><br><span class="line">    host_name,</span><br><span class="line">    port</span><br><span class="line">FROM system.clusters</span><br><span class="line">WHERE cluster = &#x27;cluster_1S_2R&#x27;</span><br><span class="line">ORDER BY</span><br><span class="line">    shard_num ASC,</span><br><span class="line">    replica_num ASC</span><br></pre></td></tr></table></figure>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/clickhouse/1S_2R_cluster_info.png" alt="imag"></p>
<h2 id="Data-Sample"><a href="#Data-Sample" class="headerlink" title="Data Sample"></a>Data Sample</h2><p>数据的简单测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">db</span></span><br><span class="line">CREATE DATABASE dp;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">table</span></span><br><span class="line">use dp;</span><br><span class="line">CREATE TABLE random_data_max (</span><br><span class="line">  date String,</span><br><span class="line">  val UInt8,</span><br><span class="line">  timestamp Datetime64</span><br><span class="line">)ENGINE=ReplicatedMergeTree()</span><br><span class="line">PARTITION by toYYYYMMDD(timestamp)</span><br><span class="line">ORDER BY timestamp;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">data insert</span></span><br><span class="line">INSERT INTO random_data_max(date, val,timestamp) SELECT today(), number,now() FROM numbers(100);</span><br></pre></td></tr></table></figure>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/clickhouse/1S_2R_Data.png" alt="imag"></p>
<p>可以看到 clickhouse-01 和 clickhouse-02 的数据是一致的</p>
<h1 id="Traefik"><a href="#Traefik" class="headerlink" title="Traefik"></a>Traefik</h1><p>Traefik 可以对后端服务提供反向代理，支持 HTTP &#x2F; TCP Proxy。这里我们使用 Traefik 控制访问 clickhouse-01 和 clickhouse-02 的负载均衡（HTTP PORT 8123）</p>
<h2 id="Modify-YML-Config"><a href="#Modify-YML-Config" class="headerlink" title="Modify YML Config"></a>Modify YML Config</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">traefik.yml contents</span></span><br><span class="line">providers:</span><br><span class="line">  file:</span><br><span class="line">    filename: &quot;/tmp/dynamic.yml&quot;</span><br><span class="line">    watch: true</span><br><span class="line"></span><br><span class="line">api:</span><br><span class="line">  insecure: true</span><br><span class="line"></span><br><span class="line">entryPoints:</span><br><span class="line">  clickhouse:</span><br><span class="line">    address: &quot;:8123&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dynamic.yml contents</span></span><br><span class="line">http:</span><br><span class="line">  routers:</span><br><span class="line">    ck-router:</span><br><span class="line">      entryPoints:</span><br><span class="line">        - &quot;clickhouse&quot;</span><br><span class="line">      rule: &quot;Host(`1S_2R.localhost`)&quot;</span><br><span class="line">      service: ck-service</span><br><span class="line">  services:</span><br><span class="line">    ck-service:</span><br><span class="line">      loadBalancer:</span><br><span class="line">        servers:</span><br><span class="line">        - url: &quot;http://clickhouse-01:8123&quot;</span><br><span class="line">        - url: &quot;http://clickhouse-02:8123&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OR server with weights</span></span><br><span class="line">http:</span><br><span class="line">  routers:</span><br><span class="line">    ck-router:</span><br><span class="line">      entryPoints:</span><br><span class="line">        - &quot;clickhouse&quot;</span><br><span class="line">      rule: &quot;Host(`1S_2R.localhost`)&quot;</span><br><span class="line">      service: ck-service</span><br><span class="line">  services:</span><br><span class="line">    ck-service:</span><br><span class="line">      weighted:</span><br><span class="line">        services:</span><br><span class="line">        - name: ck-01</span><br><span class="line">          weight: 3</span><br><span class="line">        - name: ck-02</span><br><span class="line">          weight: 1</span><br><span class="line">    ck-01:</span><br><span class="line">      loadBalancer:</span><br><span class="line">        servers:</span><br><span class="line">        - url: &quot;http://clickhouse-01:8123&quot;</span><br><span class="line">    ck-02:</span><br><span class="line">      loadBalancer:</span><br><span class="line">        servers:</span><br><span class="line">        - url: &quot;http://clickhouse-02:8123&quot;</span><br></pre></td></tr></table></figure>
<p>rule 中如果定义的 Host 是非 .localhost 结尾的，则需要在本地的 hosts 文件中指定到 127.0.0.1 的映射</p>
<h2 id="Up-Traefik-Server"><a href="#Up-Traefik-Server" class="headerlink" title="Up Traefik Server"></a>Up Traefik Server</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker-compose.yml add traefik service</span></span><br><span class="line">  ck-proxy:</span><br><span class="line">    image: traefik:v2.10</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">      - &quot;8123:8123&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - cluster_1S_2R_ch_proxy</span><br><span class="line">    volumes:</span><br><span class="line">      - ./traefik/traefik.yml:/etc/traefik/traefik.yml</span><br><span class="line">      - ./traefik/config/dynamic.yml:/tmp/dynamic.yml   </span><br></pre></td></tr></table></figure>
<p>浏览器访问 <a href="http://localhost:8080/dashboard/">http://localhost:8080/dashboard/</a></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/clickhouse/traefik.png" alt="image"></p>
<h2 id="Load-Balancer-Test"><a href="#Load-Balancer-Test" class="headerlink" title="Load Balancer Test"></a>Load Balancer Test</h2><p>测试是否经过 Traefik 反向代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">****@**** ~ % echo &#x27;SELECT DISTINCT hostName() FROM cluster(&#x27;cluster_1S_2R&#x27;, system.tables)&#x27; | curl &#x27;http://default:123456@1S_2R.localhost:8123&#x27; --data-binary @-</span><br><span class="line">clickhouse-01</span><br><span class="line">****@**** ~ % echo &#x27;SELECT DISTINCT hostName() FROM cluster(&#x27;cluster_1S_2R&#x27;, system.tables)&#x27; | curl &#x27;http://default:123456@1S_2R.localhost:8123&#x27; --data-binary @-</span><br><span class="line">clickhouse-02</span><br></pre></td></tr></table></figure>
<p>可以看到 Traefik 对访问的 cluster_1S_2R 进行了负载均衡</p>
]]></content>
      <categories>
        <category>ClickHouse</category>
      </categories>
      <tags>
        <tag>ClickHouse</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Deploying ClickHouse - 2S-2R</title>
    <url>/2023/08/31/ClickHouse2R2S/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/59.png" class="full-image">

<p>一般情况下 <a href="https://whathowhy.com/2023/08/31/ClickHouse1S2R/">ClickHouse 1S-2R</a> 的集群模式足够使用，当服务无法 scale up，服务器已经无法继续升级配置，这个时候我们可以选择数据分片来进行服务的 scale out，通过对服务的横向扩展来提升服务能力。本文记录 2S-2R （两个分片两个副本）的集群搭建，以及常用操作</p>
<span id="more"></span>

<h1 id="ClickHouse-2S-2R"><a href="#ClickHouse-2S-2R" class="headerlink" title="ClickHouse 2S-2R"></a>ClickHouse 2S-2R</h1><p>如下架构图描述</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/clickhouse/clickhouse_2S_2R.png" alt="imag"></p>
<h2 id="Data-Sample"><a href="#Data-Sample" class="headerlink" title="Data Sample"></a>Data Sample</h2><p>数据的简单测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">db</span></span><br><span class="line">CREATE DATABASE dp ON CLUSTER cluster_2S_2R;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">base table</span></span><br><span class="line">CREATE TABLE World on CLUSTER cluster_2S_2R (</span><br><span class="line">  val String</span><br><span class="line">)</span><br><span class="line">ENGINE = ReplicatedMergeTree()</span><br><span class="line">ORDER BY val</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">distributed table ｜ rand() 随机分片</span></span><br><span class="line">CREATE TABLE World_distributed ON Cluster cluster_2S_2R</span><br><span class="line">ENGINE = Distributed(cluster_2S_2R,dp,World,rand());</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">data insert</span></span><br><span class="line">INSERT INTO World_distributed(val) SELECT number FROM numbers(10);</span><br></pre></td></tr></table></figure>

<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/clickhouse/2S_2R_UUID.png" alt="imag"></p>
<h1 id="Add-New-Replicas"><a href="#Add-New-Replicas" class="headerlink" title="Add New Replicas"></a>Add New Replicas</h1><p>在当前 CK 集群中新增 SHARD 副本。新架构图描述如下</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/clickhouse/clickhouse_2S_3R_New.png" alt="imag"></p>
<h2 id="Show-Table-Full-Engine"><a href="#Show-Table-Full-Engine" class="headerlink" title="Show Table Full Engine"></a>Show Table Full Engine</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SELECT * FROM system.tables</span><br><span class="line">WHERE database = &#x27;dp&#x27; AND name = &#x27;World&#x27; FORMAT Vertical;</span><br></pre></td></tr></table></figure>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/clickhouse/tables_info_uuid.png" alt="imag"></p>
<h2 id="Show-Replicas-Info"><a href="#Show-Replicas-Info" class="headerlink" title="Show Replicas Info"></a>Show Replicas Info</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SELECT * FROM system.zookeeper</span><br><span class="line">WHERE path = &#x27;/clickhouse/tables/e60cfcf5-27eb-4672-b773-89d06a127422/shard-one/replicas&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/clickhouse/replicas_old.png" alt="imag"></p>
<h2 id="Sync-Database-Table"><a href="#Sync-Database-Table" class="headerlink" title="Sync Database &#x2F; Table"></a>Sync Database &#x2F; Table</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">on new clickhouse node | clickhouse-05 or clickhouse-06</span></span><br><span class="line">CREATE DATABASE dp ON CLUSTER cluster_2S_2R;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">table base on FULL ENGINE info</span></span><br><span class="line">CREATE TABLE World on CLUSTER cluster_2S_2R (</span><br><span class="line">  val String</span><br><span class="line">)</span><br><span class="line">ENGINE = ReplicatedMergeTree(&#x27;/clickhouse/tables/e60cfcf5-27eb-4672-b773-89d06a127422/&#123;shard&#125;&#x27;, &#x27;&#123;replica&#125;&#x27;)</span><br><span class="line">ORDER BY val;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">distributed table</span></span><br><span class="line">CREATE TABLE World_distributed ON Cluster cluster_2S_2R</span><br><span class="line">ENGINE = Distributed(cluster_2S_2R,dp,World,rand());</span><br></pre></td></tr></table></figure>

<h2 id="Show-New-Replicas-Info"><a href="#Show-New-Replicas-Info" class="headerlink" title="Show New Replicas Info"></a>Show New Replicas Info</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SELECT * FROM system.zookeeper</span><br><span class="line">WHERE path = &#x27;/clickhouse/tables/e60cfcf5-27eb-4672-b773-89d06a127422/shard-one/replicas&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/clickhouse/replicas_new.png" alt="imag"></p>
<h2 id="Sync-Replicas-Data"><a href="#Sync-Replicas-Data" class="headerlink" title="Sync Replicas Data"></a>Sync Replicas Data</h2><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/clickhouse/2S_3R_UUID.png" alt="imag"></p>
<h2 id="Test-New-Replicas"><a href="#Test-New-Replicas" class="headerlink" title="Test New Replicas"></a>Test New Replicas</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INSERT INTO World_distributed(val) SELECT number FROM numbers(10);</span><br></pre></td></tr></table></figure>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/clickhouse/2S_3R_New_Data.png" alt="imag"></p>
<h1 id="搭建过程常见问题"><a href="#搭建过程常见问题" class="headerlink" title="搭建过程常见问题"></a>搭建过程常见问题</h1><h2 id="New-Replicas-无法同步数据"><a href="#New-Replicas-无法同步数据" class="headerlink" title="New Replicas 无法同步数据"></a>New Replicas 无法同步数据</h2><p>检查 NEW NODES 中 TABLE 的 FULL ENGINE 是否相同</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SELECT * FROM system.tables</span><br><span class="line">WHERE database = &#x27;dp&#x27; AND name = &#x27;World&#x27; FORMAT Vertical;</span><br></pre></td></tr></table></figure>

<h2 id="Distributed-Table-的权限问题"><a href="#Distributed-Table-的权限问题" class="headerlink" title="Distributed Table 的权限问题"></a>Distributed Table 的权限问题</h2><p>DISTRIBUTED TABLE 使用的是 ‘default’ 用户进行不同 Clickhouse Node 之间的通信</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Received exception from server (version 23.6.2):</span><br><span class="line">Code: 516. DB::Exception: Received from localhost:9000. DB::Exception: Received from clickhouse-01:9000. DB::Exception: default: Authentication failed: password is incorrect, or there is no user with such name.</span><br><span class="line"></span><br><span class="line">If you have installed ClickHouse and forgot password you can reset it in the configuration file.</span><br><span class="line">The password for default user is typically located at /etc/clickhouse-server/users.d/default-password.xml</span><br><span class="line">and deleting this file will reset the password.</span><br><span class="line">See also /etc/clickhouse-server/users.xml on the server where ClickHouse is installed.</span><br></pre></td></tr></table></figure>

<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案 1"></a>解决方案 1</h3><p>保留 default 用户密码，修改 config.xml 文件中的 replica，新增 user&#x2F;password</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;remote_servers&gt;</span><br><span class="line">    &lt;cluster_2S_2R&gt;</span><br><span class="line">        &lt;shard&gt;</span><br><span class="line">            &lt;internal_replication&gt;true&lt;/internal_replication&gt;</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">                &lt;host&gt;clickhouse-01&lt;/host&gt;</span><br><span class="line">                &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">                &lt;user&gt;default&lt;/user&gt;</span><br><span class="line">                &lt;password&gt;123456&lt;/password&gt;                    </span><br><span class="line">            &lt;/replica&gt;</span><br><span class="line">        &lt;/shard&gt;</span><br><span class="line">        ........         </span><br><span class="line">    &lt;/cluster_2S_2R&gt;</span><br><span class="line">&lt;/remote_servers&gt;</span><br></pre></td></tr></table></figure>

<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案 2"></a>解决方案 2</h3><p>设置 default 无密码登录，修改 user.xml 文件中的 networks，指定可访问 IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;users&gt;</span><br><span class="line">    &lt;default&gt;</span><br><span class="line">        &lt;profile&gt;default&lt;/profile&gt;</span><br><span class="line">        &lt;networks&gt;</span><br><span class="line">            &lt;ip&gt;::1&lt;/ip&gt;</span><br><span class="line">            &lt;ip&gt;127.0.0.1&lt;/ip&gt;</span><br><span class="line">            &lt;ip&gt;192.168.5.1&lt;/ip&gt;</span><br><span class="line">            &lt;ip&gt;192.168.5.2&lt;/ip&gt;</span><br><span class="line">            &lt;ip&gt;192.168.5.3&lt;/ip&gt;</span><br><span class="line">            &lt;ip&gt;192.168.5.4&lt;/ip&gt;</span><br><span class="line">            &lt;ip&gt;192.168.5.5&lt;/ip&gt;</span><br><span class="line">            &lt;ip&gt;192.168.5.6&lt;/ip&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Up-ClickHouse-Server"><a href="#Up-ClickHouse-Server" class="headerlink" title="Up ClickHouse Server"></a>Up ClickHouse Server</h1><p>通过 docker compose 创建 ClickHouse Server 2S-2R 集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker-compose.yml contents</span></span><br><span class="line">version: &#x27;3.8&#x27;</span><br><span class="line">services:</span><br><span class="line">  clickhouse-01:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-server:$&#123;CHVER:-latest&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-01</span><br><span class="line">    hostname: clickhouse-01   </span><br><span class="line">    networks:</span><br><span class="line">      cluster_2S_2R_ch_proxy:</span><br><span class="line">        ipv4_address: 192.168.5.1</span><br><span class="line">    volumes:</span><br><span class="line">      - ./ck-01/config.d/config.xml:/etc/clickhouse-server/config.d/config.xml</span><br><span class="line">      - ./ck-01/users.d/users.xml:/etc/clickhouse-server/users.d/users.xml</span><br><span class="line">      - ./ck-01/data:/var/lib/clickhouse:rw</span><br><span class="line">      - ./ck-01/logs:/var/log/clickhouse-server</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;127.0.0.1:18123:8123&quot;</span><br><span class="line">      - &quot;127.0.0.1:19000:9000&quot;</span><br><span class="line">    depends_on:</span><br><span class="line">      - clickhouse-keeper-01</span><br><span class="line">      - clickhouse-keeper-02</span><br><span class="line">      - clickhouse-keeper-03</span><br><span class="line"></span><br><span class="line">  clickhouse-02:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-server:$&#123;CHVER:-latest&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-02</span><br><span class="line">    hostname: clickhouse-02   </span><br><span class="line">    networks:</span><br><span class="line">      cluster_2S_2R_ch_proxy:</span><br><span class="line">        ipv4_address: 192.168.5.2</span><br><span class="line">    volumes:</span><br><span class="line">      - ./ck-02/config.d/config.xml:/etc/clickhouse-server/config.d/config.xml</span><br><span class="line">      - ./ck-02/users.d/users.xml:/etc/clickhouse-server/users.d/users.xml</span><br><span class="line">      - ./ck-02/data:/var/lib/clickhouse:rw</span><br><span class="line">      - ./ck-02/logs:/var/log/clickhouse-server</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;127.0.0.1:18124:8123&quot;</span><br><span class="line">      - &quot;127.0.0.1:19001:9000&quot;</span><br><span class="line">    depends_on:</span><br><span class="line">      - clickhouse-keeper-01</span><br><span class="line">      - clickhouse-keeper-02</span><br><span class="line">      - clickhouse-keeper-03</span><br><span class="line"></span><br><span class="line">  clickhouse-03:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-server:$&#123;CHVER:-latest&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-03</span><br><span class="line">    hostname: clickhouse-03   </span><br><span class="line">    networks:</span><br><span class="line">      cluster_2S_2R_ch_proxy:</span><br><span class="line">        ipv4_address: 192.168.5.3</span><br><span class="line">    volumes:</span><br><span class="line">      - ./ck-03/config.d/config.xml:/etc/clickhouse-server/config.d/config.xml</span><br><span class="line">      - ./ck-03/users.d/users.xml:/etc/clickhouse-server/users.d/users.xml</span><br><span class="line">      - ./ck-03/data:/var/lib/clickhouse:rw</span><br><span class="line">      - ./ck-03/logs:/var/log/clickhouse-server</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;127.0.0.1:18125:8123&quot;</span><br><span class="line">      - &quot;127.0.0.1:19002:9000&quot;</span><br><span class="line">    depends_on:</span><br><span class="line">      - clickhouse-keeper-01</span><br><span class="line">      - clickhouse-keeper-02</span><br><span class="line">      - clickhouse-keeper-03</span><br><span class="line">    </span><br><span class="line">  clickhouse-04:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-server:$&#123;CHVER:-latest&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-04</span><br><span class="line">    hostname: clickhouse-04  </span><br><span class="line">    networks:</span><br><span class="line">      cluster_2S_2R_ch_proxy:</span><br><span class="line">        ipv4_address: 192.168.5.4</span><br><span class="line">    volumes:</span><br><span class="line">      - ./ck-04/config.d/config.xml:/etc/clickhouse-server/config.d/config.xml</span><br><span class="line">      - ./ck-04/users.d/users.xml:/etc/clickhouse-server/users.d/users.xml</span><br><span class="line">      - ./ck-04/data:/var/lib/clickhouse:rw</span><br><span class="line">      - ./ck-04/logs:/var/log/clickhouse-server</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;127.0.0.1:18126:8123&quot;</span><br><span class="line">      - &quot;127.0.0.1:19003:9000&quot;</span><br><span class="line">    depends_on:</span><br><span class="line">      - clickhouse-keeper-01</span><br><span class="line">      - clickhouse-keeper-02</span><br><span class="line">      - clickhouse-keeper-03</span><br><span class="line"></span><br><span class="line">  clickhouse-05:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-server:$&#123;CHVER:-latest&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-05</span><br><span class="line">    hostname: clickhouse-05</span><br><span class="line">    networks:</span><br><span class="line">      cluster_2S_2R_ch_proxy:</span><br><span class="line">        ipv4_address: 192.168.5.5</span><br><span class="line">    volumes:</span><br><span class="line">      - ./ck-05/config.d/config.xml:/etc/clickhouse-server/config.d/config.xml</span><br><span class="line">      - ./ck-05/users.d/users.xml:/etc/clickhouse-server/users.d/users.xml</span><br><span class="line">      - ./ck-05/data:/var/lib/clickhouse:rw</span><br><span class="line">      - ./ck-05/logs:/var/log/clickhouse-server</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;127.0.0.1:18127:8123&quot;</span><br><span class="line">      - &quot;127.0.0.1:19004:9000&quot;</span><br><span class="line">    depends_on:</span><br><span class="line">      - clickhouse-keeper-01</span><br><span class="line">      - clickhouse-keeper-02</span><br><span class="line">      - clickhouse-keeper-03</span><br><span class="line"></span><br><span class="line">  clickhouse-06:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-server:$&#123;CHVER:-latest&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-06</span><br><span class="line">    hostname: clickhouse-06</span><br><span class="line">    networks:</span><br><span class="line">      cluster_2S_2R_ch_proxy:</span><br><span class="line">        ipv4_address: 192.168.5.6</span><br><span class="line">    volumes:</span><br><span class="line">      - ./ck-06/config.d/config.xml:/etc/clickhouse-server/config.d/config.xml</span><br><span class="line">      - ./ck-06/users.d/users.xml:/etc/clickhouse-server/users.d/users.xml</span><br><span class="line">      - ./ck-06/data:/var/lib/clickhouse:rw</span><br><span class="line">      - ./ck-06/logs:/var/log/clickhouse-server</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;127.0.0.1:18128:8123&quot;</span><br><span class="line">      - &quot;127.0.0.1:19005:9000&quot;</span><br><span class="line">    depends_on:</span><br><span class="line">      - clickhouse-keeper-01</span><br><span class="line">      - clickhouse-keeper-02</span><br><span class="line">      - clickhouse-keeper-03        </span><br><span class="line"></span><br><span class="line">  clickhouse-keeper-01:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-keeper:$&#123;CHKVER:-latest-alpine&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-keeper-01</span><br><span class="line">    hostname: clickhouse-keeper-01</span><br><span class="line">    networks:</span><br><span class="line">      cluster_2S_2R_ch_proxy:</span><br><span class="line">        ipv4_address: 192.168.5.10   </span><br><span class="line">    volumes:</span><br><span class="line">     - ./ck-kp-01/config/keeper_config.xml:/etc/clickhouse-keeper/keeper_config.xml</span><br><span class="line">     - ./ck-kp-01/config/coordination:/var/lib/clickhouse/coordination</span><br><span class="line">     - ./ck-kp-01/config/log:/var/log/clickhouse-keeper</span><br><span class="line">    ports:</span><br><span class="line">        - &quot;127.0.0.1:19181:9181&quot;</span><br><span class="line"></span><br><span class="line">  clickhouse-keeper-02:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-keeper:$&#123;CHKVER:-latest-alpine&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-keeper-02</span><br><span class="line">    hostname: clickhouse-keeper-02</span><br><span class="line">    networks:</span><br><span class="line">      cluster_2S_2R_ch_proxy:</span><br><span class="line">        ipv4_address: 192.168.5.11  </span><br><span class="line">    volumes:</span><br><span class="line">     - ./ck-kp-02/config/keeper_config.xml:/etc/clickhouse-keeper/keeper_config.xml</span><br><span class="line">     - ./ck-kp-02/config/coordination:/var/lib/clickhouse/coordination</span><br><span class="line">     - ./ck-kp-02/config/log:/var/log/clickhouse-keeper</span><br><span class="line">    ports:</span><br><span class="line">        - &quot;127.0.0.1:19182:9181&quot;</span><br><span class="line">        </span><br><span class="line">  clickhouse-keeper-03:</span><br><span class="line">    image: &quot;clickhouse/clickhouse-keeper:$&#123;CHKVER:-latest-alpine&#125;&quot;</span><br><span class="line">    user: &quot;101:101&quot;</span><br><span class="line">    container_name: clickhouse-keeper-03</span><br><span class="line">    hostname: clickhouse-keeper-03</span><br><span class="line">    networks:</span><br><span class="line">      cluster_2S_2R_ch_proxy:</span><br><span class="line">        ipv4_address: 192.168.5.12</span><br><span class="line">    volumes:</span><br><span class="line">     - ./ck-kp-03/config/keeper_config.xml:/etc/clickhouse-keeper/keeper_config.xml</span><br><span class="line">     - ./ck-kp-03/config/coordination:/var/lib/clickhouse/coordination</span><br><span class="line">     - ./ck-kp-03/config/log:/var/log/clickhouse-keeper</span><br><span class="line">    ports:</span><br><span class="line">        - &quot;127.0.0.1:19183:9181&quot;</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  cluster_2S_2R_ch_proxy:</span><br><span class="line">    driver: bridge</span><br><span class="line">    ipam:</span><br><span class="line">      config:</span><br><span class="line">        - subnet: 192.168.5.0/24</span><br><span class="line">          gateway: 192.168.5.254</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ClickHouse</category>
      </categories>
      <tags>
        <tag>ClickHouse</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Deploying ClickHouse - Stand-alone</title>
    <url>/2023/08/31/ClickHouseStandalone/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/57.png" class="full-image">

<p>ClickHouse 是由俄罗斯IT公司 Yandex 为 Yandex.Metrica 网络分析服务开发的一款面向列存储的高性能 OLAP 数据库，支持 SQL 查询，于2016年6月开源。本文记录如何使用 Docker 搭建 ClickHouse 的 Stand-alone 实例，以及常见操作</p>
<span id="more"></span>

<h1 id="Modify-Xml-File"><a href="#Modify-Xml-File" class="headerlink" title="Modify Xml File"></a>Modify Xml File</h1><p>设置 default 登陆密码，并为其开启 SQL user mode</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">copy config.xml、users.xml to host path</span></span><br><span class="line">docker cp $(docker create --name tc clickhouse/clickhouse-server:latest):/etc/clickhouse-server/config.xml . &amp;&amp; docker rm tc</span><br><span class="line">docker cp $(docker create --name tc clickhouse/clickhouse-server:latest):/etc/clickhouse-server/users.xml . &amp;&amp; docker rm tc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">set</span> password <span class="keyword">for</span> <span class="string">&#x27;default&#x27;</span> user</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">modify users.xml</span></span><br><span class="line">&lt;clickhouse&gt;</span><br><span class="line">    &lt;users&gt;</span><br><span class="line">    &lt;default&gt;</span><br><span class="line">            &lt;password&gt;123456&lt;/password&gt;</span><br><span class="line">            &lt;access_management&gt;1&lt;/access_management&gt;</span><br><span class="line">            &lt;named_collection_control&gt;1&lt;/named_collection_control&gt;</span><br><span class="line">            &lt;show_named_collections&gt;1&lt;/show_named_collections&gt;</span><br><span class="line">            &lt;show_named_collections_secrets&gt;1&lt;/show_named_collections_secrets&gt;</span><br><span class="line">    &lt;/default&gt;</span><br><span class="line">    &lt;/users&gt;</span><br><span class="line">&lt;/clickhouse&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Up-ClickHouse-Server"><a href="#Up-ClickHouse-Server" class="headerlink" title="Up ClickHouse Server"></a>Up ClickHouse Server</h1><p>通过 docker compose 创建 ClickHouse Server 实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker-compose.yml contents</span></span><br><span class="line">version: &quot;3.6&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  clickhouse-server:</span><br><span class="line">    container_name: ck-test</span><br><span class="line">    image: clickhouse/clickhouse-server:latest</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;18123:8123&quot;</span><br><span class="line">      - &quot;19000:9000&quot;</span><br><span class="line">      - &quot;19004:9004&quot; </span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;2&quot;</span><br><span class="line">          memory: 1G</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: &quot;0.25&quot;</span><br><span class="line">          memory: 128M</span><br><span class="line">    ulimits:</span><br><span class="line">      nofile:</span><br><span class="line">        soft: &quot;262144&quot;</span><br><span class="line">        hard: &quot;262144&quot;</span><br><span class="line">    volumes: </span><br><span class="line">      - ./config/config.d/config.xml:/etc/clickhouse-server/config.d/config.xml:rw</span><br><span class="line">      - ./config/users.d/users.xml:/etc/clickhouse-server/users.d/users.xml:rw</span><br><span class="line">      - ./data:/var/lib/clickhouse:rw</span><br><span class="line">      - ./logs:/var/log/clickhouse-server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">up server</span></span><br><span class="line">docker compose -f &quot;docker-compose.yml&quot; up -d --build</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">login clickhouse</span></span><br><span class="line">docker exec -it ck-test clickhouse client --user default --password 123456</span><br></pre></td></tr></table></figure>

<h1 id="Create-User"><a href="#Create-User" class="headerlink" title="Create User"></a>Create User</h1><p>创建管理员用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">role</span></span><br><span class="line">CREATE ROLE admin_role;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">authorization</span></span><br><span class="line">GRANT ALL ON *.* TO admin_role WITH GRANT OPTION;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user</span></span><br><span class="line">CREATE USER mark IDENTIFIED BY &#x27;123&#x27;;</span><br><span class="line">GRANT admin_role to mark;</span><br></pre></td></tr></table></figure>

<h1 id="Data-Sample"><a href="#Data-Sample" class="headerlink" title="Data Sample"></a>Data Sample</h1><p>数据的简单测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">db</span></span><br><span class="line">CREATE DATABASE dp;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">table</span></span><br><span class="line">use dp;</span><br><span class="line">CREATE TABLE random_data_max (</span><br><span class="line">  date String,</span><br><span class="line">  val UInt8,</span><br><span class="line">  timestamp Datetime64</span><br><span class="line">)ENGINE=MergeTree()</span><br><span class="line">PARTITION by toYYYYMMDD(timestamp)</span><br><span class="line">ORDER BY timestamp;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">data insert</span></span><br><span class="line">INSERT INTO random_data_max(date, val,timestamp) SELECT today(), number,now() FROM numbers(100);</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">db infos | 压缩率信息等</span></span><br><span class="line">select</span><br><span class="line">    database,</span><br><span class="line">    table,</span><br><span class="line">    formatReadableSize(size) as size,</span><br><span class="line">    formatReadableSize(bytes_on_disk) as bytes_on_disk,</span><br><span class="line">    formatReadableSize(data_uncompressed_bytes) as data_uncompressed_bytes,</span><br><span class="line">    formatReadableSize(data_compressed_bytes) as data_compressed_bytes,</span><br><span class="line">    compress_rate,</span><br><span class="line">    rows,</span><br><span class="line">    days,</span><br><span class="line">    formatReadableSize(avgDaySize) as avgDaySize</span><br><span class="line">from</span><br><span class="line">(</span><br><span class="line">    select</span><br><span class="line">        database,</span><br><span class="line">        table,</span><br><span class="line">        sum(bytes) as size,</span><br><span class="line">        sum(rows) as rows,</span><br><span class="line">        min(min_date) as min_date,</span><br><span class="line">        max(max_date) as max_date,</span><br><span class="line">        sum(bytes_on_disk) as bytes_on_disk,</span><br><span class="line">        sum(data_uncompressed_bytes) as data_uncompressed_bytes,</span><br><span class="line">        sum(data_compressed_bytes) as data_compressed_bytes,</span><br><span class="line">        (data_compressed_bytes / data_uncompressed_bytes) * 100 as compress_rate,</span><br><span class="line">        max_date - min_date as days,</span><br><span class="line">        size / (max_date - min_date) as avgDaySize</span><br><span class="line">    from system.parts</span><br><span class="line">    where active</span><br><span class="line">     and database = &#x27;dp&#x27;</span><br><span class="line">    group by</span><br><span class="line">        database,</span><br><span class="line">        table</span><br><span class="line">) FORMAT Vertical;</span><br></pre></td></tr></table></figure>

<h1 id="Mysql-Client-Connect"><a href="#Mysql-Client-Connect" class="headerlink" title="Mysql Client Connect"></a>Mysql Client Connect</h1><p>ClickHouse 支持 MySQL protocol，可以通过 MySQL Client 连接 ClickHouse Server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">****@**** ~ % docker run -it --network=host --rm mysql mysql --protocol tcp -h 127.0.0.1 -u mark -P 19004 -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 23.6.2.18-ClickHouse </span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2023, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ClickHouse</category>
      </categories>
      <tags>
        <tag>ClickHouse</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>代码质量持续约束</title>
    <url>/2019/01/17/CodeQualityCICD/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/18.png" class="full-image" />

<h1 id="基于Docker的代码质量持续约束流程搭建"><a href="#基于Docker的代码质量持续约束流程搭建" class="headerlink" title="基于Docker的代码质量持续约束流程搭建"></a>基于Docker的代码质量持续约束流程搭建</h1><p>为了提高团队整体的代码质量，有必要搭建一套持续的代码约束流程。本文记录基于Docker如何搭建自动化代码检测流程</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/Code%20C%20C.png"></p>
<span id="more"></span>

<h1 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h1><p>方便组件间通过容器名通信</p>
<p><code>docker network create -d bridge --subnet=10.0.0.0/24 cicd_bridge</code></p>
<h1 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h1><p>开源的代码托管平台，集成了CI&#x2F;CD</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><code>docker run -it --network=cicd_bridge -p 443:443 -p 80:80 -p 22:22 --name gitlab_cicd --restart always -v ~/DockerVolumeCicd/gitlab/config:/etc/gitlab -v ~/DockerVolumeCicd/gitlab/logs:/var/log/gitlab -v ~/DockerVolumeCicd/gitlab/data:/var/opt/gitlab -d gitlab/gitlab-ce:latest</code></p>
<h2 id="访问-http-127-0-0-1"><a href="#访问-http-127-0-0-1" class="headerlink" title="访问 http://127.0.0.1"></a>访问 <a href="http://127.0.0.1/">http://127.0.0.1</a></h2><blockquote>
<p>首次登陆设置密码为：adminadmin ,使用 root用户名登陆</p>
</blockquote>
<h2 id="创建一个spring-测试项目"><a href="#创建一个spring-测试项目" class="headerlink" title="创建一个spring 测试项目"></a>创建一个spring 测试项目</h2><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/GitLab%20SpringTemplate.png"></p>
<h2 id="设置-GitLab-扩展url-并-重启"><a href="#设置-GitLab-扩展url-并-重启" class="headerlink" title="设置 GitLab 扩展url 并 重启"></a>设置 GitLab 扩展url 并 重启</h2><p><code>vi ~DockerVolumeCicd/gitlab/config/gitlab.rb</code> </p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/GitLab%20Config.png"></p>
<p><code>docker restart gitlab_cicd </code>  </p>
<h1 id="GitLab-Runner"><a href="#GitLab-Runner" class="headerlink" title="GitLab Runner"></a>GitLab Runner</h1><p>GitLab Runner用于运行.gitlab-ci.yml中定义的Jobs，Jobs的执行结果会被发送到GitLab，GitLab Runner与GitLab CI（持续集成服务） 集成使用。GitLab Runner由Go语言实现</p>
<h2 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h2><p><code>docker run -it --network=cicd_bridge --name gitlab-runner_cicd --restart always -v /var/run/docker.sock:/var/run/docker.sock -v ~/DockerVolumeCicd/gitlab-runner/conf:/etc/gitlab-runner/ -d gitlab/gitlab-runner:latest</code></p>
<h2 id="获取-Runner-Token"><a href="#获取-Runner-Token" class="headerlink" title="获取 Runner Token"></a>获取 Runner Token</h2><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/GitLab%20Token.png"><br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/GItLab%20G%20Token.png"></p>
<h2 id="注册-Runner"><a href="#注册-Runner" class="headerlink" title="注册 Runner"></a>注册 Runner</h2><p><code>docker exec -it gitlab-runner_cicd gitlab-ci-multi-runner register</code></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/GitLab%20Runner%20Register.png"></p>
<p><code>或者命令指定注册： docker exec -it  gitlab-runner_cicd gitlab-ci-multi-runner register   --non-interactive   --executor &quot;docker&quot;   --docker-image maven:3.5-jdk-8   --url &quot;http://gitlab_cicd&quot;   --registration-token &quot;NDcNdmx5jaQxka8Ua3sn&quot;   --description &quot;docker-runner&quot;   --tag-list &quot;whw&quot;   --run-untagged   --locked=&quot;false&quot; --docker-network-mode =cicd_bridge</code></p>
<h2 id="配置注册信息"><a href="#配置注册信息" class="headerlink" title="配置注册信息"></a>配置注册信息</h2><p><code>  vi ~/DockerVolumeCicd/gitlab-runner/conf/config.toml</code></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/GitLab%20Runner%20Config.png"></p>
<h1 id="SonarQube"><a href="#SonarQube" class="headerlink" title="SonarQube"></a>SonarQube</h1><p>SonarQube是一个代码质量管理系统，支持多种语言分析，提供重复代码、编码标准、单元测试、代码覆盖率、代码复杂度、潜在Bug的报告分析</p>
<h2 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h2><p><code>docker run -it --network=cicd_bridge  -p 9000:9000 --name sonarqube_cicd --restart always -v ~/DockerVolumeCicd/sonar/conf:/opt/sonarqube/conf -v ~/DockerVolumeCicd/sonar/data:/opt/sonarqube/data -v ~/DockerVolumeCicd/sonar/logs:/opt/sonarqube/logs -v ~/DockerVolumeCicd/sonar/extensions:/opt/sonarqube/extensions -d sonarqube</code></p>
<h2 id="访问-http-127-0-0-1-9000"><a href="#访问-http-127-0-0-1-9000" class="headerlink" title="访问 http://127.0.0.1:9000"></a>访问 <a href="http://127.0.0.1:9000/">http://127.0.0.1:9000</a></h2><blockquote>
<p>   user&#x2F;pwd 默认为 admin&#x2F;admin</p>
</blockquote>
<h2 id="首次登陆配置"><a href="#首次登陆配置" class="headerlink" title="首次登陆配置"></a>首次登陆配置</h2><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/SonarQube%20Token.png"><br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/SonarQube%20Lanage.png"></p>
<h2 id="安装Java语言插件-AND-刷新页面Restart-SonarQube"><a href="#安装Java语言插件-AND-刷新页面Restart-SonarQube" class="headerlink" title="安装Java语言插件 AND 刷新页面Restart SonarQube"></a>安装Java语言插件 AND 刷新页面Restart SonarQube</h2><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/Java%20Plugin%20Install.png"><br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/Restart%20SonarQube.png"></p>
<h1 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a>.gitlab-ci.yml</h1><p>在项目的根目录添加.gitlab-ci.yml文件，用于定义Jobs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">image: maven:3.5-jdk-8</span><br><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - test</span><br><span class="line">  - sonarqube</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">  MAVEN_OPTS: &quot;-Dmaven.repo.local=.m2/repository&quot;</span><br><span class="line"></span><br><span class="line">cache:</span><br><span class="line">  paths:</span><br><span class="line">    - .m2/repository</span><br><span class="line">    - target/</span><br><span class="line"></span><br><span class="line">build:</span><br><span class="line">  stage: build</span><br><span class="line">  only:</span><br><span class="line">    - release-test</span><br><span class="line">    - develop</span><br><span class="line">  script:</span><br><span class="line">    - mvn clean install -Dmaven.test.skip</span><br><span class="line">  tags:</span><br><span class="line">    - whw</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  stage: test</span><br><span class="line">  only:</span><br><span class="line">    - release-test</span><br><span class="line">    - develop</span><br><span class="line">  script:</span><br><span class="line">    - mvn test</span><br><span class="line">  tags:</span><br><span class="line">    - whw</span><br><span class="line">  allow_failure: true</span><br><span class="line"></span><br><span class="line">sonarqube:</span><br><span class="line">  stage: sonarqube</span><br><span class="line">  only:</span><br><span class="line">    - release-test</span><br><span class="line">    - develop</span><br><span class="line">  script:</span><br><span class="line">    - mvn sonar:sonar -Dsonar.host.url=http://sonarqube_cicd:9000 -Dsonar.language=java</span><br><span class="line">  tags:</span><br><span class="line">    - whw</span><br></pre></td></tr></table></figure>

<h1 id="GitLab-GitLab-Runner-GitLab-CI"><a href="#GitLab-GitLab-Runner-GitLab-CI" class="headerlink" title="GitLab &amp; GitLab Runner &amp; GitLab CI"></a>GitLab &amp; GitLab Runner &amp; GitLab CI</h1><p>当有项目代码提交到GitLab的时候，GitLab会通知到GitLab CI，GitLab CI根据配置的Jobs将任务分发给指定的GitLab Runner，GitLab Runner 执行配置好的的Piplelines</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> Boys, you must strive to find your own voice. Because the longer you wait to begin, the less likely you are to find it at all. - John</p>
<p><a href="https://movie.douban.com/subject/1291548/">Dead Poets Society</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Collection与Map</title>
    <url>/2018/09/09/CollectionAndMap/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/20.png" class="full-image" />

<p>记录下Java中常用的Collection与Map</p>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>常用的集合类图</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Collection_Map/Collection.png" alt="image"></p>
<h1 id="常用Collection对比"><a href="#常用Collection对比" class="headerlink" title="常用Collection对比"></a>常用Collection对比</h1><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Collection_Map/MultiCollectionDiffs.png" alt="image"></p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>常用的Map类图</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Collection_Map/Map.png" alt="image"></p>
<h1 id="常用Map对比"><a href="#常用Map对比" class="headerlink" title="常用Map对比"></a>常用Map对比</h1><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Collection_Map/MapDiffs.png" alt="image"></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> Mathematics is the only true universal language. - John Nash</p>
<p><a href="https://movie.douban.com/subject/1306029/">A Beautiful Mind</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>并发与多线程</title>
    <url>/2018/08/18/ConcurrencyThreads/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/23.png" class="full-image" />

<p>记录下并发与多线程的一些知识</p>
<h1 id="并发的前提"><a href="#并发的前提" class="headerlink" title="并发的前提"></a>并发的前提</h1><p>多核CPU与缓存</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/%E5%A4%9A%E6%A0%B8%3A%E5%A4%9ACPU.png" alt="image"></p>
<h2 id="多处理器与多核心"><a href="#多处理器与多核心" class="headerlink" title="多处理器与多核心"></a>多处理器与多核心</h2><ul>
<li>多处理器：即多个独立的CPU单元</li>
<li>多核心：每个CPU单元有单个或多个核心，当存在多核心的CPU运行多线程时，那么这些线程是可以并行的。单核心的CPU是否不存在线程的并行？并非如此，若单核心的CPU拥有<strong>Hyper-threading</strong>技术，那么单核心可以并行的运行两个逻辑线程</li>
</ul>
<h1 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发&#x2F;并行"></a>并发&#x2F;并行</h1><ul>
<li>Concurrency 指的是运行的多线程间存在资源的共享（或者运行的多线程会执行同一段代码片段）。单核、多核都可能存在并发，这种并发若不做相应的控制则会引起安全问题。并发多指发生在同一时间段</li>
<li>Parallelism 指的是在多个独立的核心或多个独立的CPU上运行的多线程，并行不存在线程间的数据共享，需要硬件支持（多核、多处理器）。并行发生在同一时刻</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/Concurrency%3AParallelism.png" alt="image"></p>
<span id="more"></span>

<h2 id="并发的场景"><a href="#并发的场景" class="headerlink" title="并发的场景"></a>并发的场景</h2><ol>
<li>多进程&#x2F;多任务：单个CPU下的并发，如在使用QQ的同时打开爱奇艺看剧</li>
<li>多线程&#x2F;子任务：单个应用下的并发，如博客网站可以处理不同用户的访问请求</li>
</ol>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>上下文切换是操作系统有能力实现多任务的重要特性。在单CPU单核心的硬件环境中，CPU需要记录当前进程或线程的运行状态，这样在切换到另一个进程或线程结束后，可以再次正确的切换回当前的进程或线程。上下文切换会带来一定的CPU消耗，因为CPU需要消耗额外的时间来挂起执行的线程并且记录、恢复线程的执行状态。上下文切换由线程调度实现</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.png" alt="image"></p>
<blockquote>
<p>进程是资源分配的最小单元，线程是CPU调度的最小单元</p>
</blockquote>
<h2 id="并发带来的问题"><a href="#并发带来的问题" class="headerlink" title="并发带来的问题"></a>并发带来的问题</h2><p>并发就是最大限度的压榨CPU能力，并发是把双刃剑，提高吞吐量&#x2F;响应速度的同时也带来了一些问题</p>
<ol>
<li>资源竞争问题：并发的读写会导致结果依赖于读写操作的顺序，而这种顺序是不可控的</li>
<li>内存一致性问题：多线程共同可见一块内存，当某一线程修改了共享内存区域的数据，可能导致其他线程不可见。在Java中使用<a href="http://whathowhy.com/2018/05/15/volatile/">Volatile</a>关键字能够解决缓存一致性问题</li>
</ol>
<h3 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h3><p>针对并发的问题，常用的解决方案是使用互斥锁（Lock&#x2F;Synchronize），互斥锁会使线程调度将多线程的执行强制为串行，互斥控制可能会导致其他CPU资源的浪费</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> I’m not a righteous man. I’m just one man. - Oskar Schindler</p>
<p><a href="https://movie.douban.com/subject/1295124/">Schindler’s List</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-装饰者</title>
    <url>/2023/03/02/DecoratorDesign/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/51.png" class="full-image" />

<p>装饰者模式可以在不影响原对象结构的情况下，在运行时动态的添加、增强或删除对象的行为或状态。当然通过继承类的方式也可以扩展类的行为和状态，但这种扩展是在编译期间完成的，无法做到动态扩展，使用继承来扩展类很容易导致类的数量爆增。装饰者模式可以提高系统的灵活性和扩展性，该模式在 Java IO 中经常被使用，如：FileReader、BufferedReader 等。本篇文章将以博客发布为例，来说明装饰者设计模式的特点</p>
<span id="more"></span>


<h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><p>下图展示了博客文章支持发布到不同平台的简单架构实现，通过继承的方式进行博客发布平台的扩展</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/decorator/blog.png" alt="imag"></p>
<p>这种架构抽象方式非常简单，不同发布平台的扩展也很容易。但如果我想多个平台一起发布博客内容呢？我们在此基础上扩展试试看。同时在个人网站和CSDN发布、同时在知乎和CSDN发布</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/decorator/blog_extend.png" alt="imag"></p>
<p>如果现在需要同时在所有平台发布博客内容呢？类继承方式的扩展会导致类的数量急速增加，同时过多功能的组合也导致类方法的职责过多，违反了 <strong>SRP</strong> 设计原则，这样的代码不够整洁，这也使得系统难以维护</p>
<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>装饰者模式是一种结构型设计模式，主要包含如下几个部分</p>
<ul>
<li>Component: 抽象组件，可以是抽象类或接口</li>
<li>ConcreteComponent: 具体组件，具体行为状态的对象</li>
<li>Decorator: 抽象装饰者，是所有具体装饰者的基类</li>
<li>ConcreteDecorator: 具体装饰者，实现了Decorator，并添加了一些附加的行为和状态</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/decorator/decorator.png" alt="imag"></p>
<p>这里的 Client 表示使用方，使用方依赖抽象而不是具体实现，这同时也符合 <strong>DIP</strong> 设计原则。我们来看看通过装饰者实现，如何体现出更好的系统灵活性</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/decorator/blog_decorator.png" alt="imag"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 个人网站发布</span></span><br><span class="line"><span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonalWebsite</span>();</span><br><span class="line">blog.publish();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 知乎和个人网站发布</span></span><br><span class="line">blog = <span class="keyword">new</span> <span class="title class_">ZhihuDecorator</span>(blog);</span><br><span class="line">blog.publish();</span><br><span class="line"></span><br><span class="line"><span class="comment">// CSDN、知乎和个人网站发布</span></span><br><span class="line">blog = <span class="keyword">new</span> <span class="title class_">CSDNDecorator</span>(blog);</span><br><span class="line">blog.publish();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信公众号、CSDN、知乎和个人网站发布</span></span><br><span class="line">blog = <span class="keyword">new</span> <span class="title class_">WechatDecorator</span>(blog);</span><br><span class="line">blog.publish();</span><br></pre></td></tr></table></figure>

<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>装饰者模式常见应用场景</p>
<ol>
<li>为一个对象提供多层次的功能扩展</li>
<li>动态且透明的处理对象的行为或状态</li>
</ol>
]]></content>
      <categories>
        <category>Design Pattern</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Compose</title>
    <url>/2019/09/18/Docker-Compose/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/12.png" class="full-image" />

<h1 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h1><p>Docker Compose是用Python编写的工具，并不包含在Docker Engine安装包中。Docker Compose用于解析YML文件并运行YML中定义的容器服务。Docker Compose命令通过调用Docker API完成多容器的创建启动，使用Docker Compose需要自行安装</p>
<h2 id="Docker-Compose-VS-Docker-Stack"><a href="#Docker-Compose-VS-Docker-Stack" class="headerlink" title="Docker Compose VS Docker Stack"></a>Docker Compose VS Docker Stack</h2><ul>
<li>docker stack 包含在 swarm mode中，swarm mode 已经被集成到Docker Engine中，由GO语言编写。docker compose 需要自行安装，由Python编写</li>
<li>docker stack 只支持 <strong>version &gt;&#x3D; 3</strong> 的YML定义且部分命令无法生效如  <strong>build</strong>。docker compose 对YML的不同version处理都没有问题</li>
<li>docker stack 可以将服务分发到不同的主机上，docker compose 只能将服务分发到同一台主机上</li>
</ul>
<span id="more"></span>

<h1 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h1><p>为什么要使用Docker Compose ? </p>
<h2 id="服务发布"><a href="#服务发布" class="headerlink" title="服务发布"></a>服务发布</h2><p>以下是需要容器化的服务</p>
<ul>
<li>product-service 商品服务</li>
<li>shopping-service 商店服务，两套界面</li>
<li>redis-service 数据缓存</li>
<li>front-balance 商店服务负载</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Docker/docker-compose.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEFORE COMPOSE :</span><br><span class="line"></span><br><span class="line">docker run -itd --name redis-service --network=backend -p 16379:6379 redis</span><br><span class="line">docker run -itd --name product-service --network=backend -p 15000:5000 8lovelife/product:latest</span><br><span class="line">docker network connect frontend product-service</span><br><span class="line">docker run -itd --name shopping-service-blue --network=frontend -p 28080:80 8lovelife/shopping:blue</span><br><span class="line">docker run -itd --name shopping-service-red --network=frontend -p 18080:80 8lovelife/shopping:red</span><br><span class="line">docker run -itd --name front-balance --network=frontend -p 80:80 8lovelife/frontbalance:latest</span><br><span class="line"></span><br><span class="line">AFTER COMPOSE :</span><br><span class="line"></span><br><span class="line">docker-compose -f docker-compose-product.yml up -d</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h1><p>如何使用Docker Compose ?</p>
<h2 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOPPING Dockerfile:</span><br><span class="line"></span><br><span class="line">FROM node:11.1.0-alpine as build</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY package*.json /app/</span><br><span class="line">RUN npm install</span><br><span class="line">COPY ./ /app/</span><br><span class="line">RUN npm run build</span><br><span class="line"></span><br><span class="line">FROM nginx:1.17.3-alpine</span><br><span class="line">COPY --from=build /app/build /usr/share/nginx/html</span><br><span class="line">COPY --from=build /app/nginx.conf /etc/nginx/nginx.conf</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PRODUCT Dockerfile:</span><br><span class="line"></span><br><span class="line">FROM maven:3-jdk-8 as build</span><br><span class="line">RUN mkdir -p /build</span><br><span class="line">WORKDIR /build</span><br><span class="line">COPY pom.xml /build</span><br><span class="line">RUN mvn -B dependency:resolve dependency:resolve-plugins</span><br><span class="line">COPY src /build/src</span><br><span class="line">RUN mvn package -Dmaven.test.skip=true</span><br><span class="line"></span><br><span class="line">FROM openjdk:8-jdk-alpine as runtime</span><br><span class="line">EXPOSE 5000</span><br><span class="line">ENV APP_HOME /app</span><br><span class="line">RUN mkdir $APP_HOME</span><br><span class="line">WORKDIR $APP_HOME</span><br><span class="line">COPY --from=build /build/target/*.jar app.jar</span><br><span class="line">ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar app.jar&quot; ]</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="YML定义"><a href="#YML定义" class="headerlink" title="YML定义"></a>YML定义</h2><p>本文事例使用的docker-compose-product.yml文件内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services: </span><br><span class="line"></span><br><span class="line">  product-service:</span><br><span class="line">    image: &quot;8lovelife/product:latest&quot;</span><br><span class="line">    ports: </span><br><span class="line">      - &quot;15000:5000&quot;</span><br><span class="line">    networks: </span><br><span class="line">      - frontend</span><br><span class="line">      - backend</span><br><span class="line">    environment: </span><br><span class="line">      - REDIS_HOST=redis-service</span><br><span class="line">      - REDIS_PORT=6379</span><br><span class="line">  </span><br><span class="line">  shopping-service-red:</span><br><span class="line">    image: &quot;8lovelife/shopping:red&quot;</span><br><span class="line">    ports: </span><br><span class="line">      - &quot;18080:80&quot;</span><br><span class="line">    networks: </span><br><span class="line">      - frontend</span><br><span class="line"></span><br><span class="line">  shopping-service-blue:</span><br><span class="line">    image: &quot;8lovelife/shopping:blue&quot;</span><br><span class="line">    ports: </span><br><span class="line">      - &quot;28080:80&quot;</span><br><span class="line">    networks: </span><br><span class="line">      - frontend</span><br><span class="line"></span><br><span class="line">  redis-service:</span><br><span class="line">    image: &quot;8lovelife/redis:products&quot;</span><br><span class="line">    ports: </span><br><span class="line">      - &quot;16379:6379&quot;</span><br><span class="line">    volumes: </span><br><span class="line">      - redis_data:/data</span><br><span class="line">    networks: </span><br><span class="line">      - &quot;backend&quot;</span><br><span class="line">  </span><br><span class="line">  front-balance:</span><br><span class="line">    image: &quot;8lovelife/frontbalance:latest&quot;</span><br><span class="line">    ports: </span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks: </span><br><span class="line">      - &quot;frontend&quot;</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  frontend: &#123;&#125;</span><br><span class="line">  backend: &#123;&#125;</span><br><span class="line"></span><br><span class="line">volumes: </span><br><span class="line">  redis_data: &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="构建或拉取镜像"><a href="#构建或拉取镜像" class="headerlink" title="构建或拉取镜像"></a>构建或拉取镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 绝对路径</span><br><span class="line">build: .</span><br><span class="line"></span><br><span class="line"># 相对路径</span><br><span class="line">build: ../path/to/app/</span><br><span class="line"></span><br><span class="line"># Git仓库</span><br><span class="line">build: https://url.git</span><br><span class="line"></span><br><span class="line"># 指定分支的Git仓库 </span><br><span class="line">build: https://url.git#develop</span><br><span class="line"></span><br><span class="line"># 含access_token的Git仓库链接</span><br><span class="line">build: https://&lt;ACCESS_TOKEN&gt;:@github.com/demo.git</span><br></pre></td></tr></table></figure>

<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">product-service:</span><br><span class="line">  image: &quot;8lovelife/product:latest&quot;</span><br><span class="line">  environment: </span><br><span class="line">    - REDIS_HOST=redis-service</span><br><span class="line">    - REDIS_PORT=6379</span><br></pre></td></tr></table></figure>

<h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">product-service:</span><br><span class="line">  image: &quot;8lovelife/product:latest&quot;</span><br><span class="line">  ports: </span><br><span class="line">    - &quot;15000:5000&quot;</span><br><span class="line">  networks: </span><br><span class="line">    - frontend</span><br><span class="line">    - backend</span><br><span class="line">    </span><br><span class="line">networks:</span><br><span class="line">  frontend: &#123;&#125;</span><br><span class="line">  backend: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置数据卷"><a href="#配置数据卷" class="headerlink" title="配置数据卷"></a>配置数据卷</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-service:</span><br><span class="line">  image: &quot;redis:latest&quot;</span><br><span class="line">  ports: </span><br><span class="line">    - &quot;16379:6379&quot;</span><br><span class="line">  volumes: </span><br><span class="line">    - redis_data:/data</span><br><span class="line">  networks: </span><br><span class="line">    - &quot;backend&quot;</span><br><span class="line">    </span><br><span class="line">volumes: </span><br><span class="line">  redis_data: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建运行"><a href="#构建运行" class="headerlink" title="构建运行"></a>构建运行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose-product.yml up -d</span><br><span class="line"></span><br><span class="line">docker-compose --help compose命令帮助</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> If you can’t fix it, you gotta stand it. - Jack</p>
<p><a href="https://movie.douban.com/subject/3541415/">Inception</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Plugin</title>
    <url>/2018/03/30/Docker-Plugin/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/40.png" class="full-image" />

<!-- # Docker Plugin -->

<p>简单记录下我在<strong>IntelliJ IDEA</strong>中如何使用<strong>Docker</strong></p>
<h1 id="Intellij-Idea-配置Docker"><a href="#Intellij-Idea-配置Docker" class="headerlink" title="Intellij Idea 配置Docker"></a>Intellij Idea 配置Docker</h1><blockquote>
<p><strong>Docker</strong> ：Docker是目前比较流行的容器，帮你管理应用服务    —— <a href="https://www.docker.com/">Docker官网</a></p>
</blockquote>
<h2 id="下载Docker插件"><a href="#下载Docker插件" class="headerlink" title="下载Docker插件"></a>下载Docker插件</h2><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerPD.png" alt="这里写图片描述"></p>
<h2 id="启动Docker-Daemon"><a href="#启动Docker-Daemon" class="headerlink" title="启动Docker Daemon"></a>启动Docker Daemon</h2><blockquote>
<p>启用TCP连接：<br><em><strong>sudo docker daemon -H tcp:&#x2F;&#x2F;0.0.0.0:4243 -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</strong></em></p>
</blockquote>
<h2 id="Certificates"><a href="#Certificates" class="headerlink" title="Certificates"></a>Certificates</h2><blockquote>
<p>将Docker登录证书拷贝到本地，准备连接</p>
</blockquote>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerC.png" alt="这里写图片描述"></p>
<span id="more"></span>

<h2 id="连接Docker"><a href="#连接Docker" class="headerlink" title="连接Docker"></a>连接Docker</h2><p> <strong>Intellij Idea 15.0</strong><br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerL1.png" alt="这里写图片描述"><br><strong>Intellij Idea 2016</strong><br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerL2.png" alt="这里写图片描述"></p>
<h2 id="配置Docker-Registry"><a href="#配置Docker-Registry" class="headerlink" title="配置Docker Registry"></a>配置Docker Registry</h2><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerR.png" alt="这里写图片描述"></p>
<h1 id="Deploy-on-Docker"><a href="#Deploy-on-Docker" class="headerlink" title="Deploy on Docker"></a>Deploy on Docker</h1><h2 id="Run-Debug-Configurations"><a href="#Run-Debug-Configurations" class="headerlink" title="Run&#x2F;Debug Configurations"></a>Run&#x2F;Debug Configurations</h2><blockquote>
<p>构建Docker镜像 Dockerfile（build image）<br><em><strong>Dockerfile:</strong></em><br>FROM tomcat<br>ADD HelloWorld.war &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps </p>
</blockquote>
<blockquote>
<p>Docker容器参数配置<br><em><strong>Container.json:</strong></em><br>{<br>  “HostConfig”: {<br>    “PortBindings”:{ “8080&#x2F;tcp”: [{ “HostIp”: “0.0.0.0”, “HostPort”: “18080” }] }<br>  }<br>}</p>
</blockquote>
<p><strong>发布镜像</strong></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerImage.png" alt="这里写图片描述"></p>
<p><strong>加载容器配置JSON file</strong></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerJson.png" alt="这里写图片描述"></p>
<h3 id="Start-Docker"><a href="#Start-Docker" class="headerlink" title="Start Docker"></a>Start Docker</h3><p><strong>localhost:18080&#x2F;HelloWorld</strong><br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerStart.png" alt="这里写图片描述"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.docker.com/">Docker</a><br><a href="https://www.jetbrains.com/help/idea/2016.1/run-debug-configuration-docker-deployment.html">IntelliJ IDEA</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> It’s a lonely place. You got to keep talking to yourself.</p>
<p><a href="https://movie.douban.com/subject/3073124/">Moon</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器</title>
    <url>/2019/10/13/DockerContainer/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/11.png" class="full-image" />

<h1 id="容器是什么"><a href="#容器是什么" class="headerlink" title="容器是什么"></a>容器是什么</h1><p>简单来说，容器通过利用操作系统的一些底层技术（Namespace、UnionFS、Cgroup等）来运行一些进程。Docker封装了这些底层技术（Container format），方便用户去使用</p>
<h1 id="容器的好处"><a href="#容器的好处" class="headerlink" title="容器的好处"></a>容器的好处</h1><ul>
<li>可移植性&#x2F;快速部署: 不需要关心不同的运行环境，容器运行所需的库都是打包好的一个整体</li>
<li>应用打包灵活高效: 由于image的分层共享设计，需要更换某一层的内容变得高效灵活</li>
<li>提升资源利用率（相比VM）: 共享底层的操作系统，管理程序没有额外的开销</li>
</ul>
<span id="more"></span>

<h1 id="VM-VS-Container"><a href="#VM-VS-Container" class="headerlink" title="VM VS Container"></a>VM VS Container</h1><p>虚拟机与容器的不同</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Docker/vmvscontainer.png" alt="image"></p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>概述</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Docker/docker_architecture.png" alt="image"></p>
<h2 id="Image-Volume"><a href="#Image-Volume" class="headerlink" title="Image &#x2F; Volume"></a>Image &#x2F; Volume</h2><p><a href="https://whathowhy.com/2018/03/30/Docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/">Docker容器中的数据管理</a></p>
<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><ol>
<li><strong>Default Bridge</strong></li>
</ol>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Docker/Default%20Bridge.png" alt="image"></p>
<ol start="2">
<li><strong>User Defined Bridge</strong></li>
</ol>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Docker/userdefined%20bridge.png" alt="image"></p>
<ol start="3">
<li><strong>Overlay Network</strong></li>
</ol>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Docker/overlay%20network.png" alt="image"></p>
<ol start="4">
<li><strong>Ingress Network</strong></li>
</ol>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Docker/Ingress%20network.png" alt="image"></p>
<p><a href="https://whathowhy.com/2018/03/30/Docker%E5%AE%B9%E5%99%A8%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/">Docker容器间的通信</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> The dead remember their loved ones by keeping their memories alive. - Miguel’s great-great-grandmother Coco</p>
<p><a href="https://movie.douban.com/subject/20495023/">Coco</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器中的数据管理</title>
    <url>/2018/03/30/DockerData/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/36.png" class="full-image" />

<!-- # Docker Data -->

<p>简单记录下Docker容器的数据管理</p>
<h1 id="Docker镜像的存储"><a href="#Docker镜像的存储" class="headerlink" title="Docker镜像的存储"></a><em><strong>Docker镜像的存储</strong></em></h1><blockquote>
<ol>
<li>Docker镜像是一层一层叠出来的，Dockerfile中的每一行指令都会产生一层,镜像中的数据对容器是只读的</li>
<li>dockerfile中的命令可以直接访问底层（lower layer）已经产生的数据，当发生数据文件的修改时则会将底层文件复制到当前layer进行处理</li>
<li><code>docker history 镜像ID</code>展示镜像组成结构</li>
<li>存储结构图</li>
</ol>
</blockquote>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerImageData.png" alt="这里写图片描述"></p>
<blockquote>
<ol start="5">
<li>docker的<strong>storage driver</strong>负责处理每层数据处理与存储</li>
</ol>
</blockquote>
<h1 id="Docker容器的存储"><a href="#Docker容器的存储" class="headerlink" title="Docker容器的存储"></a><em><strong>Docker容器的存储</strong></em></h1><blockquote>
<ol>
<li>Docker容器在镜像的基础之上又叠了一层（Container layer即Thin R／W层，每个容器都会有自己的Thin R／W层，镜像可以共享）</li>
<li><code>docker ps -s</code>命令能够查看当前运行容器的大小</li>
<li>当Container layer层发生数据文件的修改时则会将底层文件复制到当前layer进行处理即docker中的copy-on-write (CoW)策略，不同于虚拟机的本质。</li>
<li>存储结构图<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerStoreData.png" alt="这里写图片描述"></li>
<li><strong>Container layer</strong>中的数据应该尽量的少，减少镜像大小，storage driver的引入同样会带来性能的下降并且在容器停止后数据将会消失。应该使用volumes（宿主机文件系统可持久化）</li>
</ol>
</blockquote>
<span id="more"></span>
<h1 id="DATA-VOLUMES"><a href="#DATA-VOLUMES" class="headerlink" title="DATA VOLUMES"></a><em><strong>DATA VOLUMES</strong></em></h1><blockquote>
<p> docker提供了三种类型的数据挂载：volume,bind mount,tmpfs mount，挂载的数据能够传递到容器内部，容器中的数据也会回传到挂在目录或文件中<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerVolume.png" alt="这里写图片描述"></p>
</blockquote>
<h2 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h2><blockquote>
<ol>
<li>Volumes是最理想的容器数据持久化选择。数据存储在宿主机中的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;目录下，非docker进程不能够修改，由docker进行管理。好处如：Docker<br>CLI 扩展，容器间共享数据更加安全等</li>
<li>volumes由volume driver的支持使容器能够加载远端的数据</li>
<li>volume使用：<code>docker run -d -it --name devtest --mount source=devtest,target=/app nginx</code>，devtest不存在会自动创建</li>
</ol>
</blockquote>
<h2 id="Bind-mount"><a href="#Bind-mount" class="headerlink" title="Bind mount"></a>Bind mount</h2><blockquote>
<ol>
<li>Bind mount挂载的文件或文件夹必须有存在的全路径</li>
<li>Bind mount多用于容器共享宿主机中的配置文件，如&#x2F;etc&#x2F;resolv.conf</li>
<li>Bind mount使用：<code>docker run -itd --name devtest --mount type=bind,source=/tmp,target=/app nginx</code>,若app中已经存在数据，则tmp会掩盖app中的数据</li>
</ol>
</blockquote>
<h2 id="tmpfs-mount"><a href="#tmpfs-mount" class="headerlink" title="tmpfs mount"></a>tmpfs mount</h2><blockquote>
<ol>
<li>tmpfs挂载的数据被存在宿主机的内存中</li>
<li>当数据不需要持久化可以使用此挂载类型，如：系统启动使用的一次性数据</li>
<li>tmpfs mount使用： <code>docker run -d -it --name tmptest --mount type=tmpfs,destination=/app nginx</code></li>
</ol>
</blockquote>
<h1 id="删除未使用Docker对象"><a href="#删除未使用Docker对象" class="headerlink" title="删除未使用Docker对象"></a><em><strong>删除未使用Docker对象</strong></em></h1><blockquote>
<p>Images，Containers，Volumes和Networks这些docker对象不会被删除（除非指定删除），未被使用的docker对象仍然占据着磁盘空间，docker提供了相应的修剪方法</p>
</blockquote>
<h2 id="删除无用镜像"><a href="#删除无用镜像" class="headerlink" title="删除无用镜像"></a>删除无用镜像</h2><blockquote>
<ol>
<li><code>docker image prune</code>      #删除未打标签并且未被使用的镜像</li>
<li><code>docker image prune -a</code>   #删除所有未被容器使用的镜像</li>
</ol>
</blockquote>
<h2 id="删除没有运行的容器"><a href="#删除没有运行的容器" class="headerlink" title="删除没有运行的容器"></a>删除没有运行的容器</h2><blockquote>
<p><code>docker container prune</code></p>
</blockquote>
<h2 id="删除没有被容器引用的volume"><a href="#删除没有被容器引用的volume" class="headerlink" title="删除没有被容器引用的volume"></a>删除没有被容器引用的volume</h2><blockquote>
<p><code>docker volume prune</code></p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.docker.com/engine/admin/volumes/">Docker v17.09</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> When the going gets tough, the tough get going. - Parzival</p>
<p><a href="https://movie.douban.com/subject/4920389/">Ready Player One</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker快速构建开发测试环境</title>
    <url>/2018/03/30/DockerDevImage/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/39.png" class="full-image" />

<!-- # 使用Docker快速构建开发调试环境 -->

<p>简单记录下我在开发过程中,如何快速构建调试环境</p>
<h1 id="RedisService"><a href="#RedisService" class="headerlink" title="RedisService"></a>RedisService</h1><blockquote>
<ul>
<li>下载Redis image</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>启动Redis</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --restart=always -d -ti --name redisService \</span><br><span class="line">-v /home/core/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf \</span><br><span class="line">-v /home/core/redis/data:/data -p 16379:6379 redis \</span><br><span class="line">redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>登录Redis</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it redisService redis-cli --raw -a redis</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="MysqlService"><a href="#MysqlService" class="headerlink" title="MysqlService"></a>MysqlService</h1><blockquote>
<ul>
<li>下载Mysql image</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>启动Mysql</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --restart=always -it --name mysqlService \</span><br><span class="line">-v /home/core/mysql/data/:/var/lib/mysql \</span><br><span class="line">-v /home/core/mysql/conf.d:/etc/mysql/conf.d \</span><br><span class="line">-p 13306:3306 -e MYSQL\_ROOT\_PASSWORD=12345 -d mysql</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<hr>
<h1 id="MongoService"><a href="#MongoService" class="headerlink" title="MongoService"></a>MongoService</h1><blockquote>
<ul>
<li>下载Mongo image</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mongo</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>启动MongoDB</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -ti --restart=always --name mongoService \</span><br><span class="line">-v /home/core/mongo/data:/data/db -p 27017:27017 \</span><br><span class="line">-d mongo --auth</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>登录Mongo,建立用户</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mongoService mongo admin;</span><br><span class="line">db.createUser(&#123;user:&#x27;admin&#x27;,pwd:&#x27;admin&#x27;,roles:[&#123;role:&#x27;root&#x27;,db:&#x27;admin&#x27;&#125;]&#125;);</span><br><span class="line">db.auth(&#x27;admin&#x27;,&#x27;admin&#x27;);</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>创建collection dmz_inward下的普通用户</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use dmz_inward;</span><br><span class="line">db.createUser(&#123;user:&#x27;dmz&#x27;,pwd:&#x27;dmz&#x27;,roles: [&#123;role:&#x27;readWrite&#x27;,db:&#x27;dmz_inward&#x27;&#125;]&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="NginxService"><a href="#NginxService" class="headerlink" title="NginxService"></a>NginxService</h1><blockquote>
<ul>
<li>下载Nginx image</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>启动Nginx</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --restart=always --name nginxService -p 80:80 \</span><br><span class="line">-v /home/core/yourResources: /usr/share/nginx/html:ro \</span><br><span class="line">-v /logs:/var/log/nginx \</span><br><span class="line">-v /home/core/conf/nginx/nginx.conf:ro -d nginx</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="RabbitmqService"><a href="#RabbitmqService" class="headerlink" title="RabbitmqService"></a>RabbitmqService</h1><blockquote>
<ul>
<li>下载rabbitmq:3-management</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>启动rabbitmq:3-management</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --restart=always --name rabbitmqService \</span><br><span class="line">--hostname fRabbit \</span><br><span class="line">-p 5672:5672 -p 15672:15672 \</span><br><span class="line">-v /home/core/rabbitmq/data:/var/lib/rabbitmq/mnesia/rabbit@fRabbit \</span><br><span class="line">-v /home/core/rabbitmq/conf/rabbitmq.config:/etc/rabbitmq/rabbitmq.config:ro \</span><br><span class="line">-d rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>rabbitmq.config配置</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ &#123; rabbit, [</span><br><span class="line">        &#123; loopback_users, [ ] &#125;,</span><br><span class="line">        &#123; tcp_listeners, [ 5672 ] &#125;,</span><br><span class="line">        &#123; default_user, &lt;&lt;&quot;dmz&quot;&gt;&gt; &#125;, #用户名</span><br><span class="line">        &#123; default_pass, &lt;&lt;&quot;dmz&quot;&gt;&gt; &#125;, #密码</span><br><span class="line">        &#123; ssl_listeners, [ ] &#125;,</span><br><span class="line">        &#123; hipe_compile, false &#125;</span><br><span class="line">        ] </span><br><span class="line">&#125;,&#123;rabbitmq_management, [&#123;listener, [&#123;port, 15672&#125;]&#125;]&#125; ]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>访问rabbitmq管理界面<br><a href="http://ip:15672/">http://ip:15672</a></li>
</ul>
</blockquote>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/RabbitManage.png" alt="image"></p>
<hr>
<h1 id="Portainer"><a href="#Portainer" class="headerlink" title="Portainer"></a>Portainer</h1><p>漂亮的docker容器管理界面</p>
<blockquote>
<ul>
<li>下载portainer image</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull portainer/portainer`</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>启动Portainer</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name=portainer \</span><br><span class="line">-p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>访问<br><a href="http://ip:9000/">http://ip:9000</a></li>
</ul>
</blockquote>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Portainer.png" alt="image"></p>
<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><p><a href="http://whathowhy.com/2018/10/13/Kafka-On-Docker/">Kafka</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hub.docker.com/">Docker Hub</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> It’s not like he’s dead or anything. He’s just… different. - Christopher Johnson</p>
<p><a href="https://movie.douban.com/subject/3006772/">District 9</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器间的通信</title>
    <url>/2018/03/30/DockerNetwork/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/37.png" class="full-image" />

<!-- # Docker Network -->

<p>简单记录下容器间的网络通信。</p>
<h1 id="网络驱动"><a href="#网络驱动" class="headerlink" title="网络驱动"></a><em><strong>网络驱动</strong></em></h1><blockquote>
<ol>
<li><strong>network drivers</strong>是docker提供容器间网络通信的基础。docker默认提供了两中驱动：bridge和overlay</li>
<li><code>docker network ls</code>指令会列出当前存在的网络 </li>
<li>docker在安装完成后会自动创建三个网络<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerBridge.png" alt="这里写图片描述"></li>
</ol>
</blockquote>
<h1 id="BRIDGE"><a href="#BRIDGE" class="headerlink" title="BRIDGE"></a><em><strong>BRIDGE</strong></em></h1><blockquote>
<ol>
<li><p>宿主机中使用<code>ip addr show</code>查看网卡状况<br>   <img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerIp.png" alt="这里写图片描述"></p>
</li>
<li><p><strong>docker0</strong>为宿主机中的虚拟网桥即为docker自动创建的bridge网络</p>
</li>
<li><p><strong>bridge</strong>为docker运行容器（<code>docker run</code>）默认使用的网络</p>
</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="容器与外部的网络通信前提"><a href="#容器与外部的网络通信前提" class="headerlink" title="容器与外部的网络通信前提"></a><strong>容器与外部的网络通信前提</strong></h2><blockquote>
<ol>
<li>保证宿主机开启了ip_forward功能</li>
<li>保证iptables的相关策略的设置，如地址伪装,NAT等</li>
</ol>
</blockquote>
<h2 id="宿主机与容器的端口映射"><a href="#宿主机与容器的端口映射" class="headerlink" title="宿主机与容器的端口映射"></a><strong>宿主机与容器的端口映射</strong></h2><blockquote>
<ol>
<li><p><code>docker run -itd -P --name mongoService mongo</code>，-P表示：容器暴露的端口将会映射到宿主机中的随机端口号，随机范围见：&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_local_port_range</p>
</li>
<li><p>每当启动容器与外部网络的通信，docker都会建立响应的iptables规则。<code>iptables -L -n -t nat</code>查看规则</p>
</li>
</ol>
</blockquote>
<h1 id="容器间的网络通信"><a href="#容器间的网络通信" class="headerlink" title="容器间的网络通信"></a><em><strong>容器间的网络通信</strong></em></h1><blockquote>
<p>容器间可以通过IP或容器名进行网络通信</p>
</blockquote>
<h2 id="使用自己创建的NETWORK"><a href="#使用自己创建的NETWORK" class="headerlink" title="使用自己创建的NETWORK"></a><strong>使用自己创建的NETWORK</strong></h2><blockquote>
<ol>
<li><p>创建my_bridge网络:  <code>docker network create -d bridge --subnet=10.0.0.0/24 my_bridge</code></p>
</li>
<li><p>运行使用my_bridge网络的容器  <code>docker run -itd --network=my_bridge --ip=10.0.0.254 --name db busybox</code></p>
</li>
</ol>
</blockquote>
<h2 id="不同NETWORK间的容器通信"><a href="#不同NETWORK间的容器通信" class="headerlink" title="不同NETWORK间的容器通信"></a><strong>不同NETWORK间的容器通信</strong></h2><blockquote>
<ol>
<li><code>docker run -itd --name=web busybox</code>,使用默认的bridge network</li>
<li>将当前容器加入到需要与之通信的网络  <code>docker network connect my_bridge web</code></li>
<li>网络结构</li>
</ol>
</blockquote>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerNetWork.png" alt="这里写图片描述"></p>
<h1 id="容器DNS"><a href="#容器DNS" class="headerlink" title="容器DNS"></a><em><strong>容器DNS</strong></em></h1><blockquote>
<p>容器间如何通过别名进行网络通信？</p>
</blockquote>
<h2 id="默认bridge网络"><a href="#默认bridge网络" class="headerlink" title="默认bridge网络"></a><strong>默认bridge网络</strong></h2><blockquote>
<pre><code>   -- 创建测试容器
   docker run -itd --name c1 busybox
   docker run -itd --name c2 busybox
</code></pre>
</blockquote>
<blockquote>
<pre><code>   -- 进入容器c1内部
   docker attach c1
   / # ping c2
   ping: bad address &#39;c2&#39;

   -- 创建容器时指定link容器
   docker run -itd  --link c2:c2_alias --name c3 busybox

   -- 进入容器c3内部
   docker attach c3
   / # ping -w1 c2
   PING c2 (172.17.0.4): 56 data bytes
   64 bytes from 172.17.0.4: seq=0 ttl=64 time=0.083 ms
   / # ping -w1 c2_alias
   PING c2_alias (172.17.0.4): 56 data bytes
   64 bytes from 172.17.0.4: seq=0 ttl=64 time=0.096 ms
   / # cat /etc/hosts #（容器别名相互耦合）
   127.0.0.1	localhost
   ::1	localhost ip6-localhost ip6-loopback
   fe00::0	ip6-localnet
   ff00::0	ip6-mcastprefix
   ff02::1	ip6-allnodes
   ff02::2	ip6-allrouters
   172.17.0.4	c2_alias 7e4850ad6320 c2  #通信原因
   172.17.0.6	fe51353cb1e3

   -- 进入容器c2内部
   docker attach c2
   / # ping c3
   ping: bad address &#39;c3&#39;
</code></pre>
</blockquote>
<h2 id="用户创建的bridge网络"><a href="#用户创建的bridge网络" class="headerlink" title="用户创建的bridge网络"></a><strong>用户创建的bridge网络</strong></h2><blockquote>
<pre><code>   -- 创建测试容器
   docker run -itd --name c4 --net=my_bridge busybox
   docker run -itd --name c5 --net=my_bridge busybox

   -- 进入容器c4内部
   docker attach c4
   / # ping -w1 c5  #（自动创建DNS服务）
   PING c5 (10.0.0.3): 56 data bytes
   64 bytes from 10.0.0.3: seq=0 ttl=64 time=0.066 ms
</code></pre>
</blockquote>
<h2 id="网络层可见别名"><a href="#网络层可见别名" class="headerlink" title="网络层可见别名"></a><strong>网络层可见别名</strong></h2><blockquote>
<pre><code>  -- 创建测试容器
  docker run -itd --name c7 --net=my_bridge --network-alias c7_net_alias busybox
  -- 进入容器c4内部
  docker attach c4
  / # ping -w1 c7_net_alias
  PING c7_net_alias (10.0.0.5): 56 data bytes
  64 bytes from 10.0.0.5: seq=0 ttl=64 time=0.205 ms
</code></pre>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.docker.com/engine/userguide/networking/">Docker v17.09</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> Mars will come to fear my botany skills. - Mark Watney</p>
<p><a href="https://movie.douban.com/subject/25864085/">The Martian</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Swarm 集群</title>
    <url>/2018/03/30/DockerSwarm/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/35.png" class="full-image" />

<!-- # Docker Swarm Mode -->

<p>简单记录下Docker集群swarm使用。</p>
<h1 id="Docker集群模式"><a href="#Docker集群模式" class="headerlink" title="Docker集群模式"></a><strong>Docker集群模式</strong></h1><blockquote>
<p>docker swarm模式可以让多个运行docker的机器加入集群管理，加入集群的docker机器被称为node。整个集群被node为manager的角色管理，其他的node角色则为workers，所有workers接受manager的指令行事</p>
</blockquote>
<h2 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h2><p><em>集群机器可以是物理机也可以是虚拟机，由于资源匮乏。本文只有一个 swarm node</em></p>
<blockquote>
<ol>
<li>Manager Node：当发布service到swarm中（提交到管理节点），管理节点将service分发到Worker Node，工作节点接收到task开始工作</li>
<li>Worker Node：工作节点接受来自管理节点分发的任务并执行，同时会将自己当前的状态通知到管理节点，管理者能够管理集群中节点的状态。Manager Node同时也可以是Worker Node</li>
<li>开启swarm模式：<code>docker swarm init</code></li>
<li>离开swarm：<code>docker swarm leave --force</code></li>
<li>Node工作方式<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerNode.png" alt="这里写图片描述"></li>
</ol>
</blockquote>
<h2 id="Services-and-tasks"><a href="#Services-and-tasks" class="headerlink" title="Services and tasks"></a>Services and tasks</h2><blockquote>
<ol>
<li>Services：任务的定义，创建service有两种模式。<code>replicated services</code>可以指定创建服务的副本数量由manager node分发到不同节点。<code>global services</code>模式的服务将在集群中所有节点上运行</li>
<li>tasks：任务是管理节点分发运行的单元</li>
<li>构建副本服务：<code>docker service create --replicas 3 --name web nginx</code>,service只有在swarm模式下才能创建</li>
<li>服务与任务的关系<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerTask.png" alt="这里写图片描述"></li>
<li>replicated services和global services<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerService.png" alt="这里写图片描述"></li>
</ol>
</blockquote>
<span id="more"></span>

<h1 id="集群网络"><a href="#集群网络" class="headerlink" title="集群网络"></a><strong>集群网络</strong></h1><p><em>docker swarm保证两种不同的通讯。<code>管理通讯，如加入或是离开swarm</code> 和 <code>响应来自客户端的请求</code></em> </p>
<blockquote>
<ol>
<li>Overlay networks： 管理swarm模式下docker daemons间的通信，service同样也可以加入此网络使service间能够相互通信。此网络使用overlay网络驱动</li>
<li>ingress network ：  此网络提供了服务的负载均衡能力。当客户端请求服务，ingress network中内建的负载均衡模块（IPVS）会将请求负载到指定的IP服务。此网络使用overlay网络驱动</li>
<li>docker_gwbridge：    此网络负责将Overlay networks和ingress network连通到docker daemon的物理网卡上，创建的service默认会连接到此网络。此网络使用bridge网络驱动</li>
</ol>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.docker.com/get-started/part4/">Docker v17.09</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> I see you. - Jake Sully</p>
<p><a href="https://movie.douban.com/subject/1652587/">Avatar</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Dockerfile构建Docker镜像</title>
    <url>/2018/03/30/DockerfileImage/</url>
    <content><![CDATA[<!-- # Build Docker Image -->

<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/38.png" class="full-image" />

<p>简单记录下如何构建<strong>docker image</strong></p>
<h1 id="Docker-Build-Usage"><a href="#Docker-Build-Usage" class="headerlink" title="Docker Build Usage"></a>Docker Build Usage</h1><blockquote>
<ol>
<li><code>dcoker build</code> 命令将构建用到的内容发送给docker daemon,依次执行Dockerfile中的命令（每执行一行指令将会提交a new layer），执行成功image构建完成</li>
<li>构建docker image时，应该选择一个属于构建相关的目录（构建镜像所需内容），将会减少不必要的内容到docker daemon的传输从而加速构建</li>
<li>指定Dockerfile构建，<code>docker build -t 8lovelife/activemq:1.0 -f /home/dmz/temp/Dockerfile .</code></li>
</ol>
</blockquote>
<h1 id="Dockerfile中相关指令"><a href="#Dockerfile中相关指令" class="headerlink" title="Dockerfile中相关指令"></a>Dockerfile中相关指令</h1><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><blockquote>
<p><code>RUN</code>用于在当前镜像之上a new layer执行所需命令，执行后结果将被提交并可被后续指令使用</p>
</blockquote>
<blockquote>
<ul>
<li>SHELLFORM:<code>RUN &lt;COMMAND&gt;</code>,linux 中默认以<code>/bin/sh -c</code> 执行，windows默认为<code>cmd /s /c</code></li>
<li>EXECFORM:<code>RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;parma2&quot;]</code>,这种形式并不会执行命令shell。如<code>RUN [&quot;echo&quot;,&quot;$DMZ&quot;]</code>并不会输出解析后的变量DMZ，而<code>RUN [&quot;sh&quot;,&quot;-c&quot;,&quot;echo $DMZ&quot;]</code>可以解析变量DMZ（最终镜像中的系统变量）</li>
<li>EXECFORM将以JSON Array形式解析，所以参数需要双引号且相关符号需要转译如反斜杠，如：<code>RUN [&quot;C:\\windows\\system32&quot;]</code></li>
</ul>
</blockquote>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><blockquote>
<p><code>CMD</code>用于容器执行的默认行为(同样能够使容器以可执行的形式运行)，非必须存在。若在Dockerfile出现多次，只有最后一次会有效</p>
</blockquote>
<blockquote>
<ul>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> EXECFORM</li>
<li><code>CMD [&quot;params1&quot;,&quot;param2&quot;]</code> , 作为ENTRYPOINT的默认参数</li>
<li><code>CMD command param1 param2</code> SHELLFORM</li>
</ul>
</blockquote>
 <span id="more"></span>

<h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><blockquote>
<p> <code>ENTRYPOINT</code>能够使容器以可执行的形式运行，只有最后出现的<code>ENTRYPOINT</code>才会有效。使用<code>docker run --entrypoint</code>可以指定覆盖</p>
</blockquote>
<blockquote>
<ul>
<li><code>ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> EXECFORM</li>
<li><code>ENTRYPOINT command param1 param2</code> SHELLFORM,将不会使用CMD中的参数。这会成为&#x2F;bin&#x2F;sh -c的子命令，可执行命令不再是容器中的PID&#x3D;1,这将导致容器无法无法接收Unix signals并且无法听从<code>docker stop &lt;container&gt;</code> SIGTERM，当stop 容器超时后，SIGKILL会被发出强制停止容器。使用 <code>exec</code>能够解决问题。</li>
</ul>
</blockquote>
<h2 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h2><blockquote>
<p><code>SHELL</code>用于更改SHELLFORM中默认使用的shell，如windows使用powershell,<code>SHELL [&quot;powershell&quot;, &quot;-command&quot;]</code>,多次SHELL指令将会覆盖之前的SHELL指令</p>
</blockquote>
<h2 id="CMD-／-ENTRYPOINT"><a href="#CMD-／-ENTRYPOINT" class="headerlink" title="CMD ／ ENTRYPOINT"></a>CMD ／ ENTRYPOINT</h2><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DockerBuild.png" alt="这里写图片描述"></p>
<h1 id="构建activemq-image"><a href="#构建activemq-image" class="headerlink" title="构建activemq image"></a>构建activemq image</h1><blockquote>
<ul>
<li><strong>Dockerfile</strong>：</li>
</ul>
</blockquote>
<blockquote>
<pre><code> `FROM openjdk:8-jre-alpine`     #Base Image OpenJDK8
 `ENV ACTIVEMQ_VERSION 5.14.5`      #环境变量
 `ENV ACTIVEMQ apache-activemq-$ACTIVEMQ_VERSION`
 `ENV ACTIVEMQ_TCP=61616 ACTIVEMQ_AMQP=5672 ACTIVEMQ_STOMP=61613 ACTIVEMQ_MQTT=1883 ACTIVEMQ_WS=61614 ACTIVEMQ_UI=8161`
 `ENV ACTIVEMQ_HOME /opt/activemq`
 `RUN set -x &amp;&amp; \`      #设置脚本执行跟踪
 `mkdir -p /opt &amp;&amp; \  `      #建立目录/opt
  `apk --update add --virtual build-dependencies curl &amp;&amp; \`     #添加curl命令到虚拟构建依赖组build-dependencies
  `curl -s -S https://archive.apache.org/dist/activemq/$ACTIVEMQ_VERSION/$ACTIVEMQ-bin.tar.gz | tar xvz -C /opt &amp;&amp; \`         #下载activemq并解压到指定目录
  `ln -s /opt/$ACTIVEMQ $ACTIVEMQ_HOME &amp;&amp; \`      #建立软连接
  `addgroup -S activemq &amp;&amp; adduser -S -H -G activemq -h $ACTIVEMQ_HOME activemq &amp;&amp; \`       #添加用户&amp;用户组
  `chown -R activemq:activemq /opt/$ACTIVEMQ &amp;&amp; \    
  chown -h activemq:activemq $ACTIVEMQ_HOME &amp;&amp; \
  apk del build-dependencies &amp;&amp; \`       #删除虚拟构建依赖组
  `rm -rf /var/cache/apk/*`       #删除install缓存，缩小image size ,反斜杠换行（同一条命令执行减少结果提交，减少image layer）  
  `USER activemq`     #用户切换（之后命令所属用户
  `WORKDIR $ACTIVEMQ_HOME`
  `EXPOSE $ACTIVEMQ_TCP $ACTIVEMQ_AMQP $ACTIVEMQ_STOMP $ACTIVEMQ_MQTT $ACTIVEMQ_WS $ACTIVEMQ_UI` #暴露端口号
  `CMD [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;bin/activemq console&quot;]`     #容器启动后执行命令
</code></pre>
</blockquote>
<blockquote>
<ul>
<li>构建<br><code>docker build -t 8lovelife/activemq:1.0 .</code></li>
</ul>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">Docker v17.6</a><br><a href="https://store.docker.com/community/images/rmohr/activemq">activemq Dockerfile来源</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> I don’t want to survive. I want to live. - Ryan Stone</p>
<p><a href="https://movie.douban.com/subject/3793783/">Gravity</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂</title>
    <url>/2023/02/20/FactoryDesign/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/48.png" class="full-image" />

<p>工厂设计模式是一种常见的设计模式，用于创建对象，所以它是一种创建型模式。工厂模式有三种不同的变体：静态工厂、工厂方法、抽象工厂。使用工厂模式可以将创建对象的代码与使用对象的代码分离，这种解耦有助于提高代码的可维护性和可扩展性。在本博客中我们将通过一个订购冰淇淋的场景来说明工厂设计模式的优点</p>
<span id="more"></span>

<h1 id="普通创建"><a href="#普通创建" class="headerlink" title="普通创建"></a>普通创建</h1><p>我们使用UML来构建客户端订购冰淇淋的场景，父类（ <strong>IceCream</strong> ）冰淇淋维护了口味，以及制作方法，制作方法包括：搅拌、加热、添加材料、冰冻、打包，子类（ <strong>ChocolateIceCream</strong> 、<strong>VanillaIceCream</strong> ）通过重写 <strong>addMaterial</strong> 方法获取不同口味的冰淇淋。订购类（ <strong>OrderIceCream</strong> ）的 <strong>order</strong> 方法通过冰淇淋口味（ <strong>taste</strong> ）来选择创建香草味还是巧克力味的冰淇淋</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DP/create_ice_cream.png" alt="imag"></p>
<p>现在我们同时支持香草味、巧克力味的冰淇淋订购了，并且我们使用了继承，如果要新增草莓味的冰淇淋，我们只需要新增一个继承父类的草莓冰淇淋类就可以了，扩展新产品非常简单</p>
<h2 id="OCP-原则"><a href="#OCP-原则" class="headerlink" title="OCP 原则"></a>OCP 原则</h2><p>按照上图的构建，我们来试试新增一种草莓冰淇淋会发生什么</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DP/strawberry_extend.png" alt="imag"></p>
<p>我们很快的扩展了一款草莓冰淇淋，而使用方 <strong>OrderIceCream</strong> 同样需要修改代码来适应新款产品，如果使用方很多、冰淇淋种类不断增加，所有使用方都需要修改，这违反了 <strong>OCP</strong> 原则，更改的越多越容易出错，这种方式构建的订购冰淇淋系统扩展起来非常困难</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DP/mul_order.png" alt="imag"></p>
<blockquote>
<p><strong>OCP</strong> 即 <strong>Open-Closed Principle</strong> ，<strong>OCP</strong> 是面向对象设计中的一个基本原则，软件实体（类、模块、函数等）应该对提供方扩展开放，对使用方修改关闭</p>
</blockquote>
<h1 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h1><p>我们使用静态工厂来重新构建订购冰淇淋场景</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DP/simple_factory.png" alt="imag"></p>
<p>当我们新增一款冰淇淋种类，只需要修改 <strong>IceCreamFactory</strong> 中的代码，而使用到 <strong>IceCreamFactory</strong> 的地方都无需修改。静态工厂将对象的创建与对象的使用逻辑解耦，提高了代码的可维护性、可扩展性，同时也符合 <strong>OCP</strong> 原则</p>
<h2 id="DIP"><a href="#DIP" class="headerlink" title="DIP"></a>DIP</h2><p>在静态工厂模式构建的订购冰淇淋系统中，对于新增冰淇淋种类场景，系统提供了很好的维护性和扩展性。现在如果我们需要对冰淇淋产地进行分类，例如：土耳其香草冰淇淋，意大利巧克力冰淇淋等，系统应该如何扩展？我们可以继续使用静态工厂，针对不同产地的冰淇淋单独创建一个静态工厂，我们来试试看</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DP/mul_simple_factory.png" alt="imag"></p>
<p>由于使用方依赖了具体的工厂类，每新增一种冰淇淋工厂，客户端都需要更改代码以支持新的冰淇淋工厂，这违反了 <strong>OCP</strong> 原则，同时也违反了 <strong>DIP</strong> 原则</p>
<blockquote>
<p><strong>DIP</strong> 即 <strong>Dependency Inversion Principle</strong> ，<strong>DIP</strong> 是面向对象设计原则的一种，它强调高层模块不应该依赖低层模块，而是应该依赖于抽象接口（接口或抽象类）。同时，具体实现类应该依赖于抽象接口而不是高层模块。<strong>DIP</strong> 指导我们尽可能地使用抽象来编程，而不是具体的实现。这样可以使系统更加灵活、扩展性更好，同时也可以降低模块间的耦合度，提高代码的可维护性</p>
</blockquote>
<h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p>我们可以使用工厂方法解决上面的问题，如下构建</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DP/factory_method.png" alt="imag"></p>
<p>基类工厂新增抽象方法 <strong>doCreate</strong>，子类实现真正的产品创建，解耦了具体工厂与使用方的依赖，符合 <strong>OCP</strong> 原则，同时也符合 <strong>DIP</strong> 原则</p>
<h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><p>抽象工厂提供了一个接口，用于创建一系列相关或依赖对象的家族，而不需要指定具体的类</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DP/abstract_factory.png" alt="imag"></p>
<p>这种方式同样符合 <strong>OCP</strong> 和 <strong>DIP</strong> 的设计原则</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>工厂模式适用于创建复杂对象，控制对象创建过程。常见使用场景有</p>
<ol>
<li>根据不同条件创建不同对象：如根据不同渠道创建不同的订单信息</li>
<li>创建的对象数量不确定时：如创建数据库、网络连接、线程等</li>
</ol>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>People love what other people are passionate about. - Mia</p>
<p><a href="https://movie.douban.com/subject/25934014/">La La Land</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Design Pattern</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>How Many J In Java</title>
    <url>/2023/11/21/HowManyJsInJava/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/blogs/Jinjava/outline.svg" class="full-image">

<p>So many !<br>写 Java 程序或者了解过 Java 语言的朋友，可能经常会听到 JSR、JDK、J2EE… 等等 J 开头的缩写词，这些缩写有时候确实会让人迷糊，而且因为历史原因，这些词的含义也在不停变化，可能也会更加难以理解。这篇博客将记录这些缩写词的含义</p>
<span id="more"></span>

<h1 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h1><p>JDK 全称 Java Development Kit，是由 Oracle 公司发行的 Java 开发工具，它实现了 JLS (Java Language Specification) 和 JVMS (Java Virtual Machine Specification)，JDK 提供了 SE (Standard Edition) 的 Java API，其中包括 javac、jar、jps 等一些工具</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/blogs/Jinjava/jdk.svg" alt="image"></p>
<h1 id="JLS"><a href="#JLS" class="headerlink" title="JLS"></a>JLS</h1><p>JLS 全称 Java Language Specification，规定了一些 Java 语言的语法和语义</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/blogs/Jinjava/jls.svg" alt="image"></p>
<h1 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h1><p>JRE 全称 Java Runtime Environment，Java 的运行环境中包含 JVM 以及一些常用工具包，如：JDBC、并发包等</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/blogs/Jinjava/jre.svg" alt="image"></p>
<h1 id="JVMS"><a href="#JVMS" class="headerlink" title="JVMS"></a>JVMS</h1><p>JVMS 全称 Java Virtual Machine Specification，规定了一些实现 Java 虚拟机的规范，如：Class 文件格式、JVM 指令集、线程与内存的交互等，常见的 JVMS 实现有 HotSpot、JRockit 等</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/blogs/Jinjava/jvms.svg" alt="image"></p>
<h1 id="JSR"><a href="#JSR" class="headerlink" title="JSR"></a>JSR</h1><p>JSR 全称 Java Specification Request，是 Java 平台拟定的最终技术规范请求，用于向 JCP 发起新增技术规范的请求描述，如 JSR 51、JSR 166 等</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/blogs/Jinjava/jsr.svg" alt="image"></p>
<h1 id="JCP"><a href="#JCP" class="headerlink" title="JCP"></a>JCP</h1><p>JCP 全称 Java Community Process，新的 Java 技术规范在此机制下进行开发，涉及 JSR 的使用</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/blogs/Jinjava/jcp.svg" alt="image"></p>
<h1 id="J2SE-VS-Java-SE"><a href="#J2SE-VS-Java-SE" class="headerlink" title="J2SE VS Java SE"></a>J2SE VS Java SE</h1><p>J2SE 全称 Java 2 Platform, Standard Edition， 是众多 Java 平台中的标准版，后被更名为 Java SE</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/blogs/Jinjava/j2se.svg" alt="image"></p>
<h1 id="J2EE-VS-Java-EE-VS-Jakarta-EE"><a href="#J2EE-VS-Java-EE-VS-Jakarta-EE" class="headerlink" title="J2EE VS Java EE VS Jakarta EE"></a>J2EE VS Java EE VS Jakarta EE</h1><p>J2EE 全称 Java 2 Platform, Enterprise Edition，是众多 Java 平台中的企业版，是对 Java SE 的扩展，常见的企业技术标准有：Servlet、WebServices 等，后 Oracle 将 Java EE 交给 Eclipse Foundation，由于 Java 商标问题，Java EE 改名为 Jakarta EE</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/blogs/Jinjava/j2ee.svg" alt="image"></p>
<h1 id="Other-Java-Platform"><a href="#Other-Java-Platform" class="headerlink" title="Other Java Platform"></a>Other Java Platform</h1><p>Java 其他一些平台</p>
<ul>
<li>Java Card 用于开发嵌入式设备</li>
<li>Java ME 即 Java Platform, Micro Edition，用于开发手机、机顶盒、微控制器等</li>
<li>JavaFX 用于构建客户端应用程序</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA With Git</title>
    <url>/2018/05/21/IntelliJIDEAWithGit/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/24.png" class="full-image" />

<p>记录下Git如何与IntelliJ IDEA协作</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul>
<li><a href="https://git-scm.com/downloads">Git下载</a></li>
<li><a href="https://www.jetbrains.com/idea/download/#section=mac">IntelliJ IDEA下载</a></li>
<li>IntelliJ IDEA 的 License server 可以使用：<code>http://8lovelife.com:1017</code></li>
</ul>
<h1 id="IntelliJ-IDEA-With-Git-开发过程"><a href="#IntelliJ-IDEA-With-Git-开发过程" class="headerlink" title="IntelliJ IDEA With Git 开发过程"></a>IntelliJ IDEA With Git 开发过程</h1><h2 id="1-初次获取远端代码"><a href="#1-初次获取远端代码" class="headerlink" title="1. 初次获取远端代码"></a>1. 初次获取远端代码</h2><ul>
<li>使用IntelliJ IDEA Terminal</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Intellij%20Idea/IdeTerminal.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:code mac$ git clone https://github.com/grpc/grpc-java.git</span><br><span class="line">Cloning into &#x27;grpc-java&#x27;...</span><br></pre></td></tr></table></figure>
<h2 id="2-查看远端仓库分支"><a href="#2-查看远端仓库分支" class="headerlink" title="2. 查看远端仓库分支"></a>2. 查看远端仓库分支</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git branch -av</span><br><span class="line">* master                 0388b70 some feture</span><br><span class="line">  remotes/origin/HEAD    -&gt; origin/master</span><br><span class="line">  remotes/origin/feature cd52891 some features</span><br><span class="line">  remotes/origin/master  0388b70 some feture</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="3-将指定的远端分支同步到本地（建议同远端名一致）"><a href="#3-将指定的远端分支同步到本地（建议同远端名一致）" class="headerlink" title="3. 将指定的远端分支同步到本地（建议同远端名一致）"></a>3. 将指定的远端分支同步到本地（建议同远端名一致）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git checkout -b feature origin/feature</span><br><span class="line">Branch &#x27;feature&#x27; set up to track remote branch &#x27;feature&#x27; from &#x27;origin&#x27;.</span><br><span class="line">Switched to a new branch &#x27;feature&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="4-查看本地当前所在分支-关联的远端分支"><a href="#4-查看本地当前所在分支-关联的远端分支" class="headerlink" title="4. 查看本地当前所在分支 &amp; 关联的远端分支"></a>4. 查看本地当前所在分支 &amp; 关联的远端分支</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git branch  // 查看当前分支</span><br><span class="line">* feature</span><br><span class="line">  master</span><br><span class="line">  </span><br><span class="line">Mac:dmz-inward- mac$ git branch -avv  // 查看当前分支关联的远端分支</span><br><span class="line">* feature                bb87089 [origin/feature] Merge branch &#x27;feature_test&#x27; into feature</span><br><span class="line">  feature_test           dd90129 //</span><br><span class="line">  master                 0388b70 [origin/master] some feture</span><br><span class="line">  remotes/origin/HEAD    -&gt; origin/master</span><br><span class="line">  remotes/origin/feature bb87089 Merge branch &#x27;feature_test&#x27; into feature</span><br><span class="line">  remotes/origin/master  0388b70 some feture</span><br></pre></td></tr></table></figure>
<ul>
<li>View 确认</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Intellij%20Idea/BranchConfirmed.png" alt="image"></p>
<h2 id="5-准备在指定分支开发"><a href="#5-准备在指定分支开发" class="headerlink" title="5. 准备在指定分支开发"></a>5. 准备在指定分支开发</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git checkout -b feature_test</span><br><span class="line">Switched to a new branch &#x27;feature_test&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="6-coding-show-diff"><a href="#6-coding-show-diff" class="headerlink" title="6. coding &amp; show diff"></a>6. coding &amp; show diff</h2><ul>
<li>coding</li>
<li>随时查看本地的变动，防止遗漏：</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Intellij%20Idea/FilesLocalChanges.png" alt="image"></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Intellij%20Idea/showdiff.png" alt="image"></p>
<p><span id="jump"></span></p>
<h2 id="7-将文件添加到暂存区-提交工作分支的修改-更改提交的comments"><a href="#7-将文件添加到暂存区-提交工作分支的修改-更改提交的comments" class="headerlink" title="7. 将文件添加到暂存区 &amp; 提交工作分支的修改 | 更改提交的comments"></a>7. 将文件添加到暂存区 &amp; 提交工作分支的修改 | 更改提交的comments</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git add . // 添加暂存区</span><br><span class="line"></span><br><span class="line">Mac:dmz-inward- mac$ git commit -m &quot;feature add test&quot; // 提交</span><br><span class="line">[feature_test 7590940] feature add test</span><br><span class="line"> 2 files changed, 7 insertions(+)</span><br><span class="line"> create mode 100644 dmz-inward-test/src/test/java/Test.java</span><br><span class="line"> </span><br><span class="line">Mac:dmz-inward- mac$ git commit --amend  // 修改提交的comments</span><br><span class="line">[feature_test 90b9e43] feature add retests</span><br><span class="line"> Date: Mon May 21 10:40:06 2018 +0800</span><br><span class="line"> 2 files changed, 7 insertions(+)</span><br><span class="line"> create mode 100644 dmz-inward-test/src/test/java/Test.java</span><br></pre></td></tr></table></figure>
<ul>
<li>暂存区与HEAD</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Intellij%20Idea/stage%26commit.png" alt="image"></p>
<h2 id="8-撤销本地的修改"><a href="#8-撤销本地的修改" class="headerlink" title="8. 撤销本地的修改"></a>8. 撤销本地的修改</h2><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Intellij%20Idea/revert.png" alt="image"></p>
<h2 id="9-切换到与远端同步的主分支-同步可能的远端修改"><a href="#9-切换到与远端同步的主分支-同步可能的远端修改" class="headerlink" title="9. 切换到与远端同步的主分支 &amp; 同步可能的远端修改"></a>9. 切换到与远端同步的主分支 &amp; 同步可能的远端修改</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git checkout feature  // 切换分支</span><br><span class="line">Switched to branch &#x27;feature&#x27;</span><br><span class="line">Your branch is up to date with &#x27;origin/feature&#x27;.</span><br><span class="line"></span><br><span class="line">Mac:dmz-inward- mac$ git pull  // 同步远端可能的修改</span><br><span class="line">Already up to date.</span><br></pre></td></tr></table></figure>

<h2 id="10-切换到工作分支-rebase-resoleve-conflicts"><a href="#10-切换到工作分支-rebase-resoleve-conflicts" class="headerlink" title="10. 切换到工作分支 &amp; rebase | resoleve conflicts"></a>10. 切换到工作分支 &amp; rebase | resoleve conflicts</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git checkout feature_test </span><br><span class="line">Switched to branch &#x27;feature_test&#x27;</span><br><span class="line"></span><br><span class="line">Mac:dmz-inward- mac$ git rebase feature</span><br><span class="line">Current branch feature_test is up to date.</span><br><span class="line"></span><br><span class="line">若rebase遇到冲突则手动解决，利用Intelli Idea 的show diff 可以清晰观察冲突点</span><br><span class="line"></span><br><span class="line">冲突解决后进行：</span><br><span class="line">git add * </span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<h2 id="11-切换到主分支-合并修改到主分支"><a href="#11-切换到主分支-合并修改到主分支" class="headerlink" title="11. 切换到主分支 &amp; 合并修改到主分支"></a>11. 切换到主分支 &amp; 合并修改到主分支</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git checkout feature</span><br><span class="line">Switched to branch &#x27;feature&#x27;</span><br><span class="line">Your branch is up to date with &#x27;origin/feature&#x27;.</span><br><span class="line"></span><br><span class="line">Mac:dmz-inward- mac$ git merge --no-ff feature_test</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> dmz-inward-test/src/test/java/Test.java     | 6 ++++++</span><br><span class="line"> dmz-inward-test/src/test/java/TestFast.java | 1 +</span><br><span class="line"> 2 files changed, 7 insertions(+)</span><br><span class="line"> create mode 100644 dmz-inward-test/src/test/java/Test.java</span><br></pre></td></tr></table></figure>

<ul>
<li>分支</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Intellij%20Idea/branch.png" alt="image"></p>
<h2 id="12-本地分支同步到远端分支（会改变远程分支的文件）"><a href="#12-本地分支同步到远端分支（会改变远程分支的文件）" class="headerlink" title="12.本地分支同步到远端分支（会改变远程分支的文件）"></a>12.本地分支同步到远端分支（会改变远程分支的文件）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git push</span><br><span class="line">Counting objects: 17, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (17/17), done.</span><br><span class="line">Writing objects: 100% (17/17), 1.36 KiB | 698.00 KiB/s, done.</span><br><span class="line">Total 17 (delta 10), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (10/10), completed with 4 local objects.</span><br></pre></td></tr></table></figure>

<h1 id="Git-相关"><a href="#Git-相关" class="headerlink" title="Git 相关"></a>Git 相关</h1><p>Git 常用的操作命令</p>
<h2 id="回退到分支指定版本"><a href="#回退到分支指定版本" class="headerlink" title="回退到分支指定版本"></a>回退到分支指定版本</h2><ul>
<li>查看分支历史变动历史，回退指定版本号</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Intellij%20Idea/reflog.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git reset --hard bb8708981a01eb568d114ed7ddad71f6cd881f7e</span><br><span class="line">HEAD is now at bb87089 Merge branch &#x27;feature_test&#x27; into feature</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Cherry-Pick"><a href="#Cherry-Pick" class="headerlink" title="Cherry-Pick"></a>Cherry-Pick</h2><p>将某一分支的commit修改，应用到当前本地分支。如：将feature上的某一commit修改应用到master上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is up to date with &#x27;origin/master&#x27;.</span><br></pre></td></tr></table></figure>

<ol>
<li>Cherry-Pick</li>
</ol>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Intellij%20Idea/Cherry-Pick.png" alt="image"></p>
<ol start="2">
<li><a href="#jump">Intellij Idea With Git 开发过程</a></li>
</ol>
<h2 id="本地分支重命名"><a href="#本地分支重命名" class="headerlink" title="本地分支重命名"></a>本地分支重命名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git branch -m feature feature_rename</span><br></pre></td></tr></table></figure>

<h2 id="本地新建分支推送到远端"><a href="#本地新建分支推送到远端" class="headerlink" title="本地新建分支推送到远端"></a>本地新建分支推送到远端</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git push --set-upstream origin feature_one</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/dreamming/dmz-inward-.git</span><br><span class="line"> * [new branch]      feature_one -&gt; feature_one</span><br><span class="line">Branch &#x27;feature_one&#x27; set up to track remote branch &#x27;feature_one&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>

<h2 id="删除本地分支-删除远端分支"><a href="#删除本地分支-删除远端分支" class="headerlink" title="删除本地分支 &amp; 删除远端分支"></a>删除本地分支 &amp; 删除远端分支</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git branch -d feature_one  // 删除本地分支</span><br><span class="line">warning: deleting branch &#x27;feature_one&#x27; that has been merged to</span><br><span class="line">         &#x27;refs/remotes/origin/feature_one&#x27;, but not yet merged to HEAD.</span><br><span class="line">Deleted branch feature_one (was dd90129).</span><br><span class="line"></span><br><span class="line">Mac:dmz-inward- mac$ git push origin :feature_one  // 删除远端分支</span><br><span class="line">To https://github.com/dreamming/dmz-inward-.git</span><br><span class="line"> - [deleted]         feature_one</span><br></pre></td></tr></table></figure>

<h2 id="查看版本变动"><a href="#查看版本变动" class="headerlink" title="查看版本变动"></a>查看版本变动</h2><ol>
<li>查看分支历史变动</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ git reflog</span><br><span class="line">47128b4 (HEAD -&gt; master, origin/master, origin/HEAD) HEAD@&#123;0&#125;: commit: //</span><br><span class="line">0388b70 HEAD@&#123;1&#125;: checkout: moving from feature to master</span><br><span class="line">bb87089 (feature_two, feature) HEAD@&#123;2&#125;: checkout: moving from master to feature</span><br><span class="line">0388b70 HEAD@&#123;3&#125;: checkout: moving from feature to master</span><br><span class="line">bb87089 (feature_two, feature) HEAD@&#123;4&#125;: reset: moving to bb8708981a01eb568d114ed7ddad71f6cd881f7e</span><br><span class="line">06d0579 (origin/feature) HEAD@&#123;5&#125;: commit: __</span><br><span class="line">bb87089 (feature_two, feature) HEAD@&#123;6&#125;: checkout: moving from master to feature</span><br><span class="line">0388b70 HEAD@&#123;7&#125;: checkout: moving from feature_one to master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Intellij%20Idea/GitReflog.png" alt="image"></p>
<ol start="2">
<li>查看文件更改人</li>
</ol>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Intellij%20Idea/GitAnnotate.png" alt="image"></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Intellij%20Idea/AnnotateView.png" alt="image"></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> I have always been so scared, so alone. - Chihiro Ogino</p>
<p><a href="https://movie.douban.com/subject/1291561/">Spirited Away</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <tags>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM类加载</title>
    <url>/2018/04/21/JVMClassLoader/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/27.png" class="full-image" />

<p>回顾回顾JVM中的类加载</p>
<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>类的生命周期包括类的加载、链接、初始化、使用、销毁<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/JVM/ClassLife.png" alt="image"></p>
<h2 id="类装入JVM"><a href="#类装入JVM" class="headerlink" title="类装入JVM"></a>类装入JVM</h2><p>将类装入JVM供使用的过程分为：类的加载、链接、初始化</p>
<ul>
<li>显示装入：<sup>1。</sup> 调用类加载器中的loadClass方法 <sup>2。</sup>调用Class.forName方法</li>
<li>隐示装入：解析类中引用的其他类的时候，所引用的类未被加载时则被隐示装入</li>
</ul>
<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p>类的加载包括 </p>
<ol>
<li>将.class文件加载到JVM方法区中</li>
<li>在堆中生成Class对象，Class对象提供了访问方法区中类数据结构的接口<blockquote>
<p><strong>这一阶段类对象仅有基本的内存结构，类对象中的方法、字段、引用都不做处理，此时的类还不能使用</strong></p>
</blockquote>
</li>
</ol>
<h3 id="类的链接"><a href="#类的链接" class="headerlink" title="类的链接"></a>类的链接</h3><p>类的链接将内存中二进制数据转换到JVM运行数据区，链接包括验证、准备、解析</p>
<ul>
<li>验证：验证类的字节码是否合法</li>
<li>准备：为类的静态变量分配内存并设置默认值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final static int a = 10  准备阶段阶段 a 的默认值为 10</span><br><span class="line">static int b = 10  准备阶段 b 的默认值为 0</span><br></pre></td></tr></table></figure>
<ul>
<li>解析：将常量池中的符号引用替换为直接引用，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行</li>
</ul>
<span id="more"></span>

<h3 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h3><p>类的初始化是执行<code>&lt;clinit&gt;()</code>方法的过程</p>
<ul>
<li><code>&lt;clinit&gt;()</code> 由编译器按照代码书写的顺序将类中的 <strong>静态变量的赋值与静态代码块</strong> 合并到此方法中</li>
<li><code>&lt;clint&gt;()</code> 同时只能有一个线程且只能执行一次，利用这个特性可以写一个<a href="http://whathowhy.com/2018/04/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">安全的懒加载单例类</a></li>
</ul>
<blockquote>
<p>类的初始化时机，若类未初始化则以下动作将进行类的初始化</p>
<ol>
<li>new对象、调用静态方法、获取非final修饰的静态变量、设置静态变量</li>
<li>对类进行反射调用</li>
<li>类的初始化发生时，若有父类则先执行父类的类的初始化</li>
<li>虚拟机会对启动类（即含有main方法的类）进行类的初始化</li>
</ol>
</blockquote>
<h2 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h2><p>实例化、使用对象方法等</p>
<h2 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h2><p>Class对象被回收、Class方法区中数据结构被卸载</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>ClassLoader用于将类加载在JVM中供使用</p>
<h2 id="ClassLoader工作机制"><a href="#ClassLoader工作机制" class="headerlink" title="ClassLoader工作机制"></a>ClassLoader工作机制</h2><p>类的加载采用双亲委派模式</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/JVM/Classloader.png" alt="image"></p>
<h2 id="ClassLoader工作过程"><a href="#ClassLoader工作过程" class="headerlink" title="ClassLoader工作过程"></a>ClassLoader工作过程</h2><ol>
<li>缓存（是否已加载</li>
<li>委托父加载器</li>
<li>自己加载</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">抽象类ClassLoader核心方法：</span><br><span class="line"></span><br><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">            // 类是否已经加载</span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                long t0 = System.nanoTime();</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (parent != null) &#123;</span><br><span class="line">                    // 若类并未被加载则委托父加载器加载</span><br><span class="line">                        c = parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                    // 若没有父加载器则委托给启动加载器</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    // ClassNotFoundException thrown if class not found</span><br><span class="line">                    // from the non-null parent class loader</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (c == null) &#123;</span><br><span class="line">                    // If still not found, then invoke findClass in order</span><br><span class="line">                    // to find the class.</span><br><span class="line">                    long t1 = System.nanoTime();</span><br><span class="line">                    // 当前类加载器开始加载类</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    // this is the defining class loader; record the stats</span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">                resolveClass(c); //加载的类是否进行解析</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,</span><br><span class="line">                                         ProtectionDomain protectionDomain)</span><br><span class="line">        throws ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">        String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">        Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">        postDefineClass(c, protectionDomain);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>
<ul>
<li>findClass方法由不同的加载器实现定制（网络加载.class文件等</li>
<li>defineClass方法用与创建Class对象</li>
</ul>
<h2 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h2><p>ClassLoader双亲委派模式的能与不能</p>
<h3 id="双亲委派加载的好处"><a href="#双亲委派加载的好处" class="headerlink" title="双亲委派加载的好处"></a>双亲委派加载的好处</h3><ol>
<li>保证了Java核心类库的安全 </li>
<li>JVM中能够支持隔离的类空间（不同加载器加载同一个class）</li>
</ol>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><blockquote>
<p>SPI（Service Provider Interface）是Java提供的位于核心类库中的接口，由第三方实现。如JDBC、JNDI等。按照ClassLoader的双亲委派模式，最终加载SPI的是Bootstrap ClassLoader，而SPI的实现类是由System ClassLoader加载的，最终只会加载失败。</p>
</blockquote>
<ul>
<li><strong>针对SPI的接口Java使用线程上下文加载器(Thread.currentThread().getContextClassLoader())来显式加载SPI的实现</strong></li>
</ul>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> Justice is not a product of the court. It’s a product of the people.</p>
<p><a href="https://movie.douban.com/subject/1293182/">12 Angry Men</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM GC</title>
    <url>/2018/04/06/JVMGC/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/31.png" class="full-image" />

<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p>垃圾回收器是内存回收的具体实现，Java有四类垃圾回收器，分别是：</p>
<blockquote>
<ol>
<li>Serial Garbage Collector</li>
<li>Parallel Garbage Collector</li>
<li>CMS Garbage Collector</li>
<li>G1 Garbage Collector</li>
</ol>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/GCTypes.png" alt="image"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过如下命令可以查看 JVM 默认的垃圾回收器</span></span><br><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure>

<h1 id="串行垃圾回收器"><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h1><blockquote>
<p>串行垃圾回收器是JVM Client模式下的默认GC，只使用一个单独的线程进行垃圾回收，垃圾回收时会冻结所有应用程序的线程，垃圾回收期间程序暂停的时间较长</p>
</blockquote>
<h2 id="Serial-GC"><a href="#Serial-GC" class="headerlink" title="Serial GC"></a>Serial GC</h2><blockquote>
<p>Serial GC为新生代的垃圾搜集器，采用复制回收算法。Java中所有新产生的对象都在Yong区中的Eden区，当Eden区的大小不足以容纳新生的对象或对象大小超过了PretenureSizeThreshold的参数配置大小 ，对象只能在Old区分配。当Eden区满后会触发Minor GC ，触法Minor GC前需要检查老年代的连续空间是否大于新生代总大小或者历届晋升对象的平均大小，若满足就会进行Minor GC，否则将进行Full GC。Minor GC除了清除Eden区的非活跃对象外，还会把Survivor区一些老对象移动到Old区，老对象的定义通过配置MaxTenuringThreshold大小来控制，<sup>1.</sup>当对象在Survivor区的存活次数达到MaxTenuringThreshold的大小则会被移动到Old区。 <sup>2.</sup>当Survivor区中相同年龄大小的所有对象大小总和超过了Survivor区空间的一半（默认 -XX:TargetSurvivorRatio&#x3D;50）则会被移动到Old区</p>
</blockquote>
<h2 id="Serial-Old-GC"><a href="#Serial-Old-GC" class="headerlink" title="Serial Old GC"></a>Serial Old GC</h2><blockquote>
<p>Serial Old GC 为老年代搜集器，使用“标记-整理”算法，此GC不能够主动配置。<sup>1.</sup>当CMS收集器发生错误的时候使用。<sup>2.</sup>配合其他GC使用</p>
</blockquote>
<span id="more"></span>
<h1 id="并行垃圾回收器"><a href="#并行垃圾回收器" class="headerlink" title="并行垃圾回收器"></a>并行垃圾回收器</h1><blockquote>
<p>Parallel GC 根据Minor GC 和 Full GC的不同分为三种，分别为：ParNewGC、ParallelGC，ParallelGC。并行垃圾回收器以多线程的方式进行回收</p>
</blockquote>
<h2 id="ParNewGC"><a href="#ParNewGC" class="headerlink" title="ParNewGC"></a>ParNewGC</h2><blockquote>
<p>属于新生代的GC，此垃圾搜集器的工作方式与Serial GC类似，只不过它是多线程的，垃圾回收器工作的时候同样需要停止程序的所有线程</p>
</blockquote>
<h3 id="ParNewGC组合参数"><a href="#ParNewGC组合参数" class="headerlink" title="ParNewGC组合参数"></a>ParNewGC组合参数</h3><blockquote>
<ul>
<li>PretenureSizeThreshold ：此参数表示当对象的大小超过此值则直接进入Old区，只对Serial和ParNew两款收集器有效</li>
<li>UseAdaptiveSizePolicy：当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold ）等细节参数了</li>
</ul>
</blockquote>
<h2 id="Parallel-GC"><a href="#Parallel-GC" class="headerlink" title="Parallel GC"></a>Parallel GC</h2><blockquote>
<p>JVM Server模式下默认的GC方式，即Parallel Scavenge，属于新生代GC。此垃圾搜集器与Par NewGC类似，不同地方在于Parallel Scavenge关注点是程序的吞吐量</p>
</blockquote>
<h3 id="吞吐量与响应时间"><a href="#吞吐量与响应时间" class="headerlink" title="吞吐量与响应时间"></a>吞吐量与响应时间</h3><blockquote>
<ul>
<li>吞吐量：运行用户代码时间 &#x2F;（运行用户代码时间 + 垃圾收集时间），吞吐量高适合后台密集运算的程序</li>
<li>响应时间：程序停顿时间的大小，响应时间短适合应用与用户交互的程序</li>
</ul>
</blockquote>
<h3 id="Parallel-GC的组合参数"><a href="#Parallel-GC的组合参数" class="headerlink" title="Parallel GC的组合参数"></a>Parallel GC的组合参数</h3><blockquote>
<ul>
<li>MaxGCPausedMillis：垃圾回收器将尽可能在此时间内完成完成内存回收，<strong>关注停顿时间</strong></li>
<li>GCTimeRatio：设置垃圾搜集时间占总时间的比值，即：1-吞吐量，<strong>关注吞吐量</strong></li>
<li>ParallelGCThreads：指定回收线程数</li>
</ul>
</blockquote>
<h2 id="ParallelOldGC"><a href="#ParallelOldGC" class="headerlink" title="ParallelOldGC"></a>ParallelOldGC</h2><blockquote>
<p>属于老年代GC，以多线程的方式使用“标记-整理”算法</p>
</blockquote>
<h1 id="并发标记清除垃圾回收器"><a href="#并发标记清除垃圾回收器" class="headerlink" title="并发标记清除垃圾回收器"></a>并发标记清除垃圾回收器</h1><blockquote>
<p>CMS（Concurrent Mark Sweep）收集器是以响应时间为目标的收集器，是老年代的GC，基于“标记-清除”算法。对于B&#x2F;S系统的服务端，需要重视服务的响应速度。CMS的触发规则是检查Old区的使用率（设置参数为：CMSInitiatingOccupancyFraction），当达到一定的使用率则会触发CMS GC，当CMS GC正在进行的时候，若此时JVM正在向Old区申请内存，Old区内存不够则申请会失败并会触发Full GC</p>
</blockquote>
<h2 id="CMS过程"><a href="#CMS过程" class="headerlink" title="CMS过程"></a>CMS过程</h2><blockquote>
<ol>
<li>Initial Mark: 初始化标记，标记对象根路径直接关联的对象，需要终止程序所有线程（Stop The World，单线程）</li>
<li>Concurrent Mark: 并发标记，追踪根路径可达的对象</li>
<li>Concurrent precleaning: 并发预处理，查找并发标记阶段进入老年代的对象，减少下一阶段的停顿时间</li>
<li>Remark:重新标记，扫描从根对象开始向下追溯，并处理关联对象，需要终止程序所有线程（Stop The World，多线程）</li>
<li>Concurrent sweeping: 并发清理垃圾对象</li>
<li>Concurrent reset: 并发重置，等待下一次垃圾回收</li>
</ol>
</blockquote>
<h2 id="CMS使用"><a href="#CMS使用" class="headerlink" title="CMS使用"></a>CMS使用</h2><blockquote>
<p>CMS收集方式能够减少程序停顿时间。“标记-清除”算法会产生大量的内存空间碎片</p>
</blockquote>
<h3 id="CMS组合参数"><a href="#CMS组合参数" class="headerlink" title="CMS组合参数"></a>CMS组合参数</h3><blockquote>
<ul>
<li>UseCMSCompactAtFullCollection：Full GC 后进行一次碎片整理，整理过程会Stop The World</li>
<li>CMSFullGCsBeforeCompaction： 设置进行几次Full GC后进行碎片整理</li>
<li>ParallelCMSThreads：设置CMS线程数量</li>
<li>ExplicitGCInvokesConcurrent :设置当显示GC调用、只会触发CMS，不会进行Full GC</li>
</ul>
</blockquote>
<h1 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h1><blockquote>
<p>G1垃圾回收器，将Java堆分为多个大小相等的区域（region），新生代与老年代对象耦合在一起</p>
</blockquote>
<h2 id="G1-GC过程"><a href="#G1-GC过程" class="headerlink" title="G1 GC过程"></a>G1 GC过程</h2><blockquote>
<ol>
<li>标记阶段：初始化标记对象，并进行Minor GC ，此阶段会Stop The World</li>
</ol>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/InitialMarking.png" alt="image"><br>2. Root Region Scanning：回收Survivor区，必须在Yong GC之前完成<br>3. Concurrent Marking：在整个堆中进行并发标记，此过程会被Yong GC打断，若发现区域存在垃圾对象则直接进行回收，此阶段会进行每个区域中存活对象的比例统计</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/ConcurrentMarking.png" alt="image"><br>4. Remark：再标记用来收集在并发阶段产生的垃圾对象，效率高于CMS，此阶段会Stop The World</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Remark.png" alt="image"><br>5. Copy&#x2F;Clean up：多线程消除垃圾对象，将存活对象移动到新区域，此阶段会Stop The World</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Copying%3ACleanup.png" alt="image"><br>6. After Copy&#x2F;Clean</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/AfterC%3AC.png" alt="image"></p>
</blockquote>
<h2 id="G1-VS-CMS"><a href="#G1-VS-CMS" class="headerlink" title="G1 VS CMS"></a>G1 VS CMS</h2><blockquote>
<ul>
<li>G1 使用“标记-整理”算法，不会出现内存碎片，分配大对象不会因为找不到连续的空间进行GC</li>
<li>可预测停顿，G1能够建立可预测的停顿时间模型</li>
</ul>
</blockquote>
<h1 id="GC组合使用"><a href="#GC组合使用" class="headerlink" title="GC组合使用"></a>GC组合使用</h1><blockquote>
<p>不同GC是可以进行组合使用的<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/GCCombine.png" alt="image"></p>
</blockquote>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> People do not lack strength, they lack will. - Andrew Laeddis</p>
<p><a href="https://movie.douban.com/subject/2334904/">Shutter Island</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存回收</title>
    <url>/2018/04/05/JVMMemoryCollection/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/32.png" class="full-image" />

<p>在Java开发的过程中，程序的执行需要计算机内存空间，Java并没有语法与内存创建、释放有直接联系，JVM负责管理内存的申请与释放，对于Java语言来说，显示的内存申请通常有两种：静态内存分配与动态内存分配</p>
<h1 id="静态内存的分配与回收"><a href="#静态内存的分配与回收" class="headerlink" title="静态内存的分配与回收"></a>静态内存的分配与回收</h1><blockquote>
<ul>
<li>静态内存分配：Java类或方法中的原始类型数据和对象的引用都是静态分配的内存，当Java编译器执行编译后就已经确定了静态内存的大小，在程序被加载后会分配静态内存且在程序运行期间内存大小不会再改变</li>
<li>静态内存回收：程序执行结束后释放、方法执行结束后释放</li>
</ul>
</blockquote>
<h1 id="动态内存的分配与回收"><a href="#动态内存的分配与回收" class="headerlink" title="动态内存的分配与回收"></a>动态内存的分配与回收</h1><blockquote>
<ul>
<li>动态内存分配：Java中的对象类型的数据创建是动态的内存分配，只有在程序执行的过程中才知道程序所需的内存大小</li>
<li>动态内存分配：Java中的对象不再被使用的时候内存会被回收</li>
</ul>
</blockquote>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><blockquote>
<ul>
<li>什么样的对象应该被认为是垃圾需要回收？<strong>对象是否是垃圾对象取决于对象的引用类型与对象是否根路径可达</strong></li>
<li>如何回收垃圾对象释放内存？由<strong>垃圾回收算法</strong>负责</li>
</ul>
</blockquote>
<h2 id="垃圾对象"><a href="#垃圾对象" class="headerlink" title="垃圾对象"></a>垃圾对象</h2><blockquote>
<ol>
<li>对象与根节点之间的联系称为引用链，当对象与根节点之间不存在引用链时，此对象成为垃圾对象，根节点可以是以下元素</li>
</ol>
<ul>
<li>在方法中局部变量区的对象引用</li>
<li>在Java操作栈中的对象引用</li>
<li>在常量池中的对象引用（如常量池中引用的的类名String在堆中</li>
<li>在本地方法的对象引用</li>
<li>类的Class对象（JVM加载Class时，会在堆中创建一个代表这个类的唯一数据类型的Class对象</li>
</ul>
<ol start="2">
<li>若对象被软引用，当内存不足时，软引用对象为垃圾对象</li>
<li>若对象被弱引用，则此对象为垃圾对象</li>
<li>若对象被虚引用，则此对象为垃圾对象</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><blockquote>
<p>垃圾搜集的算法主要有三种，分别是标记-清除算法、复制算法、标记-整理算法</p>
</blockquote>
<h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><blockquote>
<ul>
<li>概述：在程序运行期间，若可以使用的内存耗尽，GC会暂停整个程序，随后将标记存活的对象，并将堆中没被标记的对象（根路径不可达的对象）清除，最后恢复程序</li>
<li>此算法缺点：标记清除算法的主要缺点是回收后的内存空间布局是分散的，JVM必须维护空闲的内存列表</li>
</ul>
</blockquote>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><blockquote>
<ul>
<li>概述：复制算法将内存分为两个部分，内存只分配在其中的一个位置（活动区），另一个位置始终保持空闲（空闲区）。当有效内存耗尽，GC线程停止程序，复制算法开始。GC线程将活动区的存活对象移动到内存的空闲区（按顺序排列）并清除垃圾对象。适合存活率低的对象</li>
<li>此算法缺点：<sup>1.</sup>内存浪费。<sup>2.</sup>如果对象存活100% ，则对象将会整体移动！</li>
</ul>
</blockquote>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记&#x2F;整理算法"></a>标记&#x2F;整理算法</h3><blockquote>
<ul>
<li>概述：标记&#x2F;整理算法与标记&#x2F;清除类似，只是在清除垃圾对象的同时将存活对象按地址进行了内存整理，JVM只需要维护内存的开始位置就可以方便支持后续的内存分配</li>
<li>此算法缺点：整理内存有更多的时间消耗</li>
</ul>
</blockquote>
<h3 id="分代搜集算法"><a href="#分代搜集算法" class="headerlink" title="分代搜集算法"></a>分代搜集算法</h3><blockquote>
<p>分代搜集算法是针对<a href="http://whathowhy.com/2018/04/04/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Java堆区</a>的内存回收，是标记-清除算法、复制算法、标记-整理算法的综合实际运用</p>
<ul>
<li>Young区垃圾回收：当Eden区满后会触发minor GC，minor GC 会利用<strong>复制算法</strong>进行此区的内存回收</li>
<li>Old区垃圾回收：当Old区满后会触发major GC or Full GC ， major GC or Full GC利用 <strong>标记&#x2F;清除或标记&#x2F;整理算法</strong>进行内存回收</li>
</ul>
</blockquote>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> The smallest change can have the biggest impact. - Evan Treborn</p>
<p><a href="https://movie.douban.com/subject/1292343/">The Butterfly Effect</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存管理</title>
    <url>/2018/04/04/JVMMemoryManage/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/33.png" class="full-image" />

<p><em><strong>记录 Java中的堆与栈究竟是什么，JVM在计算机物理内存中是如何工作的</strong></em></p>
<h1 id="计算机内存结构"><a href="#计算机内存结构" class="headerlink" title="计算机内存结构"></a>计算机内存结构</h1><blockquote>
<p><strong>计算机中存在不同类型的内存包括：RAM，CPU寄存器，缓存CACHE等</strong></p>
</blockquote>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Computer.png" alt="image"></p>
<h2 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h2><blockquote>
<p>物理内存一般指的是RAM与存储器，CPU与RAM或寄存器通信依靠的是地址总线。总线的宽度决定了CPU与内存间通信的数据量。如32位的地址总线寻址范围为：0x00000000~0xffffffff，即2<sup>32</sup>个内存位置，每个内存位置会引用一个字节，所以2<sup>32</sup> byte &#x3D; 4GB，计算机的内存是通过操作系统进行分配的，不同进程申请到的内存是逻辑上隔离的</p>
</blockquote>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><blockquote>
<p>操作系统按照进程管理内存的申请，进程间各自内存由操作系统保证独立性，独立性不表示一个内存空间只能由一个进程使用。虚拟内存使得不同进程间可以共享内存空间，然而逻辑上不同进程是不能互相访问内存的。当一个进程不活动的情况下，操作系统会将这个进程中的数据移动到磁盘文件中（Windows中的页面文件或者Linux中的swap区），当不活跃进程恢复则操作系统会把磁盘数据重新交换到物理内存中（磁盘IO开销远大于读内存，应该避免频繁的内存交换），而真正高效的内存留给活跃进程使用。若Linux中的swap区活跃度较高说明物理内存的已经不足，swap区被频繁使用会导致系统运行缓慢。虚拟内存提高了内存利用率，而且能够扩展内存的地址空间，如虚拟内存映射到物理内存、文件、其他存储设备上</p>
</blockquote>
<h2 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h2><blockquote>
<ul>
<li>内核空间：只要是操作系统运行时使用的用于程序调度、连接硬件资源等的操作逻辑</li>
<li>用户空间：程序真正能够使用的申请地址空间</li>
</ul>
<p>通常网络传输的数据一般从内核空间传送到远端计算机的内核空间，然后将数据从内核空间复制到用户空间供用户使用，这种数据COPY是很耗时的（内核态到用户态的切换</p>
</blockquote>
<h1 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h1><blockquote>
<p><em><strong>JMM是JVM针对物理内存抽象出来的Java内存模型，是JVM在计算机内存中的工作方式。JVM按照Java运行时数据的存储结构定义Java内存模型</strong></em></p>
</blockquote>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/JMM.png" alt="image"></p>
<span id="more"></span>

<h2 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h2><blockquote>
<p>PC寄存器用来保存当前线程正常执行的程序的内存地址，当多线程交叉中断执行时线程能够按照之前中断时的指令继续执行</p>
</blockquote>
<h2 id="Java栈区"><a href="#Java栈区" class="headerlink" title="Java栈区"></a>Java栈区</h2><blockquote>
<p>Java中的栈区与线程相关联，栈主要用来执行程序。JVM为每个新建线程创建栈区，栈区各线程不共享。栈区由多个栈帧组成，栈帧包含方法局部变量、操作栈、返回值等信息。每当程序进入方法都会创建一个栈帧（入栈，方法执行完毕后栈帧会弹出（出栈，弹出的栈帧元素为返回值存入操作栈中。PC寄存器指向活动栈帧（栈区顶部</p>
</blockquote>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><blockquote>
<p>堆是Java对象存储的位置，由JVM动态开辟、自动回收，堆是Java运行时的数据区。堆是Java线程共享的区域，多线程访问存在一致性问题.堆区结构</p>
</blockquote>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Heap.png" alt="image"></p>
<h3 id="堆的组成"><a href="#堆的组成" class="headerlink" title="堆的组成"></a>堆的组成</h3><blockquote>
<ul>
<li>Young区：Java新创建的对象都在Eden区，当Eden区满后会触发minor GC 将Eden区存活的对象复制到其中一个Survivor区，另一个Survivor区同样将存活对象复制到这个Survivor区，始终保证有一个Survivor区空置</li>
<li>Old区：Old区存储的是minor GC后 Yong区仍然存活的对象。当Eden区满后将对象复制到Survivor区。<sup><strong>1.</strong></sup>若Survivor空间不总则对象会被放置到Old区。<sup><strong>2.</strong></sup>若Survivor区中经过多次minor GC 存在 存活多次的“老”对象，也直接放置在Old区。Old区满后将触发Full GC</li>
<li>Metaspace区：JDK1.8将Perm区移除取而代之为Metaspace区，Metaspace区为native memory</li>
</ul>
</blockquote>
<h3 id="不同堆区大小设置"><a href="#不同堆区大小设置" class="headerlink" title="不同堆区大小设置"></a>不同堆区大小设置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -Xms100M -Xmx200M -Xmn100M -Xss256K -XX:MetaspaceSize=200M -XX:MaxMetaspaceSize=400M</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>-Xms100M : 设置JVM初始堆内存大小</li>
<li>-Xmx200M : 设置JVM最大分配的堆内存</li>
<li>-Xmn100M : 设置Young区大小</li>
<li>-XX:NewRatio&#x3D;4 : 设置Young区与Old区的比值，Young区：Old区 &#x3D; 1:4</li>
<li>-XX:SurvivorRatio&#x3D;4 : 设置Eden区与Survivor区的比值，From：To：Eden区 &#x3D; 1:1:4</li>
<li>-XX:MetaspaceSize&#x3D;200M : 设置Metaspace区初始大小</li>
<li>-XX:MaxMetaspaceSize&#x3D;400M : 设置Metaspace区最大值（若未设置则JVM会动态调整，无上限</li>
<li>-Xss256K : 设置每个线程栈大小</li>
</ul>
</blockquote>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><blockquote>
<p>Metaspace区是方法区的实现，主要存放类的结构信息、方法体、常量池、接口初始化，构造函数等，方法区的大小在程序启动一段时间基本就固定了，JVM已经加载了程序所需的类信息，若存在对类的动态编译则需要关注方法区的大小</p>
</blockquote>
<h2 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h2><blockquote>
<p>常量池是方法区的一部分，常量池代表运行时每个class文件中的常量表，常量表包括：方法、域的引用（运行时会进行解析指向真实地址、编译期的数字常量。每个class或interface常量池都是在创建class或interface时创建的</p>
</blockquote>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><blockquote>
<p>本地方法栈是  <sup><strong>1.</strong></sup>JVM调用本地方法（C或C++实现的方法）时的栈空间。<sup><strong>2.</strong></sup>JVM利用JIT技术时会将Java代码重新编译为本地代码，编译后的代码会利用本地方法栈追踪方法的执行</p>
</blockquote>
<h1 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h1><blockquote>
<ul>
<li>静态内存分配：在程序编译阶段就已经确定每个数据在运行是的存储空间（java中的基本类型、对象引用，递归、嵌套结构会导致编译阶段无法确认程序运行存储空间大小</li>
<li>栈内存分配：程序对数据区的需求在编译时是未知的，只有运行时才能知道，但是在程序入口处 必须知道该程序所需的数据区大小 才能够为其分配内存，栈内存按照先进后出原则进行分配</li>
<li>堆内存分配：只有在程序真正运行到相应的代码时才知道空间的大小</li>
</ul>
</blockquote>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> The only way to fix things is to keep reliving them. - Colter Stevens</p>
<p><a href="https://movie.douban.com/subject/3075287/">Source Code</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM监控</title>
    <url>/2018/04/16/JVMMonitor/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/28.png" class="full-image" />

<p>记录下如何监控JVM，包括JVM的线程、堆内存、CPU使用情况等</p>
<h1 id="GC-LOG"><a href="#GC-LOG" class="headerlink" title="GC LOG"></a>GC LOG</h1><p>GC日志能够反应JVM内存的动态分配回收状况、应用停顿的时间，是GC调优的依据</p>
<h2 id="JVM配置查询"><a href="#JVM配置查询" class="headerlink" title="JVM配置查询"></a>JVM配置查询</h2><blockquote>
<p>jmap -heap [pid]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:dmz-inward- mac$ jmap -heap 1016 （JDK1.8）</span><br><span class="line">Attaching to process ID 1016, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.40-b25</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 1073741824 (1024.0MB)</span><br><span class="line">   NewSize                  = 22020096 (21.0MB)</span><br><span class="line">   MaxNewSize               = 357564416 (341.0MB)</span><br><span class="line">   OldSize                  = 45088768 (43.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 16777216 (16.0MB)</span><br><span class="line">   used     = 11951560 (11.397895812988281MB)</span><br><span class="line">   free     = 4825656 (4.602104187011719MB)</span><br><span class="line">   71.23684883117676% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 3145728 (3.0MB)</span><br><span class="line">   used     = 2879968 (2.746551513671875MB)</span><br><span class="line">   free     = 265760 (0.253448486328125MB)</span><br><span class="line">   91.55171712239583% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 3145728 (3.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 3145728 (3.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 45088768 (43.0MB)</span><br><span class="line">   used     = 857520 (0.8177947998046875MB)</span><br><span class="line">   free     = 44231248 (42.18220520019531MB)</span><br><span class="line">   1.9018483716388082% used</span><br><span class="line"></span><br><span class="line">4674 interned Strings occupying 366808 bytes.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="GC日志文件"><a href="#GC日志文件" class="headerlink" title="GC日志文件"></a>GC日志文件</h2><ul>
<li>-verbose:gc</li>
<li>-XX:+PrintGCDetails</li>
<li>-XX:+PrintGCApplicationStoppedTime</li>
<li>-XX:+PrintGCDateStamps</li>
<li>-XX:+PrintHeapAtGC , GC前后输出堆内存大小</li>
<li>-Xloggc:[file] , GC信息输出到独立文件中</li>
<li>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;[file] ,记录 堆内存耗尽时的堆快照</li>
<li>-XX:ErrorFile&#x3D;[file] ,记录JVM虚拟机本身的异常信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCApplicationStoppedTime -XX:+PrintHeapAtGC -Xloggc:/tmp/gc.log  -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/ -XX:ErrorFile=/tmp/JVM_Error.log</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="http://gceasy.io/index.jsp">分析GC Log</a></li>
</ul>
<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><ol>
<li>GC、堆内存信息总情况</li>
</ol>
<blockquote>
<p>jstat -gcutil [pid] [intervel] [count]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:JDK mac$ jstat -gcutil 3157 500 2</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">  0.00   0.00  52.00  97.79  66.51  69.76      3    0.022     2    0.067    0.089</span><br><span class="line">  0.00   0.00  52.00  95.80  66.51  69.76      3    0.022     2    0.067    0.089</span><br><span class="line">  </span><br><span class="line">  S0 S1 E O M : 表示堆内存各区已使用空间的百分比</span><br><span class="line">  YGC FGC : 表示Young GC、Full GC 的次数</span><br><span class="line">  YGCT FGCT GCT : 表示YoungGC、Full GC 、GC 所用的时间</span><br><span class="line">  CCS : 压缩使用比例</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>年轻代GC情况<blockquote>
<p>jstat -gcnew [pid] [intervel] [count]</p>
</blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:JDK mac$ jstat -gcnew 3157 500 2</span><br><span class="line"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  </span><br><span class="line"> 512.0  512.0    0.0    0.0  7  15  512.0   2048.0   1065.0     11    0.044</span><br><span class="line"> 512.0  512.0    0.0    0.0  7  15  512.0   2048.0   1065.0     11    0.044</span><br><span class="line"></span><br><span class="line"> S0C S1C EC : S0、S1、E区大小(KB)</span><br><span class="line"> S0U S1U EU : S0、S1、E区已使用大小(KB)</span><br><span class="line"> TT : 对象在新生代存活的次数</span><br><span class="line"> MTT : 对象的最大年龄</span><br><span class="line"> DSS : 期待的Survivor区大小</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>年轻代内存统计<blockquote>
<p>jstat -gcnewcapacity [pid]</p>
</blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:JDK mac$ jstat -gcnewcapacity 3157</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC </span><br><span class="line">    3072.0    13312.0     3072.0   4096.0    512.0   4096.0    512.0    12288.0     2048.0    15    14</span><br><span class="line"></span><br><span class="line">  NGCMN NGCMX : 年轻代最小、最大空间</span><br><span class="line">  NGC ：当前年轻代大小</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>年老代<blockquote>
<p>jstat -gcold [pid] [intervel] [count]</p>
<p>jstat -gcoldcapacity [pid]</p>
</blockquote>
</li>
<li>元数据空间<blockquote>
<p>jstat -gcmetacapacity [pid]</p>
</blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:JDK mac$ jstat -gcmetacapacity 3157</span><br><span class="line">   MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT   </span><br><span class="line">       0.0  1056768.0     4864.0        0.0  1048576.0      512.0    17    16    0.491    0.556</span><br><span class="line">   </span><br><span class="line">   CCSMN CCSMX : 压缩类最小、最大空间</span><br><span class="line">   CCSC : 当前压缩类空间大小</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h1 id="命令行监控"><a href="#命令行监控" class="headerlink" title="命令行监控"></a>命令行监控</h1><p>命令行监控可结合脚本共同使用</p>
<h2 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取运行的JVM进程：jcmd -l</span><br><span class="line">获取JVM运行的时间：jcmd process_id VM.uptime</span><br><span class="line">获取系统属性：jcmd process_id VM.system_properties</span><br><span class="line">获取JVM调优参数：jcmd process_id VM.flags</span><br><span class="line">获取JVM线程信息：jcmd process_id Thread.print</span><br></pre></td></tr></table></figure>

<h2 id="堆快照文件"><a href="#堆快照文件" class="headerlink" title="堆快照文件"></a>堆快照文件</h2><p>jmap用于导出堆的快照文件，便于后续分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:JDK mac$ jmap -dump:format=b,file=/Users/mac/IdeaProjects/JDK/heap.hprof 3157</span><br><span class="line">Dumping heap to /Users/mac/IdeaProjects/JDK/heap.hprof ...</span><br><span class="line">Heap dump file created</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://www.eclipse.org/mat/downloads.php">堆快照分析工具MAT</a></li>
</ul>
<h2 id="线程栈文件"><a href="#线程栈文件" class="headerlink" title="线程栈文件"></a>线程栈文件</h2><p>将线程栈信息导入文件<br>jstack [pid] &gt; threaddump.out | jcmd [pid] Thread.print &gt; .&#x2F;threaddump.out</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:JDK mac$ jcmd 3157 Thread.print &gt; ./threaddump.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://fastthread.io/index.jsp">分析线程栈</a></li>
</ul>
<h1 id="图形化监控"><a href="#图形化监控" class="headerlink" title="图形化监控"></a>图形化监控</h1><p>JDK内置有jvisualvm 、jconsole 直观的图形化监控工具</p>
<h2 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过命令行直接唤醒启动</span><br><span class="line"></span><br><span class="line">Mac:JDK mac$ jvisualvm</span><br></pre></td></tr></table></figure>

<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/JVM/Java_VisualVM.png" alt="image"></p>
<h2 id="Visual-GC"><a href="#Visual-GC" class="headerlink" title="Visual GC"></a>Visual GC</h2><p>Visual GC提供图形化的JVM堆内存使用的动态监控，由VisualVM以插件的形式提供</p>
<ul>
<li>设置<a href="https://visualvm.github.io/pluginscenters.html">插件更新地址</a><br>按JDK需要选择</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/JVM/VisualGC.png" alt="image"></p>
<ul>
<li>堆内存动态监控</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/JVM/VisualGC_D.png" alt="image"></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> A magician is a man of his word. - Alfred Borden</p>
<p><a href="https://movie.douban.com/subject/1780330/">The Prestige</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h1 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h1><p>如何定位服务器 CPU 使用率过高的问题？可以通过如下几个步骤</p>
<h2 id="获取系统进程信息"><a href="#获取系统进程信息" class="headerlink" title="获取系统进程信息"></a>获取系统进程信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每隔 5s 刷新一次</span></span><br><span class="line">top -c -d5</span><br></pre></td></tr></table></figure>
<h2 id="找出-CPU-使用率最高的-PID"><a href="#找出-CPU-使用率最高的-PID" class="headerlink" title="找出 CPU 使用率最高的 PID"></a>找出 CPU 使用率最高的 PID</h2><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/JVM/topc.png" alt="image"></p>
<h2 id="获取指定进程的线程信息"><a href="#获取指定进程的线程信息" class="headerlink" title="获取指定进程的线程信息"></a>获取指定进程的线程信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top -H -p 1</span><br></pre></td></tr></table></figure>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/JVM/toph.png" alt="image"></p>
<p>找出 CPU 使用率最高的 PID（这里是线程 ID），并将线程 ID 转换为16进制值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf &#x27;0x%x\n&#x27; 6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0x6</span></span><br></pre></td></tr></table></figure>

<h2 id="查询线程信息，并定位源码位置"><a href="#查询线程信息，并定位源码位置" class="headerlink" title="查询线程信息，并定位源码位置"></a>查询线程信息，并定位源码位置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstack 1 | grep 0x6 -A 50</span><br></pre></td></tr></table></figure>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/JVM/jstackinfo.png" alt="image"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM调优</title>
    <url>/2018/04/13/JVMTuning/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/29.png" class="full-image" />

<p>JVM到底怎么优化啊？优化什么？为啥要优化。。？</p>
<h1 id="堆内存分配与回收时机"><a href="#堆内存分配与回收时机" class="headerlink" title="堆内存分配与回收时机"></a>堆内存分配与回收时机</h1><p> 大家都知道JVM中的<a href="http://whathowhy.com/2018/04/04/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">堆内存是分代</a>的结构，来看看堆内存的开辟与回收的细节</p>
<h2 id="堆内存的分配"><a href="#堆内存的分配" class="headerlink" title="堆内存的分配"></a>堆内存的分配</h2><ul>
<li>Eden区：对于新创建的对象，<strong>一般</strong>都会在此区域，新生对象不见得都会在此区域</li>
<li>Survivor区：Young区经过Minor GC，存活下的对象<strong>一般</strong>都此区，Young区存活的对象不见得都会在此区域</li>
<li>Old 区：经受住了多次Minor GC，Full GC存活的对象，都在此区域</li>
</ul>
<h2 id="堆内存的回收"><a href="#堆内存的回收" class="headerlink" title="堆内存的回收"></a>堆内存的回收</h2><p> 堆内存在Minor GC 与 Full GC发生的时候回收，那么Minor GC 、Full GC 什么时候发生呢。。</p>
 <span id="more"></span>

<h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p> Minor GC发生在Young区，当Eden区满时会触发Minor GC，新生代的对象一般存活的时间很短，Minor GC会很频繁，由于是复制算法所以执行时间较快</p>
<h3 id="Full-GC-Major-GC"><a href="#Full-GC-Major-GC" class="headerlink" title="Full GC &#x2F;Major GC"></a>Full GC &#x2F;Major GC</h3><p> Major GC 亦指 Full GC ，Full GC会对整个堆区进行内存回收。Full GC发生在以下情况</p>
<ol>
<li>Old区空间不足会触发Full GC</li>
<li>Perm区满后会触发Full GC（设置CMS GC的情况除外）</li>
<li>执行CMS GC的过程中有对象进入Old区，Old区不足会报 Concurrent Mode Failure 错误，并触发 Full GC</li>
<li>Minor GC时检测之前晋升到Old区平均对象大小（这个平均晋升大小是靠不住的），<sup>1。</sup>若大于Old区剩余大小，则直接触发Full GC。 <sup>2。</sup>若小于Old区剩余大小，则查看HandlePromotionFailure是否开启，若开启则会触发Full GC</li>
<li>System.gc()方法建议JVM进行Full GC，使用DisableExplicitGC可禁用Full GC的显示调用</li>
</ol>
<h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><h2 id="扩大年轻代堆空间"><a href="#扩大年轻代堆空间" class="headerlink" title="扩大年轻代堆空间"></a>扩大年轻代堆空间</h2><p> JVM尝试将新生对象放入Eden区，若Eden区空间不够则会将对象提前放入Old区。Minor GC的成本远低于Full GC ，因此可以将对象尽可能保留在年轻代</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JVM 参数：-Xmx20M -Xms20M -XX:+PrintGCDetails</span><br><span class="line"></span><br><span class="line">    private static void OptimizeOne() &#123;</span><br><span class="line">        int M = 1024 * 1024;</span><br><span class="line">        byte[] b1 = new byte[2 * M]; // 2M</span><br><span class="line">        byte[] b2 = new byte[2 * M];</span><br><span class="line">        byte[] b3 = new byte[2 * M];</span><br><span class="line">        byte[] b4 = new byte[2 * M];</span><br><span class="line">        byte[] b5 = new byte[2 * M];</span><br><span class="line">        byte[] b7 = new byte[2 * M];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">GC Log：</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3890K-512K(6144K)] 3890K-2664K(19968K), 0.0033226 secs] [Times: user=0.01 sys=0.01, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4772K-512K(6144K)] 6924K-6768K(19968K), 0.0057943 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4733K-496K(6144K)] 10989K-10864K(19968K), 0.0050538 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 496K-0K(6144K)] [ParOldGen: 10368K-10747K(13824K)] 10864K-10747K(19968K), [Metaspace: 3061K-3061K(1056768K)], 0.0088463 secs] [Times: user=0.02 sys=0.01, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 6144K, used 2209K [0x00000007bf980000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 5632K, 39% used [0x00000007bf980000,0x00000007bfba84c8,0x00000007bff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span><br><span class="line"> ParOldGen       total 13824K, used 10747K [0x00000007bec00000, 0x00000007bf980000, 0x00000007bf980000)</span><br><span class="line">  object space 13824K, 77% used [0x00000007bec00000,0x00000007bf67ef40,0x00000007bf980000)</span><br><span class="line"> Metaspace       used 3117K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 340K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p> 通过GC Log可以发现Young区的大小为6M ，适当调整年轻代大小</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JVM 参数：-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails</span><br><span class="line"></span><br><span class="line">    private static void OptimizeOne() &#123;</span><br><span class="line">        int M = 1024 * 1024;</span><br><span class="line">        byte[] b1 = new byte[2 * M]; // 2M</span><br><span class="line">        byte[] b2 = new byte[2 * M];</span><br><span class="line">        byte[] b3 = new byte[2 * M];</span><br><span class="line">        byte[] b4 = new byte[2 * M];</span><br><span class="line">        byte[] b5 = new byte[2 * M];</span><br><span class="line">        byte[] b7 = new byte[2 * M];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">GC Log:</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 6153K-608K(9216K)] 6153K-4704K(19456K), 0.0059569 secs] [Times: user=0.01 sys=0.01, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) --[PSYoungGen: 6991K-6991K(9216K)] 11087K-15191K(19456K), 0.0058702 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 6991K-2560K(9216K)] [ParOldGen: 8200K-8192K(10240K)] 15191K-10752K(19456K), [Metaspace: 3159K-3159K(1056768K)], 0.0070982 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 4995K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 8192K, 60% used [0x00000007bf600000,0x00000007bfae0c10,0x00000007bfe00000)</span><br><span class="line">  from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)</span><br><span class="line"> ParOldGen       total 10240K, used 8192K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  object space 10240K, 80% used [0x00000007bec00000,0x00000007bf400168,0x00000007bf600000)</span><br><span class="line"> Metaspace       used 3187K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 347K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<h2 id="年轻代不留大对象"><a href="#年轻代不留大对象" class="headerlink" title="年轻代不留大对象"></a>年轻代不留大对象</h2><p> JVM将新生的对象放入Yong区，若对象一出生就超级大，针对后续新产生的对象可能会导致Young区小对象频繁的转入Old区</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JVM 参数：-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails</span><br><span class="line"></span><br><span class="line">    private static void OptimizeTwo() &#123;</span><br><span class="line">        int M = 1024 * 1024;</span><br><span class="line">        byte[] b1 = new byte[3 * M]; // 3M</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">GC Log:</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 6144K, used 4914K [0x00000007bf980000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 5632K, 87% used [0x00000007bf980000,0x00000007bfe4c8e8,0x00000007bff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)</span><br><span class="line"> ParOldGen       total 13824K, used 0K [0x00000007bec00000, 0x00000007bf980000, 0x00000007bf980000)</span><br><span class="line">  object space 13824K, 0% used [0x00000007bec00000,0x00000007bec00000,0x00000007bf980000)</span><br><span class="line"> Metaspace       used 3045K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 334K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 新生对象直接占据了Eden区的87%，将新生的大对象直接放入Old区，有利于提升GC效率，设置对象大小阀值-XX:PretenureSizeThreshold&#x3D;3M (此设置对 +UseParallelGC 无效)</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JVM 参数：-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:PretenureSizeThreshold=3M -XX:+UseParNewGC</span><br><span class="line"></span><br><span class="line">    private static void OptimizeTwo() &#123;</span><br><span class="line">        int M = 1024 * 1024;</span><br><span class="line">        byte[] b1 = new byte[3 * M]; // 3M</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">GC Log：</span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 6144K, used 1947K [0x00000007bec00000, 0x00000007bf2a0000, 0x00000007bf2a0000)</span><br><span class="line">  eden space 5504K,  35% used [0x00000007bec00000, 0x00000007bede6e40, 0x00000007bf160000)</span><br><span class="line">  from space 640K,   0% used [0x00000007bf160000, 0x00000007bf160000, 0x00000007bf200000)</span><br><span class="line">  to   space 640K,   0% used [0x00000007bf200000, 0x00000007bf200000, 0x00000007bf2a0000)</span><br><span class="line"> tenured generation   total 13696K, used 3072K [0x00000007bf2a0000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 13696K,  22% used [0x00000007bf2a0000, 0x00000007bf5a0010, 0x00000007bf5a0200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3045K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 334K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 可以发现3M的对象直接放入了Old区</p>
<h2 id="对象的年龄"><a href="#对象的年龄" class="headerlink" title="对象的年龄"></a>对象的年龄</h2><p> 对象的年龄指经过Minor GC仍存活在Young区的次数，当对象超过指定的年龄后会被移动到Old区，年龄未超过设置的阀值一样可能会移动到Old区，当Survivor区中相同年龄大小的所有对象大小总和超过了Survivor区空间的一半（默认 -XX:TargetSurvivorRatio&#x3D;50）则会被移动到Old区</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JVM 参数：-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails</span><br><span class="line">    private static void OptimizeThree() &#123;</span><br><span class="line">        int M = 1024 * 1024;</span><br><span class="line">        byte[] b1 = new byte[2 * M]; // 2M</span><br><span class="line">        byte[] b2 = new byte[2 * M];</span><br><span class="line">        byte[] b4 = new byte[2 * M];</span><br><span class="line">        b4 = null;</span><br><span class="line">        byte[] b5 = new byte[2 * M];</span><br><span class="line">        byte[] b6 = new byte[2 * M];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">GC Log:</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3891K-496K(6144K)] 3891K-2640K(19968K), 0.0031407 secs] [Times: user=0.01 sys=0.01, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4756K-496K(6144K)] 6900K-4712K(19968K), 0.0030381 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 6144K, used 4775K [0x00000007bf980000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 5632K, 75% used [0x00000007bf980000,0x00000007bfdadd80,0x00000007bff00000)</span><br><span class="line">  from space 512K, 96% used [0x00000007bff80000,0x00000007bfffc010,0x00000007c0000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)</span><br><span class="line"> ParOldGen       total 13824K, used 4216K [0x00000007bec00000, 0x00000007bf980000, 0x00000007bf980000)</span><br><span class="line">  object space 13824K, 30% used [0x00000007bec00000,0x00000007bf01e020,0x00000007bf980000)</span><br><span class="line"> Metaspace       used 3165K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 345K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 设置对象年龄阀值 MaxTenuringThreshold</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JVM 参数：-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:MaxTenuringThreshold=1</span><br><span class="line">    private static void OptimizeThree() &#123;</span><br><span class="line">        int M = 1024 * 1024;</span><br><span class="line">        byte[] b1 = new byte[2 * M]; // 2M</span><br><span class="line">        byte[] b2 = new byte[2 * M];</span><br><span class="line">        byte[] b4 = new byte[2 * M];</span><br><span class="line">        b4 = null;</span><br><span class="line">        byte[] b5 = new byte[2 * M];</span><br><span class="line">        byte[] b6 = new byte[2 * M];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">GC Log:</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4123K-512K(6144K)] 4123K-2648K(19968K), 0.0033229 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4770K-32K(6144K)] 6906K-4692K(19968K), 0.0037061 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 6144K, used 4309K [0x00000007bf980000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 5632K, 75% used [0x00000007bf980000,0x00000007bfdad6d0,0x00000007bff00000)</span><br><span class="line">  from space 512K, 6% used [0x00000007bff80000,0x00000007bff88000,0x00000007c0000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)</span><br><span class="line"> ParOldGen       total 13824K, used 4660K [0x00000007bec00000, 0x00000007bf980000, 0x00000007bf980000)</span><br><span class="line">  object space 13824K, 33% used [0x00000007bec00000,0x00000007bf08d310,0x00000007bf980000)</span><br><span class="line"> Metaspace       used 3204K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p> 对比可以发现，进行在第二次GC时，设置了对象年龄&#x3D;1的对象被移到了Old区</p>
<h2 id="提高系统吞吐量"><a href="#提高系统吞吐量" class="headerlink" title="提高系统吞吐量"></a>提高系统吞吐量</h2><p> 减少GC执行的总时间，可以提升系统的吞吐量，可以使用关注吞吐量的ParallelGC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java –Xmx3072m –Xms3072m –Xmn2G –Xss128k –XX:+UseParallelGC -XX:ParallelGCThreads=2 –XX:+UseParallelOldGC</span><br></pre></td></tr></table></figure>
<h2 id="提高系统响应时间"><a href="#提高系统响应时间" class="headerlink" title="提高系统响应时间"></a>提高系统响应时间</h2><ol>
<li>尽可能将新生对象留在Yong区来减少Full GC的次数，Minor GC的成本要小于Full GC</li>
<li>使用关注响应时间的CMS GC</li>
<li>稍大的Survivor空间、较高的目标存活率，可以使对象直接在Young区回收，而不必因空间不够进入Old区</li>
<li>最大堆等于最小堆，避免堆内存的震荡从而降低系统性能，堆内存变小必然会带来更多的GC次数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java –Xmx3072m –Xms3072m –Xmn2G –Xss128k –XX:+UseParNewGC -XX:SurvivorRatio=8 -XX:TargetSurvivorRatio=90 –XX:+UseConcMarkSweepGC –XX:MaxTenuringThreshold=31 -XX:ParallelGCThreads=2</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> Memory’s just a trick. - Leonard</p>
<p><a href="https://movie.douban.com/subject/1304447/">Memento</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Char 编码</title>
    <url>/2018/03/31/JavaCharCoder/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/34.png" class="full-image" />

<!-- # 编码问题 -->

<p>记录下自己对<strong>编码的理解和疑惑</strong>，什么是<strong>Unicode？UTF-8、UTF-16、ASCII</strong>又是什么？</p>
<h1 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h1><blockquote>
<p><strong>编码</strong> ：信息从一种数据形式到另一种数据形式的转换过程。信息在计算机中的存储与传输是以二               进制的形式（010101）进行的，计算机中的存储单元为Byte，所以需要计算机处理的信息必须编码为Bytes。</p>
</blockquote>
<blockquote>
<p><strong>解码</strong>：编码的逆向过程。计算机中为Bytes到字符信息的转换。</p>
</blockquote>
<h2 id="为什么要编码"><a href="#为什么要编码" class="headerlink" title="为什么要编码"></a>为什么要编码</h2><blockquote>
<p>计算机中的存储单元为Byte即<strong>8位的二进制</strong>形式，所能表达的字符范围为2<sup>8</sup> &#x3D; 256种，现存的字符远远多于256种，所以单个字节不足以存够如此多的字符。不同字符的表达是多样性的，不同地区使用不同的语言表达（字符编码），不同的语言自然有不同的字典解释（字符解码）。如何解码呢？byte c1&#x3D;97代表什么字符？int c2&#x3D; 26790 又该如何翻译呢？</p>
</blockquote>
<h2 id="解码翻译"><a href="#解码翻译" class="headerlink" title="解码翻译"></a>解码翻译</h2><blockquote>
<p><em><strong>ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16</strong></em>编码表中记录了不同字符的不同表达方式。是否存在不同字符的统一表达方式呢？即所有字符存在同一张编码表中。Unicode编码集保存着全世界的字符的编码点（CodePoint)，可以存储足够多的字符表示。Unicode的编码形式又分为UTF-8，UTF-16，UTF-32分别表示8位，16位，32位存储。采用哪种编码需要在传输大小、编码效率等问题进行折中选择。UTF-8是可变长度的编码规则，一般会采用UTF-8进行编码，</p>
</blockquote>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><blockquote>
<p><strong>Unicode</strong>的编码点<em><strong>以U+开始如U+0x0020的形式</strong></em>表示，能表示的编码点范围为0x0000 ~ 0x10FFFF。我们知道Java中的字符都是以Unicode的形式保存的，并且采用UTF-16的形式编码，所以说Java中的char占用16位即2个字节，16位所能存储的最大值为0xFFFF。<em><strong>那么对于U+10000~U+10FFFF部分的CodePoint（这一部分代表的字符被称为辅助字符supplementary character），Java中的UTF-16显然无法存储</strong></em></p>
</blockquote>
<span id="more"></span>

<h2 id="UTF-8的编码规则"><a href="#UTF-8的编码规则" class="headerlink" title="UTF-8的编码规则"></a>UTF-8的编码规则</h2><table>
<thead>
<tr>
<th>编码点</th>
<th>编码方式</th>
</tr>
</thead>
<tbody><tr>
<td>U+0000 ~ U+007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>U+0080 ~ U+07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>U+0800 ~ U+FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>U+10000 ~ U+10FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<h1 id="Java中的char类型"><a href="#Java中的char类型" class="headerlink" title="Java中的char类型"></a>Java中的char类型</h1><blockquote>
<p>Java中的char类型采用UTF-16描述一个代码单元，对于超过0xFFFF的代码点的字符需要两个代码单元表示。刚好int类型(32位)可以存储所有的Unicode代码点。</p>
</blockquote>
<h2 id="简单事例"><a href="#简单事例" class="headerlink" title="简单事例"></a>简单事例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char bmp = &#x27;\u68a6&#x27;;</span><br><span class="line">System.out.println(&quot;BMP:&quot;+bmp);</span><br><span class="line">char[] chars = &#123;&#x27;\uD800&#x27;,&#x27;\uDFC3&#x27;&#125;;</span><br><span class="line">String supplementary = new String(chars);</span><br><span class="line">System.out.println(&quot;Supplementary:&quot;+supplementary);</span><br><span class="line"></span><br><span class="line">BMP:梦</span><br><span class="line">Supplementary:𐏃</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> I know Kung Fu. - Neo</p>
<p><a href="https://movie.douban.com/subject/1291843/">The Matrix</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>/2023/02/05/JavaConcurrencyinPractice/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/46.png" class="full-image" />

<p>随着摩尔定律的失效，现代计算机拥有越来越多的核心数，如何高效利用多核能力提升系统吞吐量、响应速度是非常关键的。在 Java 应用程序中实现安全、高效、可伸缩的并发编程是极其困难的，但仍有一些技巧可遵循</p>
<h1 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h1><p>所有的并发问题都可以归纳为如何协调对并发状态的访问。可变状态越少，越容易确保线程安全性</p>
<ul>
<li>域如果不需要可变，尽量声明为 <strong>final</strong> 类型</li>
<li>不可变对象一定是线程安全的</li>
<li>封装可以有效管理复杂性。例如：可以将同步机制维护在对象内部</li>
<li>使用同一把锁保护同一个 <u><strong>不变性条件</strong></u><sup>一组变量的值在某一时刻不会发生变化</sup>中的所有变量</li>
<li>对复合操作加锁</li>
<li>从多个线程中访问同一个未加锁的可变变量，程序肯定会出问题</li>
<li>在设计过程中考虑线程安全问题，并文档化</li>
</ul>
<p>关于Java线程内容可以到这里了解 <a href="https://whathowhy.com/2018/08/20/JavaThread/">Java线程基础</a> 和 <a href="https://whathowhy.com/2018/08/18/ConcurrencyThreads/">并发与多线程</a></p>
<span id="more"></span>

<h1 id="结构化"><a href="#结构化" class="headerlink" title="结构化"></a>结构化</h1><p>围绕<strong>“任务执行”</strong>来设计并发程序，可以简化开发过程，提供更好的并发维护</p>
<ol>
<li>定义清晰的任务边界</li>
<li>把工作分解为一系列任务</li>
<li>任务封装为 FutureTask</li>
<li>将 FutureTask 提交给 Executor</li>
</ol>
<p>Executor 框架将任务提交与执行策略解耦，支持不同类型的执行策略，使用 FutureTask 和 Executor 框架，可以帮助我们构建可取消的任务和服务</p>
<h1 id="并发包"><a href="#并发包" class="headerlink" title="并发包"></a>并发包</h1><p>Java <em><strong>java.util.concurrent</strong></em> 中提供了非常多性能优秀的并发工具类，如：同步器、读写锁、原子变量等。在进行并发编程时，应该优先使用并发包中的工具</p>
<h1 id="性能与可伸缩性"><a href="#性能与可伸缩性" class="headerlink" title="性能与可伸缩性"></a>性能与可伸缩性</h1><p>性能指标大概可以分为 <u>运行速度</u> 和 <u>处理能力</u> 两大类</p>
<ul>
<li>运行速度：指定任务单元需要<strong>“多快”</strong>才能处理完成。例如：延迟时间、响应时间</li>
<li>处理能力：一定的计算资源下能完成<strong>“多少”</strong>工作。例如：吞吐量、可伸缩性</li>
</ul>
<p>对服务器应用来说，<strong>“多少”</strong> 比 <strong>“多快”</strong> 更重要。在并发编程中，独占方式的资源锁是对可伸缩性的最主要威胁，因此可以通过减少锁的持有时间，降低锁的粒度，以及采用非独占锁（如：ReadWriteLock ）或非阻塞锁（如：AtomicLong、ReentrantLock 等）来代替独占锁</p>
<blockquote>
<p>可伸缩性是指：当增加计算资源时（CPU、内存、存储容量或I&#x2F;O带宽），程序的吞吐量或者处理能力相应地提升</p>
</blockquote>
<h2 id="Amdahl’s-Law"><a href="#Amdahl’s-Law" class="headerlink" title="Amdahl’s Law"></a>Amdahl’s Law</h2><p>Amdahl 定律描述的是：在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中可并行组件与串行组件所占的比重。最高加速比的公式为：</p>
<p>$$\begin{equation*}<br>Speedup&lt;&#x3D;\frac{1}{F+\frac{(1-F)}{N}}<br>\end{equation*}$$</p>
<p><strong>F：</strong>必须被执行的串行部分<br><strong>1-F：</strong>并行执行部分<br><strong>N：</strong>处理核心数<br><strong>Speedup：</strong>问题规模不变的情况下，提升处理器并行能力后能提升多少系统性能</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://book.douban.com/subject/10484692/">Java并发编程实战</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>I never had a family. I wanted one though. - Léon</p>
<p><a href="https://movie.douban.com/subject/1295644/">Léon</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程基础</title>
    <url>/2018/08/20/JavaThread/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/22.png" class="full-image" />

<p>记录下Java中多线程的使用</p>
<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><ol>
<li>NEW：线程被创建未启动</li>
<li>RUNNABLE：线程为启动状态，被虚拟机执行或者是等待系统资源中</li>
<li>WAITING：线程调用 Object.wait、Thread.join或LockSupport.park方法，线程进入WAITING状态</li>
<li>TIMED_WAITING：线程调用 Thread.sleep 、Object.wait(10) 、Thread.join(10)、LockSupport.parkNanos 或 LockSupport.parkUntil方法 ，线程进入TIMED_WAITING状态</li>
<li>BLOCKED：线程等待获取锁</li>
<li>TERMINATED：线程死亡</li>
</ol>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="image"></p>
<span id="more"></span>

<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ThreadStates extends Thread &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      threadCurrentState(&quot;RUNNABLE&quot;, this);</span><br><span class="line">      TimeUnit.SECONDS.sleep(5);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void entryMonitor() &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      synchronized (ThreadStates.class) &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(3);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public void threadCurrentState(String name, Thread thread) &#123;</span><br><span class="line">    System.out.println(name + &quot;&#x27;s state is &quot; + thread.getState());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void newRunnableTimedWaitingTerminated() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    threadCurrentState(&quot;NEW&quot;, this);</span><br><span class="line"></span><br><span class="line">    this.start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">    threadCurrentState(&quot;TIMED_WAITING&quot;, this);</span><br><span class="line"></span><br><span class="line">    Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; threadCurrentState(&quot;TERMINATED&quot;, this)));</span><br><span class="line"></span><br><span class="line">    Thread joinT = new Thread(() -&gt; entryMonitor());</span><br><span class="line"></span><br><span class="line">    joinT.start();</span><br><span class="line"></span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line"></span><br><span class="line">        Thread blockedT = new Thread(() -&gt; entryMonitor());</span><br><span class="line">        blockedT.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        threadCurrentState(&quot;BLOCKED&quot;, blockedT);</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        threadCurrentState(&quot;WAITING&quot;, thread);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    joinT.join();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  new ThreadStates().newRunnableTimedWaitingTerminated();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">NEW&#x27;s state is NEW</span><br><span class="line">RUNNABLE&#x27;s state is RUNNABLE</span><br><span class="line">TIMED_WAITING&#x27;s state is TIMED_WAITING</span><br><span class="line">BLOCKED&#x27;s state is BLOCKED</span><br><span class="line">WAITING&#x27;s state is WAITING</span><br><span class="line">TERMINATED&#x27;s state is TERMINATED</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="线程的创建与启动"><a href="#线程的创建与启动" class="headerlink" title="线程的创建与启动"></a>线程的创建与启动</h1><p>下面是几种在Java中运行线程的方式</p>
<ol>
<li>继承Thread</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ThreadExtend extends Thread &#123;</span><br><span class="line"></span><br><span class="line">  public ThreadExtend() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ThreadExtend(String name) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    System.out.println(&quot;I&#x27;m &quot;+getName()+&quot;, coming from extend&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new ThreadExtend(&quot;ThreadExtend&quot;).start();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>实现Runnable接口</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ThreadRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  private String name;</span><br><span class="line"></span><br><span class="line">  public ThreadRunnable(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    System.out.println(&quot;I&#x27;m &quot;+name+&quot;, coming from runnable&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Thread(new ThreadRunnable(&quot;ThreadRunnable&quot;)).start();</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>实现Callable接口</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ThreadWithCallable implements Callable&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String call() &#123;</span><br><span class="line">    return &quot;Thread Callable&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadWithCallable threadWithCallable = new ThreadWithCallable();</span><br><span class="line">FutureTask&lt;String&gt; futureTask = new FutureTask(threadWithCallable);</span><br><span class="line">new Thread(futureTask).start();</span><br><span class="line">try &#123;</span><br><span class="line">     System.out.println(futureTask.get());</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125; catch (ExecutionException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>基于线程池</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(2);</span><br><span class="line">executorService.submit(new ThreadExtend());</span><br><span class="line">System.out.println(executorService.submit(new ThreadWithCallable()).get());</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>

<h1 id="线程常用的相关方法"><a href="#线程常用的相关方法" class="headerlink" title="线程常用的相关方法"></a>线程常用的相关方法</h1><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>sleep()是线程的方法，此方法会使线程睡眠，sleep()不会释放当前线程已经拥有的监视器。若其他线程线程调用了睡眠线程的interrupt()方法或sleep的时间已到，则线程进入Runnable状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long waitingTime = 10;</span><br><span class="line"></span><br><span class="line">Thread sleepThread = new Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;I&#x27;m gonna go to bed !&quot;);</span><br><span class="line">        TimeUnit.SECONDS.sleep(waitingTime);</span><br><span class="line">        System.out.println(&quot;I was waken up !&quot;);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(&quot;I was interrupted !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sleepThread.start();</span><br><span class="line">sleepThread.interrupt();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Object-wait-notify-notifyAll"><a href="#Object-wait-notify-notifyAll" class="headerlink" title="Object#wait &amp; notify&#x2F;notifyAll"></a>Object#wait &amp; notify&#x2F;notifyAll</h2><ul>
<li>wait()是Object类中定义的方法，当线程持有了Object的监视器才可以调用Object的wait()方法，wiat()会释放持有的监视器。假设当前线程获得了对象锁，则当其他线程试图获得此对象锁时，会导致线程阻塞（Blocked）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WaitNotifyTest implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Integer&gt; queue = new ArrayList&lt;&gt;();</span><br><span class="line">    private int CAPACITY = 5;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        WaitNotifyTest waitNotify = new WaitNotifyTest();</span><br><span class="line">        Thread produceT = new Thread(waitNotify.new Produce());</span><br><span class="line">        Thread consumerT = new Thread(waitNotify.new Consumer());</span><br><span class="line">        produceT.start();</span><br><span class="line">        consumerT.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Produce implements Runnable &#123;</span><br><span class="line">        int count;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    produce(count++);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void produce(int count) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            synchronized (queue) &#123;</span><br><span class="line">                if (queue.size() == CAPACITY) &#123;</span><br><span class="line">                    System.out.println(&quot;Queue is Full...&quot;);</span><br><span class="line">                    queue.wait();</span><br><span class="line">                    System.out.println(&quot;Produce wait over !&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                queue.add(count);</span><br><span class="line">                System.out.println(&quot;Produced :&quot; + count);</span><br><span class="line">                queue.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Consumer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    consume();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void consume() throws InterruptedException &#123;</span><br><span class="line">            synchronized (queue) &#123;</span><br><span class="line">                if (queue.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(&quot;Queue is Empty...&quot;);</span><br><span class="line">                    queue.wait();</span><br><span class="line">                    System.out.println(&quot;Consume wait over !&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                int i = queue.remove(0);</span><br><span class="line">                System.out.println(&quot;Consumed :&quot; + i);</span><br><span class="line">                queue.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait()方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void wait() throws InterruptedException &#123;</span><br><span class="line">    wait(0); // 是个本地方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final native void wait(long timeout) throws InterruptedException; </span><br><span class="line">// 其他线程调用notify()/notifyAll()可以唤醒由wait()方法导致waiting的线程（或者wait等待的时间过期）</span><br></pre></td></tr></table></figure>

<h2 id="LockSupport-park-unpark"><a href="#LockSupport-park-unpark" class="headerlink" title="LockSupport#park &amp; unpark"></a>LockSupport#park &amp; unpark</h2><ul>
<li>park()功能同wait()，只是wait在调用前必须先获得监视器。对于线程的唤醒来说，unpark可以唤醒指定的线程，而notify&#x2F;notifyAll无法唤醒指定的线程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ForWakeUpThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  private Thread waitForWakeUp;</span><br><span class="line"></span><br><span class="line">  public ForWakeUpThread(Thread thread) &#123;</span><br><span class="line">    this.waitForWakeUp = thread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      Thread.sleep(10000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Wake Up Main Thread !&quot;);</span><br><span class="line">    LockSupport.unpark(waitForWakeUp);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ForWakeUpThread wakeUpT = new ForWakeUpThread(Thread.currentThread());</span><br><span class="line">new Thread(wakeUpT).start();</span><br><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(&quot;Main Thread Over !&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="Condition-await-signal"><a href="#Condition-await-signal" class="headerlink" title="Condition#await &amp; signal"></a>Condition#await &amp; signal</h2><ul>
<li>await()支持多个等待队列，监视器锁只有一个等待队列，当notify&#x2F;notifyAll被调用的时候系统无法知道该唤醒消费者还是生产者。await()与signal()利用了LockSupport#park&#x2F;unpark方法将线程阻塞与唤醒</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LockConditionTest implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">  private List&lt;Integer&gt; queue = new ArrayList&lt;&gt;();</span><br><span class="line">  private Lock lock = new ReentrantLock();</span><br><span class="line">  private Condition produce = lock.newCondition();</span><br><span class="line">  private Condition consume = lock.newCondition();</span><br><span class="line">  private int CAPACITY = 5;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    LockConditionTest waitNotify = new LockConditionTest();</span><br><span class="line">    Thread produceT = new Thread(waitNotify.new Produce());</span><br><span class="line">    Thread consumerT = new Thread(waitNotify.new Consumer());</span><br><span class="line">    produceT.start();</span><br><span class="line">    consumerT.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Produce implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          produce(count++);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void produce(int count) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        if (queue.size() == CAPACITY) &#123;</span><br><span class="line">          System.out.println(&quot;Queue is Full...&quot;);</span><br><span class="line">          produce.await();</span><br><span class="line">          System.out.println(&quot;Produce wait over !&quot;);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        queue.add(count);</span><br><span class="line">        System.out.println(&quot;Produced :&quot; + count);</span><br><span class="line">        consume.signal();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Consumer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          consume();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void consume() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        if (queue.isEmpty()) &#123;</span><br><span class="line">          System.out.println(&quot;Queue is Empty...&quot;);</span><br><span class="line">          consume.await();</span><br><span class="line">          System.out.println(&quot;Consume wait over !&quot;);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        int i = queue.remove(0);</span><br><span class="line">        System.out.println(&quot;Consumed :&quot; + i);</span><br><span class="line">        produce.signal();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><ul>
<li>join()方法会阻塞调用此方法的线程，当线程执行结束（或者join的时间过期）则等待的线程会继续运行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class JoinThreadPartOne implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">  </span><br><span class="line">    try &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(10);</span><br><span class="line">      System.out.println(&quot;Thread Part One Is Over !&quot;);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread partOneT = new Thread(new JoinThreadPartOne());</span><br><span class="line">partOneT.start();</span><br><span class="line">partOneT.join(); // 阻塞主线程，当partOneT执行结束，主线程将继续执行</span><br><span class="line">System.out.println(&quot;Main Thread Is Over !&quot;);</span><br><span class="line">System.in.read();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>join方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void join() throws InterruptedException &#123;</span><br><span class="line">    join(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final synchronized void join(long millis) // 调用此方法需要获取监视器</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    long base = System.currentTimeMillis();</span><br><span class="line">    long now = 0;</span><br><span class="line"></span><br><span class="line">    if (millis &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (millis == 0) &#123;</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            wait(0);    // 调用的是wait()方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            long delay = millis - now;</span><br><span class="line">            if (delay &lt;= 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h2><p>线程可以设置优先级，优先级较高的线程优先于具有较低优先级的线程执行（并非绝对的优先，由系统尽量保证，所以线程优先级不能作为编码的逻辑控制）。线程优先级因不同的操作系统而有所不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ThreadPriority extends Thread &#123;</span><br><span class="line"></span><br><span class="line">  private int priority;</span><br><span class="line">  private boolean shouldYield;</span><br><span class="line">  private String name;</span><br><span class="line"></span><br><span class="line">  public ThreadPriority(int priority, boolean shouldYield, String name) &#123;</span><br><span class="line">    this.priority = priority;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    this.shouldYield = shouldYield;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;Thread &quot; + name + &quot; With &quot; + priority + &quot; Priority Start&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(5);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (shouldYield) &#123;</span><br><span class="line">      System.out.println(&quot;Thread &quot; + name + &quot; With &quot; + priority + &quot; Priority Yield&quot;);</span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;Thread &quot; + name + &quot; With &quot; + priority + &quot; Priority End&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPriority minPriorityT = new ThreadPriority(Thread.MIN_PRIORITY, false,&quot;A&quot;);</span><br><span class="line">ThreadPriority maxPriorityT = new ThreadPriority(Thread.MAX_PRIORITY, false,&quot;B&quot;);</span><br><span class="line"></span><br><span class="line">minPriorityT.start();</span><br><span class="line">maxPriorityT.start();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>yield()方法是让出当前线程使用的CPU时间片，也就是当前线程让出的CPU时间片让其他同等优先级的线程使用。让出的意图是否被系统接受（如线程优先级一样）完全看系统心情</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ThreadPriority minPriorityT = new ThreadPriority(Thread.MIN_PRIORITY, true,&quot;A&quot;);</span><br><span class="line">ThreadPriority maxPriorityT = new ThreadPriority(Thread.MIN_PRIORITY, false,&quot;B&quot;);</span><br><span class="line"></span><br><span class="line">minPriorityT.start();</span><br><span class="line">maxPriorityT.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p>中断线程的执行，由操作系统向线程发送事件信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ThreadInterrupt implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line"></span><br><span class="line">    for(;;) &#123;</span><br><span class="line"></span><br><span class="line">      boolean isInterrupt = Thread.currentThread().isInterrupted();</span><br><span class="line">      if (isInterrupt) &#123;</span><br><span class="line">        System.out.println(&quot;Current Thread&#x27;s isInterrupt &quot; + isInterrupt);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread interruptT = new Thread(new ThreadInterrupt());</span><br><span class="line">interruptT.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(10);</span><br><span class="line">System.out.println(&quot;Interrupt ThreadInterrupt !&quot;);</span><br><span class="line">interruptT.interrupt();</span><br><span class="line">interruptT.join();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h2><p>若线程设置为守护线程，则当虚拟机中的所有用户线程结束或虚拟机退出，相应的守护线程随之结束（当用户线程都结束了，守护线程的使命即终止）。在守护线程中创建的线程也是守护线程，在用户线程中创建的是线程也是用户线程，线程池框架会将守护线程转为用户线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class DaemonThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line"></span><br><span class="line">    MemoryMXBean memorymbean = ManagementFactory.getMemoryMXBean();</span><br><span class="line">    MemoryUsage usage = memorymbean.getHeapMemoryUsage();</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        System.out.println(&quot;INIT HEAP: &quot; + usage.getInit() / 1024 / 1024 + &quot;MB&quot;);</span><br><span class="line">        System.out.println(&quot;MAX HEAP: &quot; + usage.getMax() / 1024 / 1024 + &quot;MB&quot;);</span><br><span class="line">        System.out.println(&quot;USE HEAP: &quot; + usage.getUsed() / 1024 / 1024 + &quot;MB&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AliveThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    for(;;) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        System.out.println(&quot;I&#x27;m alive !&quot;);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1.System.exit(0) 会退出虚拟机，无论当前是否有守护、用户线程运行</span><br><span class="line">Thread daemonT = new Thread(new DaemonThread());</span><br><span class="line">daemonT.setDaemon(true);</span><br><span class="line">Thread aliveT = new Thread(new AliveThread());</span><br><span class="line">daemonT.start();</span><br><span class="line">aliveT.start();</span><br><span class="line">System.out.println(&quot;Main Thread Over !&quot;);</span><br><span class="line">TimeUnit.SECONDS.sleep(5);</span><br><span class="line">System.exit(0); </span><br><span class="line"></span><br><span class="line">// 1.输出</span><br><span class="line">Main Thread Over !</span><br><span class="line">I&#x27;m alive !</span><br><span class="line">INIT HEAP: 64MB</span><br><span class="line">MAX HEAP: 910MB</span><br><span class="line">USE HEAP: 5MB</span><br><span class="line"></span><br><span class="line">I&#x27;m alive !</span><br><span class="line">INIT HEAP: 64MB</span><br><span class="line">MAX HEAP: 910MB</span><br><span class="line">USE HEAP: 5MB</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 2.JVM等待所有用户线程执行完成后才会退出</span><br><span class="line">Thread aliveT = new Thread(new AliveThread());</span><br><span class="line">aliveT.start();</span><br><span class="line">System.out.println(&quot;Main Thread Over !&quot;);</span><br><span class="line"></span><br><span class="line">// 2.输出</span><br><span class="line">Main Thread Over !</span><br><span class="line">I&#x27;m alive !</span><br><span class="line">I&#x27;m alive !</span><br><span class="line">I&#x27;m alive !</span><br><span class="line">I&#x27;m alive !</span><br><span class="line">I&#x27;m alive !</span><br><span class="line">I&#x27;m alive !</span><br><span class="line">I&#x27;m alive !（无限执行下去）</span><br><span class="line"></span><br><span class="line">// 3.用户线程都执行完成后，JVM退出</span><br><span class="line">Thread daemonT = new Thread(new DaemonThread());</span><br><span class="line">daemonT.setDaemon(true);</span><br><span class="line">System.out.println(&quot;Main Thread Over !&quot;);</span><br><span class="line"></span><br><span class="line">// 3.输出</span><br><span class="line">INIT HEAP: 64MB</span><br><span class="line">MAX HEAP: 910MB</span><br><span class="line">USE HEAP: 5MB</span><br><span class="line"></span><br><span class="line">INIT HEAP: 64MB</span><br><span class="line">MAX HEAP: 910MB</span><br><span class="line">USE HEAP: 5MB</span><br><span class="line"></span><br><span class="line">Main Thread Over !</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br><span class="line">// 4.守护线程一直守护用户线程</span><br><span class="line">Thread daemonT = new Thread(new DaemonThread());</span><br><span class="line">daemonT.setDaemon(true);</span><br><span class="line">Thread aliveT = new Thread(new AliveThread());</span><br><span class="line">daemonT.start();</span><br><span class="line">aliveT.start();</span><br><span class="line">System.out.println(&quot;Main Thread Over !&quot;);</span><br><span class="line"></span><br><span class="line">// 4.输出</span><br><span class="line">Main Thread Over !</span><br><span class="line">I&#x27;m alive !</span><br><span class="line">INIT HEAP: 64MB</span><br><span class="line">MAX HEAP: 910MB</span><br><span class="line">USE HEAP: 6MB</span><br><span class="line"></span><br><span class="line">I&#x27;m alive !</span><br><span class="line">INIT HEAP: 64MB</span><br><span class="line">MAX HEAP: 910MB</span><br><span class="line">USE HEAP: 6MB</span><br><span class="line"></span><br><span class="line">I&#x27;m alive !</span><br><span class="line">INIT HEAP: 64MB</span><br><span class="line">MAX HEAP: 910MB</span><br><span class="line">USE HEAP: 6MB</span><br><span class="line"></span><br><span class="line">I&#x27;m alive !</span><br><span class="line">INIT HEAP: 64MB</span><br><span class="line">MAX HEAP: 910MB</span><br><span class="line">USE HEAP: 6MB（无限执行下去）</span><br></pre></td></tr></table></figure>

<h1 id="多线程可能产生的问题"><a href="#多线程可能产生的问题" class="headerlink" title="多线程可能产生的问题"></a>多线程可能产生的问题</h1><p>活跃性故障</p>
<h2 id="Thread-Starvation"><a href="#Thread-Starvation" class="headerlink" title="Thread Starvation"></a>Thread Starvation</h2><p>如果一个线程一直得不到共享的资源（为什么其他线程都会得到资源，而我一直不能。。），这个线程就很“饥饿”，即 Thread Starvation。导致线程饥饿的原因：</p>
<ol>
<li>线程进入同步方法造成的阻塞等待,可能导致线程饥饿</li>
<li>高优先级的线程抢走资源，可能导致低优先级的线程饥饿</li>
<li>调用了wait()方法的线程，notify()不能保证所有线程的wait都终止，可能导致线程饥饿</li>
</ol>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/Starvation%20due%20to%20priority.png" alt="image"><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/Starvation%20due%20to%20synchronized.png" alt="image"><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/Starvation%20due%20to%20wait.png" alt="image"></p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>公平锁会公平的分配多线程竞争的资源，避免导致线程饥饿</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/Fairness%20Lock.png" alt="image"></p>
<h2 id="Thread-Deadlock"><a href="#Thread-Deadlock" class="headerlink" title="Thread Deadlock"></a>Thread Deadlock</h2><p>假设当前有线程A和B，线程A获得资源AA的锁并尝试获得资源BB的锁，而此时线程B已经获得了资源BB的锁并尝试获得资源AA的锁 –&gt;产生死锁，死锁状态下的线程状态为BLOCKED。如同不懂退让的两只山羊过桥,两只羊各先占一半桥，同时又都需要对方的那一半桥</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/Thread%20DeadLock.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class DeadLockOccur &#123;</span><br><span class="line"></span><br><span class="line">  private Object sourceALock = new Object();</span><br><span class="line"></span><br><span class="line">  private Object sourceBLock = new Object();</span><br><span class="line"></span><br><span class="line">  public void needA_B() &#123;</span><br><span class="line"></span><br><span class="line">    synchronized (sourceALock) &#123;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        synchronized (sourceBLock) &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public void needB_A() &#123;</span><br><span class="line"></span><br><span class="line">    synchronized (sourceBLock) &#123;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        synchronized (sourceALock) &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DeadLockOccur deadLock = new DeadLockOccur();</span><br><span class="line">Thread ABT = new Thread(() -&gt; deadLock.needA_B());</span><br><span class="line">Thread BAT = new Thread(() -&gt; deadLock.needB_A());</span><br><span class="line"></span><br><span class="line">ABT.start();</span><br><span class="line">BAT.start();</span><br><span class="line"></span><br><span class="line">TimeUnit.SECONDS.sleep(2);</span><br><span class="line">System.out.println(&quot;ABT will be BLOCKED:&quot; + ABT.getState());</span><br><span class="line">System.out.println(&quot;BAT will be BLOCKED:&quot; + BAT.getState());</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">ABT will be BLOCKED:BLOCKED</span><br><span class="line">BAT will be BLOCKED:BLOCKED</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/Dead%20Lock.png" alt="image"></p>
<blockquote>
<p>将上例中所需资源一次性锁定可以解决死锁问题</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Object sourceABLock = new Object();</span><br><span class="line"></span><br><span class="line">  public void needA_B() &#123;</span><br><span class="line"></span><br><span class="line">    synchronized (sourceABLock) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void needB_A() &#123;</span><br><span class="line"></span><br><span class="line">    synchronized (sourceABLock) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Thread-Livelock"><a href="#Thread-Livelock" class="headerlink" title="Thread Livelock"></a>Thread Livelock</h2><p>线程的活锁指的是线程间都在“为对方考虑”，对方存活就把资源让给对方，这样互相谦让自己的资源，最后反而谁都得不到资源，活锁状态下的线程状态为RUNNABLE。有没有遇到过这种情况：你走在路上迎面来了个人，你躲让到一边想让对方通过，在这同时对方也躲让到了你躲让的这一边（你们又面对面了），如此反复</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/Thread%20LiveLock.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Worker &#123;</span><br><span class="line"></span><br><span class="line">  private String name;</span><br><span class="line">  private boolean active;</span><br><span class="line"></span><br><span class="line">  public Worker(String name, boolean active) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.active = active;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public synchronized void work(Worker otherWorker) &#123;</span><br><span class="line"></span><br><span class="line">    while (active) &#123;</span><br><span class="line"></span><br><span class="line">      if (otherWorker.active) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + &quot; handover the resource to &quot; + otherWorker.name);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(name + &quot; working on the resource&quot;);</span><br><span class="line">      active = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Worker w1 = new Worker(&quot;Work1&quot;, true);</span><br><span class="line">Worker w2 = new Worker(&quot;Work2&quot;, true);</span><br><span class="line"></span><br><span class="line">Thread w1T = new Thread(() -&gt; w1.work(w2));</span><br><span class="line">Thread w2T = new Thread(() -&gt; w2.work(w1));</span><br><span class="line"></span><br><span class="line">w1T.start();</span><br><span class="line">w2T.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">Work1 handover the resource to Work2</span><br><span class="line">Work2 handover the resource to Work1</span><br><span class="line">Work1 handover the resource to Work2</span><br><span class="line">Work2 handover the resource to Work1</span><br><span class="line">Work1 handover the resource to Work2</span><br><span class="line">Work2 handover the resource to Work1（无限执行下去）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>资源顺序的执行可以避免上述的活锁</p>
</blockquote>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> What is the weight of a soul? How much does a heart weigh? - Joan Clarke</p>
<p><a href="https://movie.douban.com/subject/10463953/">The Imitation Game</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Virtual Threads</title>
    <url>/2023/03/20/JavaVirtualThreads/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/52.png" class="full-image" />

<p>Java 开发人员在构建高并发应用的时候，大部分都会依赖多线程进行开发，而在 Java 中，线程的启动、调度、销毁是由操作系统来执行的，使用成本很高，我们认为这是一种重量级的线程。Java 虚拟线程被 JEP425 提议作为预览功能，并在 JDK 19 中发布，它是一种轻量级线程，不与操作系统线程直接绑定，使用虚拟线程能够大大减少编写、维护和观察高吞吐量并发程序的工作量</p>
<span id="more"></span>

<h1 id="Little’-Law"><a href="#Little’-Law" class="headerlink" title="Little’ Law"></a>Little’ Law</h1><p>利特尔定律可以根据系统中项目的平均等待时间和每单位到达系统中的平均项目数量，来确定排队系统中的项目个数，公式如下</p>
<p>$L &#x3D; λ * W$</p>
<ul>
<li>L：排队系统中的项目个数</li>
<li>λ：每单位到达系统中的平均项目数</li>
<li>W：项目的平均等待时间</li>
</ul>
<p>服务器应用的扩展性受制于 Little’ Law 的约束，利特尔定律对应到服务器中的性能指标包括：响应时间、吞吐量、并发任务数，即</p>
<p>$并发任务数 &#x3D; 吞吐量 * 响应时间$</p>
<p>假设系统的响应时间为 200ms，如果想要提高系统的吞吐量，公式给到的最直观的做法是提高系统的并发任务数，如何提高系统的并发数？最简单的做法是每个任务分配一个线程来处理。文章开始已经提到了 Java 中的线程是非常昂贵的，虽然池化线程可以降低线程创建、启动成本，但线程的数量仍然是有限的，并且每个线程的创建大概需要占用 2M 的内存，用于保存线程上下文，调用栈信息等</p>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>线程在处理 I&#x2F;O 等待的场景时会阻塞等待，在这期间的线程处于“无事可做”的状态，只有等到 I&#x2F;O 返回结果，线程才会继续处理。因此我们可以让阻塞等待中的线程去处理其他的任务，这样可以提升线程的利用率，从而提高系统的吞吐量。异步编程可以在 I&#x2F;O 等待的地方，释放这些阻塞的线程，从而去处理其他任务，当 I&#x2F;O 返回结果的时候，线程再去处理响应结果，但是异步编程会打破编码的顺序性，因为请求的任务线程和处理 I&#x2F;O 结果的线程，不属于同一个线程，这种编码风格使代码难于理解，并且线程栈信息的不连续，也导致代码难以调试，遇到问题更难定位</p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><p>通过使用 async&#x2F;await 语法方式，可以让编写的异步代码上下文有序，但它的结构与线程分开，需要通过其他构造形式将线程引入平台及依赖的工具包，所属生态适用需要花费很长的时间，与平台线程的绑定不够优雅</p>
<h1 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h1><p>虚拟线程是一种轻量级线程，它是一种用户模式线程，类似于 GoLang 中的协程。在早期的 Java 版本中，用户模式线程被称为 “green threads”，绿色线程出现在操作系统线程还未成熟阶段，那时候大多是单核系统，所有的绿色线程共享一个 OS Thread（ M:1 scheduling）。Java 中的线程实现被称为平台线程，它是对系统线程的一比一包装（1:1 scheduling），虚拟线程与平台线程的关系则为 M:N 映射，M是大量的虚拟线程，N是少量的平台线程。虚拟线程运行在平台线程之上，当执行的任务被阻塞，虚拟线程对象会被从线程栈中拷贝到堆中，释放平台线程，当任务阻塞完成，虚拟线程会重新装载到平台线程中，如下两种情况中，虚拟线程不会释放平台线程</p>
<ul>
<li>任务执行在 asynchronized 块或方法中</li>
<li>调用外部方法或 native 方法（JNI）</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/JVM/virtualthread.png" alt="imag"></p>
<p>由于虚拟线程是轻量级的，所以我们可以为每一个任务分配一个独立的虚拟线程，从而提高系统的吞吐量</p>
<h1 id="HTTP-SERVER-基准测试"><a href="#HTTP-SERVER-基准测试" class="headerlink" title="HTTP SERVER 基准测试"></a>HTTP SERVER 基准测试</h1><p>我们使用 OpenJDK11 自带的 HttpServer 来构建简单的 WEB 服务器功能，分别采用单线程（V1）、固定线程池（V2)、无界线程池（V3）和 虚拟线程（V4）的方式实现</p>
<h2 id="V1（单线程）"><a href="#V1（单线程）" class="headerlink" title="V1（单线程）"></a>V1（单线程）</h2><p>单线程模式下基本没有吞吐量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wrk -t100 -c200 -d30 http://localhost:18080/foo</span><br><span class="line"></span><br><span class="line">Running 30s test @ http://localhost:18080/foo</span><br><span class="line">  100 threads and 200 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.03s   554.29ms   1.84s    55.56%</span><br><span class="line">    Req/Sec     0.59      1.28     5.00     85.81%</span><br><span class="line">  148 requests in 30.08s, 13.88KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 139</span><br><span class="line">Requests/sec:      4.92</span><br><span class="line">Transfer/sec:     472.36B</span><br></pre></td></tr></table></figure>

<h2 id="V2（固定数量线程池）"><a href="#V2（固定数量线程池）" class="headerlink" title="V2（固定数量线程池）"></a>V2（固定数量线程池）</h2><p>使用固定数量线程池的情况下，吞吐量也不高，所以在IO密集型任务下，线程池设置为 CPU核心数 * 2 不靠谱</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">固定 10 个线程数</span></span><br><span class="line">wrk -t100 -c200 -d30 http://localhost:28080/foo</span><br><span class="line"></span><br><span class="line">Running 30s test @ http://localhost:28080/foo</span><br><span class="line">  100 threads and 200 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.03s   522.86ms   1.84s    55.56%</span><br><span class="line">    Req/Sec     0.70      1.37     6.00     88.58%</span><br><span class="line">  1480 requests in 30.07s, 138.75KB read</span><br><span class="line">  Socket errors: connect 0, read 29, write 0, timeout 1390</span><br><span class="line">Requests/sec:     49.22</span><br><span class="line">Transfer/sec:      4.61KB</span><br></pre></td></tr></table></figure>

<h2 id="V3（无界线程池）"><a href="#V3（无界线程池）" class="headerlink" title="V3（无界线程池）"></a>V3（无界线程池）</h2><p>每个请求一个线程，这种情况下的吞吐量比 V1、V2 好多了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wrk -t100 -c200 -d30 http://localhost:38080/foo</span><br><span class="line"></span><br><span class="line">Running 30s test @ http://localhost:38080/foo</span><br><span class="line">  100 threads and 200 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   220.58ms   19.78ms 279.31ms   66.81%</span><br><span class="line">    Req/Sec     8.80      1.66    20.00     85.00%</span><br><span class="line">  27116 requests in 30.11s, 2.49MB read</span><br><span class="line">  Socket errors: connect 0, read 33, write 0, timeout 0</span><br><span class="line">Requests/sec:    900.67</span><br><span class="line">Transfer/sec:     84.54KB</span><br></pre></td></tr></table></figure>

<p>我们来试试用更强的压力来进行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wrk -t2000 -c2000 -d30 http://localhost:38080/foo</span><br><span class="line">Running 30s test @ http://localhost:38080/foo</span><br><span class="line">  2000 threads and 2000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   254.27ms  175.67ms   1.70s    95.29%</span><br><span class="line">    Req/Sec     4.02      1.14    10.00     93.65%</span><br><span class="line">  98947 requests in 30.11s, 9.06MB read</span><br><span class="line">  Socket errors: connect 0, read 17267, write 1, timeout 709</span><br><span class="line">Requests/sec:   3286.10</span><br><span class="line">Transfer/sec:    308.09KB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU、内存使用情况</span></span><br><span class="line">CPU %     MEM USAGE / LIMIT   MEM %</span><br><span class="line">32.60%    340.4MiB / 512MiB   66.48%</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="V4（虚拟线程）"><a href="#V4（虚拟线程）" class="headerlink" title="V4（虚拟线程）"></a>V4（虚拟线程）</h2><p>我们来看看虚拟线程表现如何</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wrk -t2000 -c2000 -d30 http://localhost:48080/foo</span><br><span class="line">Running 30s test @ http://localhost:48080/foo</span><br><span class="line">  2000 threads and 2000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   237.31ms  121.62ms   1.48s    96.29%</span><br><span class="line">    Req/Sec     4.10      1.03    10.00     80.37%</span><br><span class="line">  143827 requests in 30.11s, 13.17MB read</span><br><span class="line">  Socket errors: connect 0, read 31992, write 26, timeout 0</span><br><span class="line">Requests/sec:   4776.83</span><br><span class="line">Transfer/sec:    447.83KB</span><br><span class="line"></span><br><span class="line">CPU %     MEM USAGE / LIMIT   MEM %</span><br><span class="line">34.10%    161.8MiB / 512MiB   31.61%</span><br></pre></td></tr></table></figure>
<p>测试数据显示吞吐量、内存使用情况都优于 V3 版本</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://openjdk.org/jeps/436">JEP 436</a></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="获取-JVM-环境的堆和栈的大小"><a href="#获取-JVM-环境的堆和栈的大小" class="headerlink" title="获取 JVM 环境的堆和栈的大小"></a>获取 JVM 环境的堆和栈的大小</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | grep -Ei &quot;maxheapsize|maxram|stacksize&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MaxHeapSize = 134217728 <span class="comment"># 最大堆内存 134M</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MaxRAMPercentage = 25.000000 <span class="comment"># 最大堆占 RAM 内存大小的 25%</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ThreadStackSize = 2048 <span class="comment"># 栈大小 2M</span></span></span><br></pre></td></tr></table></figure>

<h2 id="获取容器CPU、内存、IO等使用情况"><a href="#获取容器CPU、内存、IO等使用情况" class="headerlink" title="获取容器CPU、内存、IO等使用情况"></a>获取容器CPU、内存、IO等使用情况</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stats &#123;container_id&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取-堆内存、GC-情况"><a href="#获取-堆内存、GC-情况" class="headerlink" title="获取 堆内存、GC 情况"></a>获取 堆内存、GC 情况</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat -gcutil &#123;pid&#125; &#123;interval&#125; &#123;count&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试用例源码"><a href="#测试用例源码" class="headerlink" title="测试用例源码"></a>测试用例源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HttpServer</span> <span class="variable">server</span> <span class="operator">=</span> HttpServer.create(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>), <span class="number">0</span>);</span><br><span class="line">server.createContext(<span class="string">&quot;/foo&quot;</span>, (<span class="keyword">var</span> t) -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> t.getResponseBody()) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        <span class="type">byte</span>[] response = <span class="string">&quot;Hello World!&quot;</span>.getBytes();</span><br><span class="line">        t.sendResponseHeaders(<span class="number">200</span>, response.length);</span><br><span class="line">        os.write(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// server.setExecutor(Executors.newFixedThreadPool(1)); // V1</span></span><br><span class="line"><span class="comment">// server.setExecutor(Executors.newFixedThreadPool(10)); // V2</span></span><br><span class="line"><span class="comment">// server.setExecutor(Executors.newCachedThreadPool()); // V3</span></span><br><span class="line">server.setExecutor(Executors.newVirtualThreadPerTaskExecutor()); <span class="comment">// V4</span></span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>

<h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version: &#x27;3.4&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  webserver_v1:</span><br><span class="line">    build:</span><br><span class="line">        context: .</span><br><span class="line">        dockerfile: v1.Dockerfile</span><br><span class="line">    ports:</span><br><span class="line">      - 18080:8080  </span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#x27;2&#x27;</span><br><span class="line">          memory: 512M</span><br><span class="line"></span><br><span class="line">  webserver_v2:</span><br><span class="line">    build:</span><br><span class="line">        context: .</span><br><span class="line">        dockerfile: v2.Dockerfile</span><br><span class="line">    ports:</span><br><span class="line">      - 28080:8080  </span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#x27;2&#x27;</span><br><span class="line">          memory: 512M          </span><br><span class="line"></span><br><span class="line">  webserver_v3:</span><br><span class="line">    build:</span><br><span class="line">        context: .</span><br><span class="line">        dockerfile: v3.Dockerfile</span><br><span class="line">    ports:</span><br><span class="line">      - 38080:8080      </span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#x27;2&#x27;</span><br><span class="line">          memory: 512M          </span><br><span class="line"></span><br><span class="line">  webserver_v4:</span><br><span class="line">    build:</span><br><span class="line">        context: .</span><br><span class="line">        dockerfile: v4.Dockerfile</span><br><span class="line">    ports:</span><br><span class="line">      - 48080:8080      </span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#x27;2&#x27;</span><br><span class="line">          memory: 512M</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Database Connectivity</title>
    <url>/2023/11/05/Jdbc/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/11.png" class="full-image">

<p>JDBC 是 Java Database Connectivity 的缩写，是 Java 应用程序的 API，用于访问数据库。1997年2月19日发布的 JDK 1.1 版本中就已经包含了 JDBC 的实现，从 JDBC 3.0 版本开始，JDBC 在 JCP (Java Community Process) 机制下进行迭代开发。在 JSR 54 中有关于 JDBC 简短的底层技术描述：JDBC is a Java API for executing SQL statements</p>
<span id="more"></span>

<h1 id="JDBC-历史版本"><a href="#JDBC-历史版本" class="headerlink" title="JDBC 历史版本"></a>JDBC 历史版本</h1><p>JDBC 由 Oracle Corporation 开发，发布至今已经有 26 年的历史，代码分布在 java.sql 和 javax.sql 包中。目前 JDBC 的最新版本是 4.3，发布于 2017 年。下面是 JDBC 发布历史时间表，以及对应的 JDK 实现</p>
<table>
<thead>
<tr>
<th>Year</th>
<th>JDBC Version</th>
<th>JSR</th>
<th>JDK Version</th>
</tr>
</thead>
<tbody><tr>
<td>2017</td>
<td>JDBC 4.3</td>
<td>JSR 221 - release 3</td>
<td>Java SE 9</td>
</tr>
<tr>
<td>2014</td>
<td>JDBC 4.2</td>
<td>JSR 221 - release 2</td>
<td>Java SE 8</td>
</tr>
<tr>
<td>2011</td>
<td>JDBC 4.1</td>
<td>JSR 221 - release 1</td>
<td>Java SE 7</td>
</tr>
<tr>
<td>2006</td>
<td>JDBC 4.0</td>
<td>JSR 221</td>
<td>Java SE 6</td>
</tr>
<tr>
<td>2004</td>
<td>JDBC RowSet Implementrations</td>
<td>JSR 114</td>
<td>J2SE 1.5</td>
</tr>
<tr>
<td>2000</td>
<td>JDBC 3.0</td>
<td>JSR 54</td>
<td>J2SE 1.4</td>
</tr>
<tr>
<td>1998</td>
<td>JDBC 2.x</td>
<td>-</td>
<td>J2SE 1.2 &#x2F; J2SE 1.3</td>
</tr>
<tr>
<td>1997</td>
<td>JDBC 1.2</td>
<td>-</td>
<td>JDK 1.1</td>
</tr>
</tbody></table>
<h1 id="JDBC-版本特性"><a href="#JDBC-版本特性" class="headerlink" title="JDBC 版本特性"></a>JDBC 版本特性</h1><p>JDBC 3.0 将不同的 JDBC 2.x 版本规范合并，并开始在 JSR 下迭代开发，JDBC 3.0 主要目标是技术功能完善，JDBC 4.0 主要目标是提供更好的开发体验</p>
<h2 id="JDBC-驱动"><a href="#JDBC-驱动" class="headerlink" title="JDBC 驱动"></a>JDBC 驱动</h2><p>JDBC 4.0 支持 自动加载驱动，3.0 需要指定驱动加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.0</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:13306/mydb?user=root&amp;password=123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.0</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:13306/mydb?user=root&amp;password=123456&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="JDBC-4-x-新特性"><a href="#JDBC-4-x-新特性" class="headerlink" title="JDBC 4.x 新特性"></a>JDBC 4.x 新特性</h2><table>
<thead>
<tr>
<th>JDBC Version</th>
<th>New Feature</th>
</tr>
</thead>
<tbody><tr>
<td>4.0</td>
<td>支持驱动自动加载</td>
</tr>
<tr>
<td>4.1</td>
<td>支持 try-with-resource</td>
</tr>
<tr>
<td>4.2</td>
<td>支持 REF CURSOR</td>
</tr>
<tr>
<td>4.3</td>
<td>支持 Sharding</td>
</tr>
</tbody></table>
<h1 id="JDBC-驱动类型"><a href="#JDBC-驱动类型" class="headerlink" title="JDBC 驱动类型"></a>JDBC 驱动类型</h1><p>JDBC 驱动类型主要有以下四种</p>
<table>
<thead>
<tr>
<th>JDBC Driver</th>
<th>类别</th>
</tr>
</thead>
<tbody><tr>
<td>Type 1</td>
<td>JDBC-ODBC bridge</td>
</tr>
<tr>
<td>Type 2</td>
<td>Native-API driver</td>
</tr>
<tr>
<td>Type 3</td>
<td>Middleware driver</td>
</tr>
<tr>
<td>Type 4</td>
<td>Database-Protocol driver</td>
</tr>
</tbody></table>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/blogs/JDBC/jdbc_types.png" alt="image"></p>
<p>可以发现 Type 4 类型的驱动性能应该是最好的，mysql-connector-j 的驱动类型属于 Type 4 driver</p>
<h1 id="JDBC-核心-API"><a href="#JDBC-核心-API" class="headerlink" title="JDBC 核心 API"></a>JDBC 核心 API</h1><ul>
<li>DataSource 代表实际连接的数据库</li>
<li>Connection 数据库连接可以通过 DataSource 对象获取，用于执行 Statement 和 获取 ResultSet</li>
<li>Statement 可以通过 Connection 对象获取，用于执行 SQL 语句</li>
<li>PrepareStatement 可以预编译 SQL 语句，防止 SQL 注入</li>
<li>ResultSet 代表数据执行的查询结果</li>
</ul>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/blogs/JDBC/jdbc_api.png" alt="image"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单代码事例</span></span><br><span class="line"><span class="type">MysqlDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MysqlDataSource</span>();</span><br><span class="line">dataSource.setPort(<span class="number">13306</span>);</span><br><span class="line">dataSource.setDatabaseName(<span class="string">&quot;mydb&quot;</span>);</span><br><span class="line">dataSource.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">dataSource.setPassword(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO test VALUES (&#x27;hello&#x27;)&quot;</span>;</span><br><span class="line">stmt.executeUpdate(sql);</span><br></pre></td></tr></table></figure>
<h1 id="Vendor-Driver"><a href="#Vendor-Driver" class="headerlink" title="Vendor Driver"></a>Vendor Driver</h1><p>主流数据库几乎都提供了对应的 JDBC Driver，比如 Hive 的 hive-jdbc，Mysql 的 mysql-connector-j，Clickhouse 的 clickhouse-jdbc 等。JDBC 的设计完全符合 OCP、DIP 原则，扩展数据源非常方便</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/blogs/JDBC/vendor_driver.png" alt="image"></p>
<p>如果项目中有换存储方案的需求，理论上只需要更换对应的 jdbc driver 就可以了</p>
<h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><p>虽然 JDBC 提供了完整的访问数据库能力，但直接使用 JDBC 操作数据库，过于复杂，并且会增加过多的样板代码。在真实的项目开发中，我们会使用数据库连接池 Hikari 来提高数据库操作的吞吐量，并引入持久层框架来降低代码复杂度，比如使用：Spring JDBC Template 、MyBatis、Hibernate 等，并且基于不同场景可以选择使用不同的持久层框架，比如可以使用 JDBC Template 来进行大数据集记录的批量新增、更新（需要配置rewriteBatchedStatements&#x3D;true）</p>
<h2 id="HikariCP"><a href="#HikariCP" class="headerlink" title="HikariCP"></a>HikariCP</h2><p>HikariCP 是一款高性能的 JDBC 连接池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依赖包</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.0</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接池</span></span><br><span class="line"><span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">config.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:13306/mydb?user=root&amp;password=123456&quot;</span>);</span><br><span class="line"><span class="type">HikariDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br></pre></td></tr></table></figure>

<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>MyBatis 是一款流行的 ORM 框架，可以通过 Mapper 接口绑定配置 SQL 进行数据库访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依赖包</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.5</span><span class="number">.11</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 SqlSessionFactory</span></span><br><span class="line"><span class="type">SqlSessionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">factoryBean.setDataSource(dataSource());</span><br><span class="line"><span class="keyword">return</span> factoryBean.getObject();</span><br></pre></td></tr></table></figure>

<h2 id="JDBC-Template"><a href="#JDBC-Template" class="headerlink" title="JDBC Template"></a>JDBC Template</h2><p>JDBC Template 由 Spring 提供，可以简化 JDBC 操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依赖包</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 JDBC Template</span></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource)；</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JSR</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JSR</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes Cluster With Docker</title>
    <url>/2023/09/09/K8s_Install_Offline/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/60.png" class="full-image">

<p>Kubernetes 是一款开源的容器编排系统，用于自动部署、扩容和管理容器应用，因为 Kubernetes 的首字母和尾字母之间有8个字母，所以也被简称为 K8s。K8s 在 v1.24 版本之前默认集成了 Docker Engine 作为 K8s 的容器运行时，而在 v1.24 及之后的版本中使用 containerd 作为 K8s 的容器运行时，本篇文章记录如何在 v1.24之后的 K8s 版本中使用 Docker Engine 作为容器运行时以及如何离线安装 K8s 集群</p>
<span id="more"></span>

<h1 id="机器情况"><a href="#机器情况" class="headerlink" title="机器情况"></a>机器情况</h1><table>
<thead>
<tr>
<th align="left"></th>
<th align="right">server 1</th>
<th align="right">server 2</th>
<th align="right">server 3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">是否有网</td>
<td align="right">no</td>
<td align="right">no</td>
<td align="right">yes</td>
</tr>
<tr>
<td align="left">主机名</td>
<td align="right">master-01</td>
<td align="right">worker-01</td>
<td align="right">-</td>
</tr>
<tr>
<td align="left">IP</td>
<td align="right">192.168.1.20</td>
<td align="right">192.168.1.21</td>
<td align="right">-</td>
</tr>
<tr>
<td align="left">操作系统</td>
<td align="right">centos:7.6.1810</td>
<td align="right">centos:7.6.1810</td>
<td align="right">macos</td>
</tr>
<tr>
<td align="left">CPU架构</td>
<td align="right">x86</td>
<td align="right">x86</td>
<td align="right">arm</td>
</tr>
</tbody></table>
<p>server 1 和 server 2 分别为 K8s 的 master 节点 和 worker 节点，server 3 用于提供安装 K8s 集群所需软件包</p>
<h1 id="Docker-CE"><a href="#Docker-CE" class="headerlink" title="Docker CE"></a>Docker CE</h1><p>在 server 3 的 centos 容器中下载 Docker CE 安装包</p>
<h2 id="On-server-3"><a href="#On-server-3" class="headerlink" title="On server 3"></a>On server 3</h2><p>server 3 安装了 Docker Desktop</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行 centos:7.6.1810</span></span><br><span class="line">docker run -itd --name centos --platform=linux/amd64 centos:7.6.1810</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器内部</span></span><br><span class="line">docker exec -it centos /bin/sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加 docker-ce yum 源</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 docker-ce 最新的5个版本</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r | head -5</span><br><span class="line"></span><br><span class="line">docker-ce.x86_64            3:24.0.6-1.el7                      docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:24.0.5-1.el7                      docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:24.0.4-1.el7                      docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:24.0.3-1.el7                      docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:24.0.2-1.el7                      docker-ce-stable</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载 24.0.6-1.el7 版本的 docker</span></span><br><span class="line">yum install --downloadonly --downloaddir=/root/docker docker-ce-24.0.6-1.el7.x86_64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩 docker-ce rpm 安装包</span></span><br><span class="line">tar -zcvf docker.tar.gz docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝 docker.tar.gz 至宿主机</span></span><br><span class="line">docker cp centos:/root/docker.tar.gz downloads</span><br></pre></td></tr></table></figure>

<h2 id="On-server-1"><a href="#On-server-1" class="headerlink" title="On server 1"></a>On server 1</h2><p>server 2 和 server 1 进行同样操作，拷贝 docker.tar.gz 至服务器并解压缩</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压缩</span></span><br><span class="line">tar -zxvf docker.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 docker</span></span><br><span class="line">rpm -ivh --replacefiles --replacepkgs docker/*.rpm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 docker 并设置开启启动</span></span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置 docker cgroupdriver 为 systemd</span></span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; EOF </span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">后续使用 kubeadm 搭建的 k8s 集群，默认使用 systemd 作为 cgroupdriver，这里保持一致</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><p>在 server 3 的 centos 容器中下载 Kubernetes 所需组件</p>
<blockquote>
<ol>
<li>kubectl: k8s 中的命令行工具</li>
<li>kubelet: 在集群中 Worker Node (Node) 上运行的代理，确保容器在 Pod 中运行</li>
<li>kubeadm: 用于构建 k8s 集群</li>
<li>kube-proxy: 在集群中 Worker Node (Node) 上运行的网络代理，确保从集群内&#x2F;外可访问 Pod</li>
<li>kube-apiserver: 属于集群中 Master Node (Control Plane) 的 front end</li>
<li>etcd: 在集群中 Master Node (Control Plane) 上运行的一致性高可用 key&#x2F;value 存储，保存所有的集群数据</li>
<li>kube-scheduler: 用于监听新创建的未分配 Worker Node (Node) 的 Pod，并将其调度到合适的 Worker Node (Node) 中，运行在集群中的 Master Node (Control Plane) 上</li>
<li>kube-controller-manager:  运行在集群中的 Master Node (Control Plane) 上，包括 Deployment Controller &#x2F; Node controller &#x2F; Replica controller &#x2F; EndpointSlice controller &#x2F; ServiceAccount controller 等</li>
<li>pause: 也称为 infra 容器，在 Pod 中作为 Linux 命名空间共享的基础，并且为 Pod 提供 1 号进程</li>
<li>coredns: 选择 coredns 为 k8s 集群提供 DNS 服务</li>
<li>flannel: 选择 flannel 作为 CNI（Container Network Interface）的实现，完成跨主机容器通信</li>
<li>cri-dockerd: docker engine wrapper 以符合 k8s CRI（Container Runtime Interface） 标准</li>
</ol>
</blockquote>
<h2 id="On-server-3-1"><a href="#On-server-3-1" class="headerlink" title="On server 3"></a>On server 3</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器内部</span></span><br><span class="line">docker exec -it centos /bin/sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加 k8s yum 源</span></span><br><span class="line">cat &gt;&gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缓存安装提速</span></span><br><span class="line">yum makecache fast</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载 1.28.1-0.x86_64 版本的 第 1~3 组件</span></span><br><span class="line">yum install --downloadonly --downloaddir=/root/k8s kubectl-1.28.1-0.x86_64 kubeadm-1.28.1-0.x86_64 kubelet-1.28.1-0.x86_64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出 k8s 依赖的第 4～10 docker image 组件</span></span><br><span class="line">docker pull --platform=linux/amd64 registry.k8s.io/pause:3.9</span><br><span class="line">docker save registry.k8s.io/pause:3.9 &gt; /root/k8s/k8s-images/pause.tar</span><br><span class="line"></span><br><span class="line">docker pull --platform=linux/amd64 registry.k8s.io/kube-apiserver:v1.28.1</span><br><span class="line">docker save registry.k8s.io/kube-apiserver:v1.28.1 &gt; /root/k8s/k8s-images/kube-apiserver.tar</span><br><span class="line"></span><br><span class="line">docker pull --platform=linux/amd64 registry.k8s.io/kube-controller-manager:v1.28.1</span><br><span class="line">docker save registry.k8s.io/kube-controller-manager:v1.28.1 &gt; /root/k8s/k8s-images/kube-controller-manager.tar</span><br><span class="line"></span><br><span class="line">docker pull --platform=linux/amd64 registry.k8s.io/kube-scheduler:v1.28.1</span><br><span class="line">docker save registry.k8s.io/kube-scheduler:v1.28.1 &gt; /root/k8s/k8s-images/kube-scheduler.tar</span><br><span class="line"></span><br><span class="line">docker pull --platform=linux/amd64 registry.k8s.io/kube-proxy:v1.28.1</span><br><span class="line">docker save registry.k8s.io/kube-proxy:v1.28.1 &gt; /root/k8s/k8s-images/kube-proxy.tar</span><br><span class="line"></span><br><span class="line">docker pull --platform=linux/amd64 registry.k8s.io/etcd:3.5.9-0</span><br><span class="line">docker save registry.k8s.io/etcd:3.5.9-0 &gt; /root/k8s/k8s-images/etcd.tar</span><br><span class="line"></span><br><span class="line">docker pull --platform=linux/amd64 registry.k8s.io/coredns/coredns:v1.10.1</span><br><span class="line">docker save registry.k8s.io/coredns/coredns:v1.10.1 &gt; /root/k8s/k8s-images/coredns.tar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载 k8s 依赖的 kube-flannel.yml</span></span><br><span class="line">wget -P /root/k8s/k8s-flannel https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出 flannel 依赖的 docker image 组件</span></span><br><span class="line">cat kube-flannel.yml | grep image</span><br><span class="line">      image: docker.io/flannel/flannel-cni-plugin:v1.2.0</span><br><span class="line">      image: docker.io/flannel/flannel:v0.22.2</span><br><span class="line">      image: docker.io/flannel/flannel:v0.22.2</span><br><span class="line"></span><br><span class="line">docker pull --platform=linux/amd64 docker.io/flannel/flannel:v0.22.2</span><br><span class="line">docker save docker.io/flannel/flannel:v0.22.2 &gt; /root/k8s/k8s-flannel/flannel.tar</span><br><span class="line"></span><br><span class="line">docker pull --platform=linux/amd64 docker.io/flannel/flannel-cni-plugin:v1.2.0</span><br><span class="line">docker save docker.io/flannel/flannel-cni-plugin:v1.2.0 &gt; /root/k8s/k8s-flannel/flannel-cni-plugin.tar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载 v0.3.4 版本的 cri-dockerd</span></span><br><span class="line">wget -P /root/k8s/k8s-cri-dockerd https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.4/cri-dockerd-0.3.4-3.el7.x86_64.rpm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩 k8s 安装依赖</span></span><br><span class="line">tar -zcvf k8s.tar.gz k8s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝 k8s.tar.gz 至宿主机</span></span><br><span class="line">docker cp centos:/root/k8s.tar.gz downloads</span><br></pre></td></tr></table></figure>
<h2 id="On-server-1-1"><a href="#On-server-1-1" class="headerlink" title="On server 1"></a>On server 1</h2><p>安装 k8s 的一些配置操作，server 2 和 server 1 进行同样操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭 selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭 swap</span></span><br><span class="line">swapoff -a</span><br><span class="line">sed -ri &#x27;s/.swap./#&amp;/&#x27; /etc/fsta</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加 hosts</span></span><br><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">192.168.1.20 master-01</span><br><span class="line">192.168.1.21 worker-01 </span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网络配置</span></span><br><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载配置</span></span><br><span class="line">modprobe br_netfilter</span><br><span class="line">sysctl --system</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝 k8s.tar.gz 至服务器并解压缩</span></span><br><span class="line">tar -zxvf k8s.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 k8s</span></span><br><span class="line">rpm -ivh --replacefiles --replacepkgs k8s/*.rpm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 kubelet 开机启动</span></span><br><span class="line">systemctl enable kubelet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启 kubectl 命令补全</span></span><br><span class="line">source &lt;(kubectl completion bash)</span><br><span class="line">kubectl completion bash &gt; /etc/bash_completion.d/kubectl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">版本查看</span></span><br><span class="line">kubectl version</span><br><span class="line">Client Version: v1.28.1</span><br><span class="line">-----------------------</span><br><span class="line">kubelet --version</span><br><span class="line">Kubernetes v1.28.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入 k8s 依赖镜像</span></span><br><span class="line">docker load &lt; k8s/k8s-images/pause.tar</span><br><span class="line">docker load &lt; k8s/k8s-images/kube-apiserver.tar</span><br><span class="line">docker load &lt; k8s/k8s-images/kube-controller-manager.tar</span><br><span class="line">docker load &lt; k8s/k8s-images/kube-scheduler.tar</span><br><span class="line">docker load &lt; k8s/k8s-images/kube-proxy.tar</span><br><span class="line">docker load &lt; k8s/k8s-images/etcd.tar</span><br><span class="line">docker load &lt; k8s/k8s-images/coredns.tar</span><br><span class="line">docker load &lt; k8s/k8s-flannel/flannel-cni-plugin.tar</span><br><span class="line">docker laod &lt; k8s/k8s-flannel/flannel.tar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 cri-dockerd</span></span><br><span class="line">rpm -ivh --replacefiles --replacepkgs k8s/k8s-cri-dockerd/*.rpm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 cri-dockerd</span></span><br><span class="line">systemctl enable cri-docker.socket</span><br><span class="line">systemctl start cri-docker.socket cri-docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 cri-docker 状况</span></span><br><span class="line">systemctl status cri-docker</span><br><span class="line">● cri-docker.service - CRI Interface for Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/cri-docker.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Wed 2023-09-06 20:48:16 CST; 4min 8s ago</span><br><span class="line">     Docs: https://docs.mirantis.com</span><br><span class="line"> Main PID: 236691 (cri-dockerd)</span><br><span class="line">    Tasks: 13</span><br><span class="line">   Memory: 14.1M</span><br><span class="line">   CGroup: /system.slice/cri-docker.service</span><br><span class="line">           └─236691 /usr/bin/cri-dockerd --container-runtime-endpoint fd://</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 cri-docker.service 中的 ExecStart</span></span><br><span class="line">ExecStart=/usr/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --pod-infra-container-image=registry.k8s.io/pause:3.9</span><br><span class="line"></span><br><span class="line">1. --network-plugin: 更改网络插件使用 cni, 因为默认的 kubenet 没有实现跨 Node 的网络访问</span><br><span class="line">2. --pod-infra-container-image: 更改 infra 容器景象版本及 pause 版本</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 cri-docker</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemclt restart cri-docker</span><br></pre></td></tr></table></figure>

<h1 id="K8s-集群配置"><a href="#K8s-集群配置" class="headerlink" title="K8s 集群配置"></a>K8s 集群配置</h1><p>使用 kubeadm 进行集群创建</p>
<h2 id="On-server-1-2"><a href="#On-server-1-2" class="headerlink" title="On server 1"></a>On server 1</h2><p>仅在 server 1 上进行如下操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化 master node</span></span><br><span class="line">kubeadm init --kubernetes-version=v1.28.1 --apiserver-advertise-address=192.168.1.20 --pod-network-cidr=10.10.0.0/16 --cri-socket=unix:///var/run/cri-dockerd.sock</span><br><span class="line"></span><br><span class="line">1. --apiserver-advertise-address: 指定 server 1 ip</span><br><span class="line">2. --pod-network-cidr: 指定 Pod 网络段</span><br><span class="line">3. --cri-socket: 指定使用 docker engine 作为 k8s container runtime</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按提示进行配置</span></span><br><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 Node Join Token</span></span><br><span class="line">kubeadm token create --print-join-command</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 kube-flannel.yml</span> </span><br><span class="line">  net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Network&quot;: &quot;10.10.0.0/16&quot;, // 与 --pod-network-cidr 设置一致</span><br><span class="line">      &quot;Backend&quot;: &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署 kube-flannel.yml</span></span><br><span class="line">kubectl apply -f kube-flannel.yml     </span><br></pre></td></tr></table></figure>

<h2 id="On-server-2"><a href="#On-server-2" class="headerlink" title="On server 2"></a>On server 2</h2><p>仅在 server 2 上进行如下操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Worker Node 加入集群</span></span><br><span class="line">kubeadm join 192.168.1.20:6443 --token mpyekp.e32b91pvl2itcld8 --discovery-token-ca-cert-hash sha256:932b2c4bda8597bfe2daf75c7dde53ae1bb5e55b488beaf628a18526d3a1c334 --cri-socket=unix:///var/run/cri-dockerd.sock</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置 crictl</span> </span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt; EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">timeout: 10</span><br><span class="line">debug: false</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka On Docker</title>
    <url>/2018/10/13/KafkaOnDocker/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/19.png" class="full-image" />

<p>记录在Docker上创建单broker的Kafka过程</p>
<h1 id="安装运行Kafka"><a href="#安装运行Kafka" class="headerlink" title="安装运行Kafka"></a>安装运行Kafka</h1><h2 id="创建bridge网络"><a href="#创建bridge网络" class="headerlink" title="创建bridge网络"></a>创建bridge网络</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker  network create -d  bridge --subnet=10.0.0.0/24 kafka_net</span><br></pre></td></tr></table></figure>

<h2 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --restart=always -d -ti --name zookeeperService --network=kafka_net -p 2181:2181 -v /home/core/zookeeper/conf:/conf -v /home/core/zookeeper/data:/data -v /home/core/zookeeper/dataLog:/dataLog zookeeper</span><br></pre></td></tr></table></figure>
<h3 id="验证zookeeper是否启动正常"><a href="#验证zookeeper是否启动正常" class="headerlink" title="验证zookeeper是否启动正常"></a>验证zookeeper是否启动正常</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --rm -it --network=host zookeeper  zkCli.sh -server localhost:2181  </span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="启动Kafka"><a href="#启动Kafka" class="headerlink" title="启动Kafka"></a>启动Kafka</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name kafkaService --network=kafka_net -p 9092:9092 -e KAFKA_ADVERTISED_HOST_NAME=localhost -e KAFKA_ZOOKEEPER_CONNECT=zookeeperService:2181 -d wurstmeister/kafka  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行上述命令后发现启动日志报错，错误信息显示系统内存不总</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000bad30000, 986513408, 0) failed; error=&#x27;Cannot allocate memory&#x27; (errno=12)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看kafka启动脚本，发现默认配置的JVM堆内存为1G，本机空闲内存只有67M，系统并未开启swap区</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free -mh</span><br><span class="line">total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          988Mi       682Mi        67Mi       200Mi       238Mi        17Mi</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="开启swap区"><a href="#开启swap区" class="headerlink" title="开启swap区"></a>开启swap区</h3><h4 id="使用文件添加swap区"><a href="#使用文件添加swap区" class="headerlink" title="使用文件添加swap区"></a>使用文件添加swap区</h4><blockquote>
<ol>
<li>dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;swap-file bs&#x3D;1M count&#x3D;1024</li>
<li>chmod 0600 &#x2F;swap-file</li>
<li>mkswap &#x2F;swap-file 格式化交换分区</li>
<li>swapon &#x2F;swap-file 启动交换分区</li>
<li>swapon -s 查看交换分区</li>
</ol>
</blockquote>
<h4 id="Swappiness"><a href="#Swappiness" class="headerlink" title="Swappiness"></a>Swappiness</h4><blockquote>
<p>Swappiness的取值范围为0～100，通过修改&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness文件的值来设置<br>vm.swappiness &#x3D; 0，系统尽可能的使用物理内存，在避免用尽之前才进行swap操作<br>vm.swappiness &#x3D; 100，系统主动的进行swap操作</p>
</blockquote>
<blockquote>
<p>再次启动Kafka，并覆盖JVM对内存参数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run  -d -ti --name kafkaService --network=kafka_net -p 9092:9092 -e KAFKA_ADVERTISED_HOST_NAME=localhost -e KAFKA_ZOOKEEPER_CONNECT=zookeeperService:2181 -e KAFKA_HEAP_OPTS=&quot;-Xmx200M -Xms200M&quot; wurstmeister/kafka</span><br></pre></td></tr></table></figure>

<h3 id="验证Kafka是否启动成功"><a href="#验证Kafka是否启动成功" class="headerlink" title="验证Kafka是否启动成功"></a>验证Kafka是否启动成功</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Producer:</span><br><span class="line">docker run --rm -it --network=host ryane/kafkacat -b localhost:9092 -t myTopic -P</span><br><span class="line">Hello World !</span><br><span class="line"></span><br><span class="line">Consumer:</span><br><span class="line">docker run --rm -it --network=host ryane/kafkacat -b localhost:9092 -t myTopic -C  </span><br><span class="line">% Reached end of topic myTopicTest [0] at offset 0</span><br><span class="line">Hello World !</span><br><span class="line">% Reached end of topic myTopicTest [0] at offset 1</span><br></pre></td></tr></table></figure>

<h3 id="swap区的活动"><a href="#swap区的活动" class="headerlink" title="swap区的活动"></a>swap区的活动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmstat 1</span><br><span class="line"></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line">19  5 355328  61092    160 149916   95   35   482    54   29   45  1  1 97  1  0</span><br><span class="line"> 9 10 355840  60640    176 148624 2784 1060 112192  1212 2420 5863  2 43  0 56  0</span><br><span class="line">16  4 355328  59268    176 149840 2048  612 112268   680 2163 5319  2 32  0 66  0</span><br><span class="line">14 20 355840  58216    168 151556 2876 1360 150376  1580 2960 6953  1 50  0 49  0</span><br><span class="line">10  9 355584  57344    168 152156 1780  728 151144   772 2318 5504  1 42  0 57  0</span><br><span class="line">19  0 355328  57852    200 150296 3528  676 114896   888 2900 5972  1 63  0 36  0</span><br><span class="line">17 15 355584  54752    148 154576 2660 1216 165028  1528 2636 5672  1 55  0 44  0</span><br><span class="line">11  4 355584  54008    188 155416 2896 1268 111956  1336 3175 6713 13 56  0 31  0</span><br><span class="line">20 12 355840  58968    192 150796 2176  992 136236  1244 2453 6017  1 36  0 64  0</span><br><span class="line">27  2 355328  55616    200 152832 3192  832 108232   992 2393 5416  2 39  0 60  0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然Kafka启动成功了，但是频繁的swap区交换导致系统响应变慢</p>
</blockquote>
<h3 id="查看Kafka对swap区的使用"><a href="#查看Kafka对swap区的使用" class="headerlink" title="查看Kafka对swap区的使用"></a>查看Kafka对swap区的使用</h3><blockquote>
<ol>
<li>获取容器应用在宿主机中的PID<br> cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;docker&#x2F;{container_id}&#x2F;cgroup.procs </li>
<li>获取进程地址信息<br> sudo cat &#x2F;proc&#x2F;{PID}&#x2F;smaps | head -n20</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本例Kafka的PID为10250：</span><br><span class="line"></span><br><span class="line">sudo cat /proc/10250/smaps | head -n20</span><br><span class="line"></span><br><span class="line">f3800000-100400000 rw-p 00000000 00:00 0</span><br><span class="line">Size:             208896 kB</span><br><span class="line">KernelPageSize:        4 kB</span><br><span class="line">MMUPageSize:           4 kB</span><br><span class="line">Rss:               76048 kB</span><br><span class="line">Pss:               76048 kB</span><br><span class="line">Shared_Clean:          0 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:        68 kB</span><br><span class="line">Private_Dirty:     75980 kB</span><br><span class="line">Referenced:        56888 kB</span><br><span class="line">Anonymous:         76048 kB</span><br><span class="line">LazyFree:              0 kB</span><br><span class="line">AnonHugePages:     55296 kB</span><br><span class="line">ShmemPmdMapped:        0 kB</span><br><span class="line">Shared_Hugetlb:        0 kB</span><br><span class="line">Private_Hugetlb:       0 kB</span><br><span class="line">Swap:             129208 kB  // 使用的swap区空间</span><br><span class="line">SwapPss:          129208 kB</span><br><span class="line">Locked:                0 kB</span><br></pre></td></tr></table></figure>

<h2 id="启动Kafka-Manager"><a href="#启动Kafka-Manager" class="headerlink" title="启动Kafka Manager"></a>启动Kafka Manager</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --restart=always -d -ti --name=kafkaManager --network=kafka_net  </span><br><span class="line">-p 9000:9000 -e ZK_HOSTS=zookeeperService:2181</span><br><span class="line">sheepkiller/kafka-manager</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> This is our time. This is our moment to define a generation. - Mark Zuckerberg</p>
<p><a href="https://movie.douban.com/subject/3205624/">The Social Network</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>Swap分区</tag>
      </tags>
  </entry>
  <entry>
    <title>Repeated String Match -LeetCode#686</title>
    <url>/2023/04/29/LeetCode686/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/leetcode/686.png" class="full-image" />


<h1 id="FIRST-Time-Limit-Exceeded"><a href="#FIRST-Time-Limit-Exceeded" class="headerlink" title="FIRST -Time Limit Exceeded"></a>FIRST -Time Limit Exceeded</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">repeatedStringMatch</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= b.length(); i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">repeatStr</span> <span class="operator">=</span> a.repeat(i);</span><br><span class="line">        <span class="keyword">if</span> (repeatStr.contains(b)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="SECOND-AC-10-57"><a href="#SECOND-AC-10-57" class="headerlink" title="SECOND -AC 10.57%"></a>SECOND -AC 10.57%</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">repeatedStringMatch</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sb.length() &lt; b.length()) &#123;</span><br><span class="line">        sb.append(a);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sb.indexOf(b) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(a);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (sb.indexOf(b) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="THREE-AC-98-53"><a href="#THREE-AC-98-53" class="headerlink" title="THREE -AC 98.53%"></a>THREE -AC 98.53%</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">repeatedStringMatch</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] freq = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : a.toCharArray()) &#123;</span><br><span class="line">        freq[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : b.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (freq[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sb.length() &lt; b.length()) &#123;</span><br><span class="line">        sb.append(a);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sb.indexOf(b) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(a);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (sb.indexOf(b) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!--stackedit_data:
eyJoaXN0b3J5IjpbODQyODgyNzg3XX0=
-->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>排序-归并排序</title>
    <url>/2018/04/11/MergeSort/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/30.png" class="full-image" />

<p>怎么对数据进行排序？排序算法有多种，该使用哪种排序算法呢？回顾下时间复杂度较低的归并排序</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><blockquote>
<p>归并排序的核心分为两个部分。<sup>1。</sup>将待排序数据对半分，直到只剩一个元素。<sup>2。</sup>针对两部分的数据（每部分已经是有序的）进行排序，左半部分与右半部分进行排序</p>
</blockquote>
<h2 id="归并排序（递归方式）"><a href="#归并排序（递归方式）" class="headerlink" title="归并排序（递归方式）"></a>归并排序（递归方式）</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSortByRecursive</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    mergeSortRecursive(<span class="number">0</span>, data.length - <span class="number">1</span>, data, <span class="keyword">new</span> <span class="title class_">int</span>[data.length]);</span><br><span class="line">    System.out.println(<span class="string">&quot;MergeSortRecursive Time Cost : &quot;</span> + (System.nanoTime() - startTime) * <span class="number">0.000001</span> +<span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    checkSortedData(data,<span class="string">&quot;MergeSortRecursive&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSortRecursive</span><span class="params">(<span class="type">int</span> lowIndex, <span class="type">int</span> highIndex, <span class="type">int</span>[] data, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lowIndex &gt;= highIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> ((highIndex - lowIndex) &gt;&gt; <span class="number">1</span>) + lowIndex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">startOne</span> <span class="operator">=</span> lowIndex, endOne = mid, startTwo = mid + <span class="number">1</span>, endTwo = highIndex;</span><br><span class="line">    mergeSortRecursive(startOne, endOne, data, temp);</span><br><span class="line">    mergeSortRecursive(startTwo, endTwo, data, temp);</span><br><span class="line">    mergeData(lowIndex, mid, highIndex, data, temp);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeData</span><span class="params">(<span class="type">int</span> lowIndex, <span class="type">int</span> middle, <span class="type">int</span> highIndex, <span class="type">int</span>[] data, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lowIndex; i &lt;= highIndex; i++) &#123;</span><br><span class="line">        temp[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftStart</span> <span class="operator">=</span> lowIndex, rightStart = middle + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tempIndex</span> <span class="operator">=</span> leftStart;</span><br><span class="line">    <span class="keyword">while</span> (leftStart &lt;= middle &amp;&amp; rightStart &lt;= highIndex) &#123;</span><br><span class="line">        data[tempIndex++] = temp[leftStart] &lt; temp[rightStart] ? temp[leftStart++] : temp[rightStart++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (leftStart &lt;= middle) &#123;</span><br><span class="line">        data[tempIndex++] = temp[leftStart++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="递归归并排序示意图"><a href="#递归归并排序示意图" class="headerlink" title="递归归并排序示意图"></a>递归归并排序示意图</h3><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/RecursiveMerge.png" alt="image"></p>
<blockquote>
<p>上述的排序代码是理想状态下的，当排序的数据量较大的时候，<sup>1。</sup>使用递归的方式对数据进行分治，排序的过程将不能正常结束，递归达到一定的深度将导致栈内存溢出。<sup>2。</sup>merge排序过程中需要额外的存储空间</p>
</blockquote>
<h2 id="归并排序（迭代方式）"><a href="#归并排序（迭代方式）" class="headerlink" title="归并排序（迭代方式）"></a>归并排序（迭代方式）</h2><p>迭代归并排序将不会出现栈内存溢出的问题，同时对于merge部分可以采用原地排序，降低空间复杂度</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSortByIterative</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> block=<span class="number">1</span>; block&lt;=data.length-<span class="number">1</span>/<span class="number">2</span>; block = <span class="number">2</span>*block)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left_start=<span class="number">0</span>; left_start&lt;data.length-<span class="number">1</span>; left_start += <span class="number">2</span>*block)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left_start + block - <span class="number">1</span> &lt; data.length-<span class="number">1</span> ? left_start + block - <span class="number">1</span> : left_start-<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right_end</span> <span class="operator">=</span> (left_start + <span class="number">2</span> * block - <span class="number">1</span>) &lt; data.length - <span class="number">1</span> ? left_start + <span class="number">2</span> * block - <span class="number">1</span> : data.length-<span class="number">1</span>;</span><br><span class="line">            mergeDataInPlace(left_start,mid,right_end,data);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeDataInPlace</span><span class="params">(<span class="type">int</span> lowIndex, <span class="type">int</span> middle, <span class="type">int</span> highIndex, <span class="type">int</span>[] data)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lowIndex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> middle + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; j &lt;= highIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; data[i] &lt;= data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= highIndex &amp;&amp; data[j] &lt;= data[i])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(data, i, index-i, j-index);</span><br><span class="line">        i += (j-index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> k, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    reverse(arr, i, i + k - <span class="number">1</span>);</span><br><span class="line">    reverse(arr, i + k, i + k + j - <span class="number">1</span>);</span><br><span class="line">    reverse(arr, i, i + k + j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] ^= arr[j];</span><br><span class="line">        arr[j] ^= arr[i];</span><br><span class="line">        arr[i] ^= arr[j];</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="迭代归并排序示意图"><a href="#迭代归并排序示意图" class="headerlink" title="迭代归并排序示意图"></a>迭代归并排序示意图</h3><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%20IterationMerge.png" alt="image"></p>
<h1 id="归并的算法复杂度"><a href="#归并的算法复杂度" class="headerlink" title="归并的算法复杂度"></a>归并的算法复杂度</h1><ol>
<li>将N个待排序的数据对半分，分到剩下单个元素为止，这个过程需要<strong>log<sub>2</sub>N</strong>次</li>
<li>针对两部分有序的数据进行排序，比较的次数介于 <strong>N ~ N&#x2F;2</strong> 之间</li>
</ol>
<ul>
<li>时间复杂度：<strong>O(Nlog<sub>2</sub>N)</strong></li>
<li>空间复杂度：<strong>O(1) ~ O(N)</strong></li>
</ul>
<h1 id="实际运行效果"><a href="#实际运行效果" class="headerlink" title="实际运行效果"></a>实际运行效果</h1><h2 id="时间与空间不可兼得"><a href="#时间与空间不可兼得" class="headerlink" title="时间与空间不可兼得"></a>时间与空间不可兼得</h2><p>来看看归并排序具体所需的时间，测试数据为0～20W的随机大小数字，20W个数据排序5次</p>
<ul>
<li>迭代归并排序(归并部分采用In-Place)</li>
</ul>
<table>
<thead>
<tr>
<th>排序次数</th>
<th>所需时间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>20093.858586 ms</td>
</tr>
<tr>
<td>2</td>
<td>19864.726974999998 ms</td>
</tr>
<tr>
<td>3</td>
<td>19930.830952 ms</td>
</tr>
<tr>
<td>4</td>
<td>19667.228037999997 ms</td>
</tr>
<tr>
<td>5</td>
<td>19873.263419 ms</td>
</tr>
</tbody></table>
<ul>
<li>迭代归并排序(归并部分不采用In-Place)</li>
</ul>
<table>
<thead>
<tr>
<th>排序次数</th>
<th>所需时间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>69.183775 ms</td>
</tr>
<tr>
<td>2</td>
<td>45.25653 ms</td>
</tr>
<tr>
<td>3</td>
<td>36.282312 ms</td>
</tr>
<tr>
<td>4</td>
<td>38.270578 ms</td>
</tr>
<tr>
<td>5</td>
<td>35.130196999999995 ms</td>
</tr>
</tbody></table>
<blockquote>
<p>merge部分算法不同，排序的整体时间天壤之别。。。In-Place merge虽然节省了空间，但是带来了更多的元素移动，更多的时间消耗。时间复杂度与空间复杂度不可兼得</p>
</blockquote>
<h2 id="Fork-Join排序"><a href="#Fork-Join排序" class="headerlink" title="Fork&#x2F;Join排序"></a>Fork&#x2F;Join排序</h2><p>来看看对千万级的数据量进行排序，时间情况如何。测试数据1000W</p>
<ul>
<li>迭代归并排序</li>
</ul>
<table>
<thead>
<tr>
<th>排序次数</th>
<th>所需时间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2690.39711 ms</td>
</tr>
<tr>
<td>2</td>
<td>2267.34402 ms</td>
</tr>
<tr>
<td>3</td>
<td>2423.867487 ms</td>
</tr>
<tr>
<td>4</td>
<td>2543.747986 ms</td>
</tr>
<tr>
<td>5</td>
<td>2409.55724 ms</td>
</tr>
</tbody></table>
<blockquote>
<p>归并排序先把大量的数据分为多个小量的数据（分治），然后合并小量的数据（合并），这不是在说Fork&#x2F;Join的嘛,而且Fork&#x2F;Join可以利用多核，那么利用Fork&#x2F;Join排序会不会快一点？</p>
</blockquote>
<ul>
<li>Fork&#x2F;Join归并排序</li>
</ul>
<table>
<thead>
<tr>
<th>排序次数</th>
<th>所需时间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10921.404759 ms</td>
</tr>
<tr>
<td>2</td>
<td>16899.215443 ms</td>
</tr>
<tr>
<td>3</td>
<td>14746.151189 ms</td>
</tr>
<tr>
<td>4</td>
<td>14887.626859999998 ms</td>
</tr>
<tr>
<td>5</td>
<td>15565.447017999999 ms</td>
</tr>
</tbody></table>
<blockquote>
<p>不敢相信的速度，Fork&#x2F;Join排序会消耗大量的内存空间，导致频繁的GC，归并排序分治的最小任务是1，Fork&#x2F;Join虽能并行的处理排序，但任务如果分的过小，会带来更多的线程切换，相比单线程的迭代归并排序，反而需要更多的时间</p>
</blockquote>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> I’m not a devil, I’m just a good man, put in a bad place. - Verbal Kint</p>
<p><a href="https://movie.douban.com/subject/1292214/">The Usual Suspects</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Docker搭建监控系统</title>
    <url>/2019/01/30/MonitorBaseOnDocker/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/17.png" class="full-image" />

<p>记录如何基于Docker搭建监控系统</p>
<h1 id="StatsD"><a href="#StatsD" class="headerlink" title="StatsD"></a>StatsD</h1><p>StatsD 用于统计和聚合系统的指标数据</p>
<ol>
<li>StatsD client<br>拥有多语言实现，用于将数据发送到StatsD Server</li>
<li>StatsD daemon<br>监听StatsD client 发送的数据并整合数据发送(默认每10s)到后端</li>
<li>监控后端 Graphite、influxDB</li>
</ol>
<h2 id="StatsD-协议"><a href="#StatsD-协议" class="headerlink" title="StatsD 协议"></a>StatsD 协议</h2><p>StatsD采用简单的行协议，StatsD Server默认采用UDP协议，可配置为 TCP协议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bucket&gt;:&lt;value&gt;|&lt;type&gt;[|@sample_rate]</span><br><span class="line">* bucket: Metric 标识</span><br><span class="line">* value: Metric 数值</span><br><span class="line">* type: Metric 类型</span><br><span class="line">* sample_rate: 采样率</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="StatsD-Metric-Types"><a href="#StatsD-Metric-Types" class="headerlink" title="StatsD Metric Types"></a>StatsD Metric Types</h2><ol>
<li>Counting<br>计数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">people.number:10|c  -- people.number +10</span><br><span class="line">people.number:2|c  -- people.number 10+2 = 12</span><br><span class="line">people.number:-5|c  -- people.number 12-5 = 7</span><br><span class="line">people.number:10|c|@0.1  -- people.number 7+10/0.1=107</span><br><span class="line">flush 107</span><br><span class="line">current people.number 107</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>Timing<br>记录操作耗时，StatsD 会计算出平均值、标准差、最大值、最小值</li>
</ol>
<blockquote>
<p>people.number.api.mean_$PCT<br>people.number.api.sum_$PCT<br>people.number.api.upper_$PCT</p>
<ul>
<li>PCT表示百分比阀值，可配置</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">people.number.api:10|ms</span><br><span class="line">people.number.api:101|ms</span><br><span class="line">people.number.api:20|ms</span><br><span class="line">people.number.api:15|ms</span><br><span class="line">people.number.api:11|ms</span><br><span class="line">flush前值列表为 [10,101,20,15,11]</span><br><span class="line"></span><br><span class="line">假设 PCT为80 则刷新上报的值为: </span><br><span class="line">1. 首先剔除10%的峰值：5*0.8 = 4 (四舍五入) ，保留4个值，剔除剩余峰值101。当前[10,20,15,11]</span><br><span class="line">2. 平均值: (10+20+15+11)/4  最大值: 20  最小值: 10</span><br><span class="line"></span><br><span class="line">current people.number.api 0</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>Gauges<br> 在flush后值不会被清零</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat.food.amount:10|g  -- cat.food.amount +10</span><br><span class="line">cat.food.amount:-2|g  -- cat.food.amount 10-2=8</span><br><span class="line">cat.food.amount:+5|g  -- cat.food.amount 8+5=13</span><br><span class="line">cat.food.amount:10|g  -- cat.food.amount 10</span><br><span class="line">flush 10  </span><br><span class="line">current cat.food.amount 10</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>Sets<br>统计不重复的值有多少个</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">active.people.id:2|g  -- active.people.id +1</span><br><span class="line">active.people.id:1|g  -- active.people.id 1+1 = 2</span><br><span class="line">active.people.id:1|g  -- active.people.id 2</span><br><span class="line">active.people.id:10|g  -- active.people.id 2+1 = 3</span><br><span class="line">flush 3  </span><br><span class="line">current active.people.id 0</span><br></pre></td></tr></table></figure>


<h1 id="Graphite"><a href="#Graphite" class="headerlink" title="Graphite"></a>Graphite</h1><p>Graphite 由三部分构成</p>
<ol>
<li>carbon<br>监听时间序列数据</li>
<li>whisper<br>存储时间序列数据</li>
<li>graphite-web<br>展示时间序列数据</li>
</ol>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Monitoring/graphite.png" alt="image"></p>
<h1 id="Graphite-StatsD-安装"><a href="#Graphite-StatsD-安装" class="headerlink" title="Graphite &amp; StatsD 安装"></a>Graphite &amp; StatsD 安装</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name graphite --restart=always -p 8080:80 -p 2003-2004:2003-2004 -p 2023-2024:2023-2024 -p 8125:8125/udp -p 8126:8126 -d graphiteapp/graphite-statsd</span><br></pre></td></tr></table></figure>

<h2 id="访问Graphite"><a href="#访问Graphite" class="headerlink" title="访问Graphite"></a>访问Graphite</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://host:8080/dashboard</span><br><span class="line">默认用户密码为：root/root</span><br><span class="line">修改用户密码：http://host:8080/admin/auth/user/1/</span><br></pre></td></tr></table></figure>

<h1 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h1><p>官方是这么说的：<br>No matter where your data is, or what kind of database it lives in, you can bring it together with Grafana. Beautifully</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Monitoring/grafana.png" alt="image"></p>
<h2 id="Grafana安装"><a href="#Grafana安装" class="headerlink" title="Grafana安装"></a>Grafana安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name=grafana --restart=always -p 3000:3000 -d grafana/grafana</span><br></pre></td></tr></table></figure>


<h2 id="访问Grafana"><a href="#访问Grafana" class="headerlink" title="访问Grafana"></a>访问Grafana</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://host:3000</span><br><span class="line">默认用户/密码：admin/admin</span><br></pre></td></tr></table></figure>


<h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Monitoring/grafana%20data%20config.png" alt="image"></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Monitoring/grafana%20data%20config%202.png" alt="image"></p>
<h1 id="Metrics数据模拟"><a href="#Metrics数据模拟" class="headerlink" title="Metrics数据模拟"></a>Metrics数据模拟</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while true; do echo -n &quot;people.number:$((RANDOM % 100))|c&quot; | nc -w 1 -u 127.0.0.1 8125; done</span><br></pre></td></tr></table></figure>
<h1 id="设置Grafana图表"><a href="#设置Grafana图表" class="headerlink" title="设置Grafana图表"></a>设置Grafana图表</h1><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Monitoring/Grafana%20Graph.png" alt="image"></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Monitoring/Grafana%20Graph%202.png" alt="image"></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> You don’t know about real loss, because it only occurs when you’ve loved something more than you love yourself. - Sean</p>
<p><a href="https://movie.douban.com/subject/1292656/">Good Will Hunting</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>监控</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 事务隔离级别与并发问题</title>
    <url>/2024/09/24/MySQLIsolation/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/20.png" class="full-image">

<p>在数据库系统中，事务的隔离性是保证多个事务并发执行时不会相互干扰的重要特性。在本文中，我们将介绍 MySQL InnoDB 中的四种事务隔离级别，并讨论每种隔离级别可能产生的并发问题。</p>
<span id="more"></span>

<h1 id="事务隔离级别简介"><a href="#事务隔离级别简介" class="headerlink" title="事务隔离级别简介"></a>事务隔离级别简介</h1><p>MySQL InnoDB 支持四种事务隔离级别，分别是  Read Uncommitted、Read Committed、Repeatable Read、Serializable，每种隔离级别都会影响事务在并发操作中的行为，以下是事物并发操作在不同隔离级别下产生的问题。</p>
<table>
<thead>
<tr>
<th>Isolation Level</th>
<th>Dirty Read</th>
<th>Non-repeatable Read</th>
<th>Phantom Read</th>
</tr>
</thead>
<tbody><tr>
<td>Read Uncommitted</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Read Committed</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Serializable</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
</tbody></table>
<ul>
<li>脏读：当一个事务读取了另一个事务尚未提交的修改数据，如果该修改事务随后回滚，读取到的数据就变成了无效的脏数据</li>
<li>不可重复读：同一个事务中，前后两次读取相同的记录却得到了不同的结果，这是因为另一事务在这期间修改了这条记录并提交了更改</li>
<li>幻读：同一事务中，前后两次执行相同的查询时，返回的结果集行数不同。这是因为另一事务在两次查询期间插入或删除了数据</li>
</ul>
<h2 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h2><p>Read Uncommitted 未提交读，是最低级别的隔离级别，它允许一个事务读取到其他事务尚未提交的数据。事务A读取到事务B未提交的数据，如果事务B在后续回滚，事务A所读取的数据就变成了脏数据。脏读只出现在 Read Uncommitted 隔离级别中，同时也包含不可重复读和幻读的问题。</p>
<table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>SELECT balance FROM accounts WHERE id = 1;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>UPDATE accounts SET balance = balance + 100 WHERE id = 1;</code></td>
</tr>
<tr>
<td>T5</td>
<td><code>SELECT balance FROM accounts WHERE id = 1;</code> <strong>(读取到事务B的未提交更改，脏读)</strong></td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>ROLLBACK;</code> <strong>(事务B回滚，事务A读取到的值是脏数据)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h2><p>Read Committed 提交读，只允许事务读取到其他事务已经提交的数据，解决了脏读问题，但存在不可重复读和幻读的问题。</p>
<table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>SELECT balance FROM accounts WHERE id = 1;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>UPDATE accounts SET balance = balance + 100 WHERE id = 1;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交更改)</strong></td>
</tr>
<tr>
<td>T6</td>
<td><code>SELECT balance FROM accounts WHERE id = 1;</code> <strong>(读取到更新后的值，不可重复读)</strong></td>
<td></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read"></a>Repeatable Read</h2><p>Repeatable Read 可重复读，确保在同一个事务中多次读取同一行数据的结果是相同的。它解决了不可重复读的问题，但未解决幻读问题。</p>
<table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>SELECT * FROM accounts WHERE balance &gt; 1000;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>INSERT INTO accounts (id, balance) VALUES (3, 1500);</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B插入了新数据)</strong></td>
</tr>
<tr>
<td>T6</td>
<td><code>SELECT * FROM accounts WHERE balance &gt; 1000;</code> <strong>(幻读：读取到新插入的数据)</strong></td>
<td></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code></td>
<td></td>
</tr>
</tbody></table>
<p>在 Repeatable Read  隔离级别下，MySQL 通过 <strong>MVCC（多版本并发控制）</strong> 和 <strong>Gap Lock（间隙锁）</strong> 解决了部分幻读问题。MVCC 可以确保事务内的读操作是可重复的，Gap Lock 可以阻止其他事务在特定范围内插入新记录，从而解决部分幻读，但并未完全解决幻读的问题。</p>
<h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>Serializable 是最高级别的事务隔离级别，通过将事务串行化执行，彻底解决了幻读问题，但也降低了系统的并发性能。</p>
<table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>SELECT * FROM accounts WHERE balance &gt; 1000;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>INSERT INTO accounts (id, balance) VALUES (3, 1500);</code> <strong>(被阻塞，等待事务A提交)</strong></td>
</tr>
<tr>
<td>T5</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>INSERT INTO accounts (id, balance) VALUES (3, 1500);</code> <strong>(成功执行插入操作)</strong></td>
</tr>
<tr>
<td>T7</td>
<td></td>
<td><code>COMMIT;</code></td>
</tr>
</tbody></table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MySQL InnoDB 提供了四种不同的事务隔离级别，以满足不同的应用场景。如果系统对一致性要求较低且并发压力大，可以选择较低的隔离级别如 Read Uncommitted 或 Read Committed。如果对一致性要求较高且系统需要避免并发读写问题，可以选择 Repeatable Read 或 Serializable。在选择合适的隔离级别时，需要根据系统的并发需求和数据一致性要求进行权衡。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 事务隔离级别与MVCC</title>
    <url>/2024/09/29/MySQLMVCC/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/21.png" class="full-image">

<p>事物的隔离主要是为了控制多个事物并发执行时相互间的影响，多个事物可能会在同一时刻访问和修改同一组数据，这会产生各种并发问题，导致数据不一致。通过设置不同的事物隔离级别，数据库可以在并发性能与并发问题之间进行权衡，以适应不同应用场景的需求。</p>
<span id="more"></span>

<h1 id="MySQL-事物隔离级别"><a href="#MySQL-事物隔离级别" class="headerlink" title="MySQL 事物隔离级别"></a>MySQL 事物隔离级别</h1><p>SQL标准中定义了四种事物隔离级别，分别为 Read  Uncommitted、Read Committed、Repeatable Read、Serializable。MySQL InnoDB 引擎实现了这四种隔离级别，我们先来回顾一下这四种事物隔离级别的特点。</p>
<table>
<thead>
<tr>
<th><strong>Transaction Isolation</strong></th>
<th><strong>Common Concurrency Issues</strong></th>
<th><strong>Concurrency Performance</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Read Uncommitted</strong></td>
<td>Dirty Reads, Non-repeatable Reads, Phantom Reads</td>
<td>Highest</td>
</tr>
<tr>
<td><strong>Read Committed</strong></td>
<td>Non-repeatable Reads, Phantom Reads</td>
<td>High</td>
</tr>
<tr>
<td><strong>Repeatable Read</strong></td>
<td>Phantom Reads</td>
<td>Good</td>
</tr>
<tr>
<td><strong>Serializable</strong></td>
<td>No concurrency issues, fully serialized execution</td>
<td>Lowest</td>
</tr>
</tbody></table>
<h2 id="隔离级别选择"><a href="#隔离级别选择" class="headerlink" title="隔离级别选择"></a>隔离级别选择</h2><p>从以上图表可以发现，Read Uncommitted 的并发性能是最高的，导致的并发问题也是最多的，尤其是会产生脏读，这会导致更多的数据不一致，对于一般系统来说是无法接受的，虽然 Serializable不会产生并发问题，但并发性能是最低的，对于一般系统来说同样是无法接受的，大部分的应用会根据不同的使用场景，在 Read Committed 和 Repeatable Read 两个隔离级别之间作出选择。不同的数据库厂商也有不同的默认隔离级别选择，比如 MySQL InnoDB 默认的隔离级别是 Repeatable Read，而 Oracle 默认的隔离级别是 Read Committed。</p>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>MVCC 全称 Multiversion Concurrency Control（多版本并发控制），是一种无锁的并发访问技术，最早的 MVCC 阐述可以追溯到 1978 年，一般被用在数据库管理系统中。MySQL InnoDB 提供了 MVCC 的实现，大大提高了数据库并发访问的性能。Read Committed 和 Repeatable Read 能够拥有如此良好的性能，离不开 MVCC 的支持。需要注意的是 Read Uncommitted 和 Serializable 隔离级别不支持 MVCC。</p>
<h2 id="版本快照"><a href="#版本快照" class="headerlink" title="版本快照"></a>版本快照</h2><p>MVCC 通过维护每一行数据的变更版本来实现并发控制，每当有事物更改某一行数据的时候，MySQL InnoDB 并不会直接覆盖原始值，而是生成一个新的快照，内容存储在 undo log 文件中。假设现在有 T1、T2、T3 这个三事物尝试更新账户 balance 的值，则会创建如下图所示的版本快照。</p>
<table>
<thead>
<tr>
<th><strong>Operation</strong></th>
<th><strong>balance</strong></th>
<th><strong>DB_TRX_ID</strong></th>
<th><strong>DB_ROLL_PTR</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T3 updates balance &#x3D; 400 (uncommitted <strong>latest record</strong>)</td>
<td>400</td>
<td>3</td>
<td>↓</td>
</tr>
<tr>
<td>T2 updates balance &#x3D; 300 (uncommitted)</td>
<td>300</td>
<td>2</td>
<td>↓</td>
</tr>
<tr>
<td>T1 updates balance &#x3D; 200 (uncommitted)</td>
<td>200</td>
<td>1</td>
<td>↓</td>
</tr>
<tr>
<td>Initial state</td>
<td>100</td>
<td>0</td>
<td>NULL</td>
</tr>
</tbody></table>
<h2 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h2><p>DB_TRX_ID 和 DB_ROLL_PTR 是隐藏的行记录字段，存储在 Record Header（聚簇索引）中，分别表示最近修改该行记录的事物ID和指向该行记录的 undo log（上一个版本数据），下图展示了 T1、T2、T3 事物形成的版本链。</p>
<table>
<thead>
<tr>
<th>Transaction T3 (DB_TRX_ID &#x3D; 3, balance &#x3D; 400, uncommitted)</th>
<th>→</th>
<th>Transaction T2 (DB_TRX_ID &#x3D; 2, balance &#x3D; 300, uncommitted)</th>
<th>→</th>
<th>Transaction T1 (DB_TRX_ID &#x3D; 1, balance &#x3D; 200, uncommitted)</th>
<th>→</th>
<th>Initial state (DB_TRX_ID &#x3D; 0, balance &#x3D; 100)</th>
</tr>
</thead>
</table>
<p>针对某一行数据修改的并发事物越多，产生的 undo log 也越多，这会占用更多的存储空间，典型的通过空间来换取时间。</p>
<h2 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h2><p>Read View 规定了当前事物在读取数据时，哪些版本可见，哪些版本不可见，这些可见性规则是 MVCC 实现的一部分，Read View 主要有以下几个部分组成：</p>
<ol>
<li>ACTIVE_TRX_IDS：记录当前系统中所有尚未提交的事务ID。</li>
<li>LOW_LIMIT_ID：系统中下一个还未开始的事务的ID。</li>
<li>UP_LIMIT_ID：ACTIVE_TRX_IDS 中的最小值。</li>
<li>CREATOR_TRX_ID：当前正在执行的事务ID。创建或修改数据的事务会分配事务ID，并将该ID记录为 CREATOR_TRX_ID，如果事物只是查询则事物ID默认为 0。</li>
</ol>
<p>之前我们有提到 Read Committed 和 Repeatable Read 都支持 MVCC，但他们创建 Read View 的时机是不同的。</p>
<ul>
<li>Read Committed：事物中的每一次查询，都会创建一个 Read View，这意味着多次查询同一条记录可能会看到不同的结果，存在不可重复读的问题。</li>
<li>Repeatable Read：整个事物只会创建一个 Read View，这意味着多次查询同一条记录，看到的结果是相同的，解决了不可重复读的问题。</li>
</ul>
<h2 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h2><p>当事务第一次执行 SELECT … FROM table 时，MySQL InnoDB 会创建一个 Read View，按照如下几条检查规则，可以确定当前查询可以看到哪些版本的数据：</p>
<ol>
<li>如果被访问的版本中 DB_TRX_ID &#x3D; CREATOR_TRX_ID，则表明当前事物正在访问自己修改的版本，所以该版本对当前事物可见。</li>
<li>如果被访问的版本中 DB_TRX_ID &lt; UP_LIMIT_ID，则表明当前访问的版本事物在此 Read View 创建前已经提交，所以该版本对当前事物可见。</li>
<li>如果被访问的版本中 DB_TRX_ID &gt;&#x3D; LOW_LIMIT_ID，则表明当前访问的事物在此 Read View 创建后开启，所以该版本对当前事物不可见。</li>
<li>如果被访问的版本中 UP_LIMIT_ID &lt;&#x3D; DB_TRX_ID &lt; LOW_LIMIT_ID，则可见性需要按照如下情况决定，如果 DB_TRX_ID 不在 ACTIVE_TRX_IDS 列表中，则说明当前访问的版本已经提交，该版本对当前事物可见，若在 ACTIVE_TRX_IDS 列表中，则说明当前访问的版本未提交，对当前事物不可见。</li>
</ol>
<p>若经过以上规则判断，版本 DB_TRX_ID 对当前事物不可见，则沿着 DB_TRX_ID 的下一个版本继续进行规则判断，一直到找到当前事物可见的版本。值得注意的是，规则 1 的存在是 Repeatable Read 隔离级别存在<strong>幻读</strong>问题的一个原因。</p>
<table>
<thead>
<tr>
<th><strong>Timeline</strong></th>
<th><strong>Transaction A</strong></th>
<th><strong>Transaction B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>SELECT balance FROM accounts WHERE id = 1;</code> <strong>(No record found)</strong></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>INSERT INTO accounts (id, balance) VALUES (1, 100);</code></td>
</tr>
<tr>
<td>T5</td>
<td><code>SELECT balance FROM accounts WHERE id = 1;</code> <strong>(No record found, due to Repeatable Read isolation)</strong></td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>COMMIT;</code> <strong>(Transaction B commits the new record)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>UPDATE accounts SET balance = balance + 50 WHERE id = 1;</code> <strong>(1 row affected, current read behavior)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td><code>SELECT balance FROM accounts WHERE id = 1;</code> <strong>(Reads updated balance of 150)</strong></td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td><code>COMMIT;</code></td>
<td></td>
</tr>
</tbody></table>
<p>事物 A 在 T2 和 T8 时间的两次查询，返回了不同的结果集，产生了幻读问题。原因是事物 A 在 T7 时间更新时发生了当前读，更新到了最新已经被提交的数据，紧接着 T8 又进行了快照读，根据可见性规则 1 的描述，查询到了可见的版本数据。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 事物隔离级别与锁（上）</title>
    <url>/2024/10/31/MySQLTILockPart1/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/23.png" class="full-image">

<p>MySQL 通过设置不同的事物隔离级别，数据库可以在并发性能与并发问题之间进行权衡，这种权衡离不开 MySQL 提供的多样化锁支持。MySQL 锁可以分为 <strong>表级锁</strong>、<strong>行级锁</strong>、<strong>意向锁</strong>、<strong>共享锁</strong>、<strong>排他锁</strong>，在 MySQL InnoDB 引擎下的锁会有更多细致的分类，这篇文章我们主要介绍 MySQL InnoDB 下的锁机制。</p>
<span id="more"></span>

<h1 id="MySQL-InnoDB-锁"><a href="#MySQL-InnoDB-锁" class="headerlink" title="MySQL InnoDB 锁"></a>MySQL InnoDB 锁</h1><p>MySQL InnoDB 支持的锁种类繁多，用途、作用范围各不相同，可以根据不同应用需求调整锁的使用，以下表格描述了 MySQL InnoDB 支持的几种主要锁类型及其用途：</p>
<table>
<thead>
<tr>
<th><strong>锁类型</strong></th>
<th><strong>作用</strong></th>
<th><strong>范围</strong></th>
<th><strong>加锁方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>共享锁（S）</td>
<td>允许多个事务并发读取数据，但不允许修改</td>
<td>单行，<br>多行，<br>全表</td>
<td>自动<br>或显式</td>
</tr>
<tr>
<td>排他锁（X）</td>
<td>只允许持有该锁的事务读写数据，阻止其他事务的任何操作</td>
<td>单行，<br>多行，<br>全表</td>
<td>自动<br>或显式</td>
</tr>
<tr>
<td>意向共享锁（IS）</td>
<td>表明事务打算在某些行上加 共享锁（S），确保表级锁和行级锁的一致性，提高加锁效率</td>
<td>全表</td>
<td>自动加锁</td>
</tr>
<tr>
<td>意向排他锁（IX）</td>
<td>表明事务打算在某些行上加 排他锁（X），确保表级锁和行级锁的一致性，提高加锁效率</td>
<td>全表</td>
<td>自动加锁</td>
</tr>
<tr>
<td>间隙锁（Gap Lock）</td>
<td>锁定索引记录之间的空隙，防止其他事务在该间隙中插入和修改新记录</td>
<td>索引记录之间的间隙</td>
<td>自动或显式</td>
</tr>
<tr>
<td>临键锁（Next-Key Lock）</td>
<td>锁定索引记录及其前后的间隙，防止其他事务在该间隙中插入和修改新记录</td>
<td>索引记录及其前后的间隙</td>
<td>自动或显式</td>
</tr>
<tr>
<td>记录锁（Record Lock）</td>
<td>锁定单个索引记录，防止其他事务修改或删除该记录</td>
<td>单行索引记录</td>
<td>自动或显式</td>
</tr>
<tr>
<td>插入意向锁（Insert Intention Lock）</td>
<td>允许多个事务在不同位置插入记录，但防止在相同间隙位置插入</td>
<td>插入位置之间的空隙</td>
<td>自动加锁</td>
</tr>
<tr>
<td>自增长锁（AUTO-INC Lock）</td>
<td>确保 AUTO_INCREMENT 列的唯一性和有序性</td>
<td>全表</td>
<td>自动加锁</td>
</tr>
</tbody></table>
<h2 id="显示加锁语句"><a href="#显示加锁语句" class="headerlink" title="显示加锁语句"></a>显示加锁语句</h2><p>大部分的锁都是系统自动添加的，但我们可以根据应用需要，通过以下语句显示控制加锁类型：</p>
<table>
<thead>
<tr>
<th><strong>显示加锁语句</strong></th>
<th><strong>锁类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>SELECT * FROM table LOCK IN SHARE MODE;</code></td>
<td>S 锁</td>
</tr>
<tr>
<td><code>SELECT * FROM table FOR UPDATE;</code></td>
<td>X 锁</td>
</tr>
<tr>
<td><code>LOCK TABLES table WRITE;</code></td>
<td>表级 X 锁</td>
</tr>
<tr>
<td><code>LOCK TABLES table READ;</code></td>
<td>表级 S 锁</td>
</tr>
</tbody></table>
<h2 id="锁兼容性"><a href="#锁兼容性" class="headerlink" title="锁兼容性"></a>锁兼容性</h2><p>在 MySQL InnoDB 中，不同类型的锁在并发事务间存在兼容性问题。下面展示了意向锁（IS、IX）、共享锁（S）、排他锁（X）之间的兼容关系：</p>
<table>
<thead>
<tr>
<th></th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IS</strong></td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td><strong>IX</strong></td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td><strong>S</strong></td>
<td>兼容</td>
<td>不兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td><strong>X</strong></td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
</tbody></table>
<h1 id="隔离级别与锁"><a href="#隔离级别与锁" class="headerlink" title="隔离级别与锁"></a>隔离级别与锁</h1><p>MySQL InnoDB 锁对于不同事物隔离级别的支持是有差异的，加锁类型在不同隔离级别下也不尽相同。接下来我们会从执行以下 SQL 语句开始，分析不同事物隔离级别下的加锁情况：</p>
<table>
<thead>
<tr>
<th>SQL 语句</th>
</tr>
</thead>
<tbody><tr>
<td><code>SELECT * FROM table WHERE column = ?;</code></td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ?;</code></td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column = ? LOCK IN SHARE MODE;</code></td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ? LOCK IN SHARE MODE;</code></td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column = ? FOR UPDATE;</code></td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ? FOR UPDATE;</code></td>
</tr>
</tbody></table>
<p>下文事例都将基于表 <strong>employees</strong> 中的数据：</p>
<table>
<thead>
<tr>
<th>id（主键）</th>
<th>name（非索引）</th>
<th>employee_number<br>（唯一索引）</th>
<th>age（普通索引）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
<td>1001</td>
<td>30</td>
</tr>
<tr>
<td>5</td>
<td>Bob</td>
<td>1020</td>
<td>25</td>
</tr>
<tr>
<td>13</td>
<td>Charlie</td>
<td>1010</td>
<td>35</td>
</tr>
<tr>
<td>14</td>
<td>David</td>
<td>1035</td>
<td>25</td>
</tr>
<tr>
<td>25</td>
<td>Eve</td>
<td>1040</td>
<td>32</td>
</tr>
</tbody></table>
<h2 id="Read-UnCommitted"><a href="#Read-UnCommitted" class="headerlink" title="Read UnCommitted"></a>Read UnCommitted</h2><table>
<thead>
<tr>
<th>SQL 语句</th>
<th>锁类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>SELECT * FROM table WHERE column = ?;</code></td>
<td>不加锁</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ?;</code></td>
<td>不加锁</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column = ? LOCK IN SHARE MODE;</code></td>
<td>不加锁</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ? LOCK IN SHARE MODE;</code></td>
<td>不加锁</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column = ? FOR UPDATE;</code></td>
<td>意向排他锁（IX）<br>和 行级排他锁（X）</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ? FOR UPDATE;</code></td>
<td>意向排他锁（IX）<br>和 行级排他锁（X）</td>
</tr>
</tbody></table>
<p>可以看到在 Read UnCommitted 事物隔离级别下，即使查询语句中显示指定了 <strong>LOCK IN SHARE</strong> 的查询，也无法申请到行级共享锁（S），这也符合 Read UnCommitted 允许脏读的设定，每次读取到的数据都是最新记录 <strong>（当前读）</strong>。在没有锁的保护下，会读取到其他事物未提交的数据，产生脏读。接下来我们看看 <strong>FOR UPDATE</strong> 行级排他锁 X 在不同 column 下的加锁区别。</p>
<h3 id="主键-id（聚簇索引）"><a href="#主键-id（聚簇索引）" class="headerlink" title="主键 id（聚簇索引）"></a>主键 id（聚簇索引）</h3><table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务 A</strong></th>
<th><strong>事务 B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE id = 1 FOR UPDATE;</code> <strong>(加锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>UPDATE employees SET name = &#39;Robert&#39; WHERE id = 1;</code> <strong>(被阻塞)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务 A 提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务 B 提交修改)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 T3 时刻的 WHERE 条件中使用了主键的等值查询， id &#x3D; 1 这条记录的聚簇索引上会被添加 X 锁，事物 A 在添加 X 锁之前需要先添加意向排他锁 IX，这里可以通过意向排他锁 IX，快速判断是否可以添加 X 锁（若不存在 IX，则说明当前不存在其事物的排他锁 X），所以这里会添加<strong>表级意向排他锁 IX 和行级排他锁 X，X 会添加在 id &#x3D; 1 的聚簇索引上</strong>。事物 B 在 T6 尝试更新此记录，此时 <strong>UPDATE 语句会自动添加行级排他锁  X</strong> ，申请的同样是 id &#x3D; 1 这条记录的排他锁 X，这导致锁冲突，操作被阻塞。</p>
<table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务 A</strong></th>
<th><strong>事务 B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE id &gt;= 13 FOR UPDATE;</code> <strong>(加锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>UPDATE employees SET name = &#39;Robert&#39; WHERE id = 14;</code> <strong>(被阻塞)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务 A 提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务 B 提交修改)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 T3 时刻的 WHERE 条件中使用了主键的范围查询，符合条件的行记录聚簇索引上都会被添加 X 锁，所以这里会添加<strong>表级意向排他锁 IX 和行级排他锁 X， X 会分别添加在聚簇索引  id &#x3D; 13，id &#x3D; 14，id &#x3D; 25 上</strong>，事物 B 尝试更新这其中的记录时导致锁冲突，操作被阻塞。</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>基本上与聚簇索引 id（主键） 的加锁情况一致（这也容易理解，因为当表中未设置主键 id 的时候，聚集索引可能是第一个不允许为 null 的唯一索引），使用唯一索引 employee_number 时，系统不仅会在该索引上加排他锁 X，还会在相应的聚簇索引 id 上加上排他锁 X。</p>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务 A</strong></th>
<th><strong>事务 B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE age = 25 FOR UPDATE;</code> <strong>(加锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>UPDATE employees SET name = &#39;Robert&#39; WHERE age = 25;</code> <strong>(被阻塞)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务 A 提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务 B 提交修改)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 T3 时刻的 WHERE 条件中使用了普通索引的等值查询，首先普通索引 age &#x3D; 25 上会被添加行级排他锁 X，对应的 id &#x3D; 5，id &#x3D; 14 的聚簇索引上也会被添加排他锁 X，所以这里会添加<strong>表级意向排他锁 IX 和行级排他锁 X， X 会被添加在 age &#x3D; 25 的普通索引上和  id &#x3D; 5，id &#x3D; 14 的聚簇索引上</strong>，事物 B 尝试更新这其中的记录时都会导致锁冲突，操作被阻塞。</p>
<table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务 A</strong></th>
<th><strong>事务 B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE age &gt; 30 FOR UPDATE;</code> <strong>(加锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>UPDATE employees SET name = &#39;Robert&#39; WHERE age = 35;</code> <strong>(被阻塞)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务 A 提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务 B 提交修改)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 T3 时刻的 WHERE 条件中使用了普通索引的范围查询，首先符合条件的普通索引 age &#x3D; 32，age &#x3D; 35 上会被添加行级排他锁 X，对应的 id &#x3D; 25，id &#x3D; 13 的聚簇索引上也会被添加排他锁 X，所以这里会添加<strong>表级意向排他锁 IX 和行级排他锁 X， X 会被添加在 age &#x3D; 32，age &#x3D; 35 的普通索引上和  id &#x3D; 25，id &#x3D; 13 的聚簇索引上</strong>，事物 B 尝试更新这其中的记录时都会导致锁冲突，操作被阻塞。</p>
<h3 id="非索引"><a href="#非索引" class="headerlink" title="非索引"></a>非索引</h3><p>基本上与聚簇索引 id（主键） 的加锁情况一致，主要的区别在于，非索引列的查询会进行全表扫描，全表扫描使用聚簇索引进行，扫描的每一行会先添加排他锁锁 X，如果不符合查询条件的值，锁会被立即释放，最终加锁情况与聚簇索引一致。</p>
<h2 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h2><table>
<thead>
<tr>
<th>SQL 语句</th>
<th>锁类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>SELECT * FROM table WHERE column = ?;</code></td>
<td>不加锁</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ?;</code></td>
<td>不加锁</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column = ? LOCK IN SHARE MODE;</code></td>
<td>意向共享锁（IS）<br>和 行级共享锁（S）</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ? LOCK IN SHARE MODE;</code></td>
<td>意向共享锁（IS）<br>和 行级共享锁（S）</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column = ? FOR UPDATE;</code></td>
<td>意向排他锁（IX）<br>和 行级排他锁（X）</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ? FOR UPDATE;</code></td>
<td>意向排他锁（IX）<br>和 行级排他锁（X）</td>
</tr>
</tbody></table>
<p>不同于 Read UnCommitted 隔离级别，<strong>LOCK IN SHARE MODE</strong> 在 Read Committed 下会添加表级意向共享锁 IS 和 行级共享锁 S，<strong>FOR UPDATE</strong> 的加锁情况与 Read UnCommitted 一致， <strong>LOCK IN SHARE MODE</strong> 在不同列类型的查询条件下，锁定的记录与 <strong>FOR UPDATE</strong> 一致，只是锁的类型变成了 IS 和 S。</p>
<table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务 A</strong></th>
<th><strong>事务 B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE id = 1 LOCK IN SHARE MODE;</code> <strong>(锁定 id &#x3D; 1，防止其他事务修改)</strong></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>UPDATE employees SET name = &#39;Robert&#39; WHERE id = 1;</code> <strong>(被阻塞，因为事务 A 锁定了 id &#x3D; 1)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>SELECT * FROM employees WHERE id = 1;</code> <strong>(读取到的值和之前一致，不会发生不可重复读)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td><code>COMMIT;</code></td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td></td>
<td><code>COMMIT;</code></td>
</tr>
</tbody></table>
<p>在 Read Committed 隔离级别下，使用 <strong>LOCK IN SHARE MODE</strong> 可以使快照读变为当前读，再加上行级排他锁 X 的应用，这似乎可以解决一部分在 Read Committed 隔离级别下产生的<strong>不可重复读问题</strong>。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 事物隔离级别与锁（下）</title>
    <url>/2024/11/13/MySQLTILockPart2/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/29.png" class="full-image">

<p>上篇文章 <strong>MySQL 事物隔离级别与锁（上）</strong> 中，我们主要介绍了在 Read UnCommitted 和 Read Committed 事物隔离级别下执行特定 SQL 的加锁情况，在本篇文章中，我们将重点分析 MySQL InnoDB 默认的事务隔离级别 <strong>Repeatable Read</strong> 在执行特定 SQL 时的加锁情况。</p>
<span id="more"></span>

<h1 id="案例数据"><a href="#案例数据" class="headerlink" title="案例数据"></a>案例数据</h1><p>我们会从执行以下 SQL 语句开始，分析 Repeatable Read 隔离级别下的加锁情况。</p>
<table>
<thead>
<tr>
<th>SQL 语句</th>
</tr>
</thead>
<tbody><tr>
<td><code>SELECT * FROM table WHERE column = ?;</code></td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ?;</code></td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column = ? LOCK IN SHARE MODE;</code></td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ? LOCK IN SHARE MODE;</code></td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column = ? FOR UPDATE;</code></td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ? FOR UPDATE;</code></td>
</tr>
</tbody></table>
<p>下文事例都将基于表 <strong>employees</strong> 中的数据：</p>
<table>
<thead>
<tr>
<th>id（主键）</th>
<th>name（非索引）</th>
<th>employee_number<br>（唯一索引）</th>
<th>age（普通索引）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
<td>1001</td>
<td>30</td>
</tr>
<tr>
<td>5</td>
<td>Bob</td>
<td>1020</td>
<td>25</td>
</tr>
<tr>
<td>13</td>
<td>Charlie</td>
<td>1010</td>
<td>35</td>
</tr>
<tr>
<td>14</td>
<td>David</td>
<td>1035</td>
<td>25</td>
</tr>
<tr>
<td>25</td>
<td>Eve</td>
<td>1040</td>
<td>32</td>
</tr>
</tbody></table>
<h1 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read"></a>Repeatable Read</h1><table>
<thead>
<tr>
<th>SQL 语句</th>
<th>锁情况</th>
</tr>
</thead>
<tbody><tr>
<td><code>SELECT * FROM table WHERE column = ?;</code></td>
<td>不加锁</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ?;</code></td>
<td>不加锁</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column = ? LOCK IN SHARE MODE;</code></td>
<td>意向共享锁（IS）<br>和 行级共享锁（S）<br>或 临键锁（Next- Key Lock）<br>或 间隙锁（Gap Lock）</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ? LOCK IN SHARE MODE;</code></td>
<td>意向共享锁（IS）<br>和 行级共享锁（S）<br>或 临键锁（Next- Key Lock）<br>或 间隙锁（Gap Lock）</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column = ? FOR UPDATE;</code></td>
<td>意向排他锁（IX）<br>和 行级排他锁（X）<br>或 临键锁（Next-Key Lock）<br>或 间隙锁（Gap Lock）</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ? FOR UPDATE;</code></td>
<td>意向排他锁（IX）<br>和 行级排他锁（X）<br>或 临键锁（Next-Key Lock）<br>或 间隙锁（Gap Lock）</td>
</tr>
</tbody></table>
<p>可以看到 Repeatable Read 支持 Net-Key Lock 和 Gap Lock，并且不同的 WHERE 条件可能导致不同的加锁方案，查询条件 column 是否是索引、是否是唯一索引、查询的记录是否存在，都会影响加锁方案。接下来，我们会分析查询条件为聚簇索引、唯一索引、普通索引 和 非索引的情况下，对应的不同加锁方案。</p>
<h2 id="聚簇索引列查询"><a href="#聚簇索引列查询" class="headerlink" title="聚簇索引列查询"></a>聚簇索引列查询</h2><h3 id="等值查询"><a href="#等值查询" class="headerlink" title="等值查询"></a>等值查询</h3><h4 id="查询有记录"><a href="#查询有记录" class="headerlink" title="查询有记录"></a>查询有记录</h4><table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE id = 5 LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>UPDATE employees SET name = &#39;Robert&#39; WHERE id = 5;</code> <strong>(被阻塞，因事务A锁定记录)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 T1 的查询条件 id &#x3D; 5 记录存在，id 索引上首先会添加 Next-Key Lock，范围是（1, 5]，由于 id &#x3D; 5 的记录存在，并且 id 是唯一索引，Next-Key Lock 会退化为行记录锁，所以这里会添加<strong>行级共享锁 S 和 表级意向共享锁 IS，行级锁会添加在聚簇索引 id 上</strong>，事物 B 在 T6 尝试获取此行 id &#x3D; 5 的排他锁 X 导致冲突，操作被阻塞。</p>
<h4 id="查询无记录"><a href="#查询无记录" class="headerlink" title="查询无记录"></a>查询无记录</h4><table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE id = 2 LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>INSERT INTO employees (id, name, employee_number, age) VALUES (3, &#39;Frank&#39;, 1051, 30);</code> <strong>(被阻塞，因事务A的 Gap Lock)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 T1 的查询条件 id &#x3D; 2 的记录是不存在的，id 索引上首先会添加 Next-Key Lock，范围是（1, 5]，由于 id &#x3D; 5 的记录不存在，并且 id 是唯一索引，Next-Key Lock 会退化为 Gap Lock，所以这里会添加<strong>表级意向共享锁 IS 和 Gap Lock，Gap 的范围为（1, 5）</strong>，事物 B 在 T6 尝试插入 id &#x3D; 3 的记录导致冲突，操作被阻塞。</p>
<h3 id="范围查找"><a href="#范围查找" class="headerlink" title="范围查找"></a>范围查找</h3><table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE id &gt;= 5 AND id &lt; 32 LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>INSERT INTO employees (id, name, employee_number, age) VALUES (10, &#39;Frank&#39;, 1050, 30);</code> <strong>(阻塞)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 id 索引上首先会添加 Next-Key Lock，范围是 (1, 5]，(5, 13]，(13,14]，(14, 25]，(25, 32]，由于 id &#x3D; 5 的记录存在，并且 id 是唯一索引，最先被扫描到的 Next-Key Lock (1, 5] 会退化为行记录锁，由于 id &#x3D; 32 不满足 id &lt; 32，最后被扫描到的 Next-Key Lock (25, 32] 会退化为 Gap Lock，所以这里会添加<strong>表级意向共享锁 IS 、行级共享锁 S、 Gap Lock，Gap 的范围为(5, 13]，(13,14]，(14, 25]，(25, 32)，行级锁会被添加在 id &#x3D; 5 的记录上</strong>，事物 B 在 T6 尝试插入 id &#x3D; 10 的记录导致锁冲突，操作被阻塞。</p>
<table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE id &lt;= 13 LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>INSERT INTO employees (id, name, employee_number, age) VALUES (10, &#39;Frank&#39;, 1050, 30);</code> <strong>(阻塞)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 id 索引上首先会添加 Next-Key Lock，范围是 (-∞, 1]， (1, 5]，(5, 13] ，id &#x3D; 13 的记录存在，但这里的 (5, 13] 并不会退化为记录锁，所以这里会添加表级意向共享锁 IS、 Next-Key Lock，范围为 (-∞, 1]， (1, 5]，(5, 13]，事物 B 在 T6 尝试插入 id &#x3D; 10 的记录导致锁冲突，操作被阻塞。</p>
<h2 id="唯一索引列查询"><a href="#唯一索引列查询" class="headerlink" title="唯一索引列查询"></a>唯一索引列查询</h2><h3 id="等值查询-1"><a href="#等值查询-1" class="headerlink" title="等值查询"></a>等值查询</h3><h4 id="查询有记录-1"><a href="#查询有记录-1" class="headerlink" title="查询有记录"></a>查询有记录</h4><table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE employee_number = 1010 LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>UPDATE employees SET name = &#39;Robert&#39; WHERE id = 13;</code> <strong>(被阻塞，因事务A锁定记录)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 T3 的查询条件 employee_number &#x3D; 1010 的记录是存在的，employee_number 索引上首先会添加 Next-Key Lock，范围是（1001, 1010]，employee_number &#x3D; 1010 的记录存在，并且 employee_number 是唯一索引，Next-Key Lock 会退化为行记录锁，所以这里会添加<strong>行级共享锁 S 和 表级意向共享锁 IS，行级锁会添加在聚簇索引 id &#x3D; 13 和 唯一索引 employee_number &#x3D; 1010 上</strong>，事物 B 在 T6 尝试更新 id &#x3D; 13 的记录导致锁冲突，操作被阻塞。</p>
<h4 id="查询无记录-1"><a href="#查询无记录-1" class="headerlink" title="查询无记录"></a>查询无记录</h4><table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE employee_number = 1011 LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>INSERT INTO employees (id, name, employee_number, age) VALUES (6, ‘Robert’, 1012, 30);&#96; <br> <strong>(被阻塞，因事务A 的 Gap Lock)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 T3 的查询条件 employee_number &#x3D; 1011  的记录是不存在的，employee_number 索引上首先会添加 Next-Key Lock，范围是（1010, 1020]，employee_number &#x3D; 1011 的记录不存在，Next-Key Lock 会退化为 Gap Lock，所以这里会添加<strong>表级意向共享锁 IS 和 Gap Lock，Gap 的范围为（1010, 1020）</strong>，事物 B 在 T6 尝试插入 employee_number &#x3D; 1012 的记录导致冲突，操作被阻塞。</p>
<h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE employee_number &lt; 1011 LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>INSERT INTO employees (id, name, employee_number, age) VALUES (6, ‘Robert’, 1012, 30);&#96; <br> <strong>(被阻塞，因事务A 的 Gap Lock)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 employee_number 索引上首先会添加 Next-Key Lock，范围是 (-∞, 1001]， (1001, 1010]， (1010, 1020]， employee_number &#x3D; 1020 的记录不满足 employee_number &lt; 1011，Next-Key Lock (1010, 1020] 会退化为 Gap Lock，所以这里会添加**表级意向共享锁 IS、 Gap Lock，Gap 范围为 (-∞, 1001]， (1001, 1010] ， (1010, 1020)**，事物 B 在 T6 尝试插入 employee_number &#x3D; 1012 的记录导致锁冲突，操作被阻塞。</p>
<table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE employee_number &gt;= 1040 LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>UPDATE employees SET name = &#39;Robert&#39; WHERE id = 25;</code> <strong>(被阻塞，因事务A锁定记录)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 employee_number 索引上首先会添加 Next-Key Lock，范围是 (1035, 1040]， (1040, +∞]， employee_number &#x3D; 1040 的记录存在，并且 employee_number 是唯一索引，Next-Key Lock (1035, 1040] 会退化为行记录锁，所以这里会添加**行级共享锁 S、Next-Key Lock 和 表级意向共享锁 IS，行级锁会添加在聚簇索引 id &#x3D; 25 和 唯一索引 employee_number &#x3D; 1040 上，Next- Key Lock 范围为 (1040, +∞]**，事物 B 在 T6 尝试更新 id &#x3D; 25 的记录导致锁冲突，操作被阻塞。</p>
<h2 id="非唯一索引列查询"><a href="#非唯一索引列查询" class="headerlink" title="非唯一索引列查询"></a>非唯一索引列查询</h2><h3 id="等值查询-2"><a href="#等值查询-2" class="headerlink" title="等值查询"></a>等值查询</h3><h4 id="查询有记录-2"><a href="#查询有记录-2" class="headerlink" title="查询有记录"></a>查询有记录</h4><table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事物B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE age = 25 LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>INSERT INTO employees (name, employee_number, age) VALUES (&#39;Frank&#39;, 1050, 26);</code> <strong>(被阻塞，因事务A的 Gap Lock)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 age 索引上首先会添加 Next-Key Lock，范围是（<del>∞, 25]， 由于 age &#x3D; 25 的记录存在且 age 是非唯一索引，还需添加 Gap Lock（遍历至下一个不符合条件的 age 索引） 和 对应的行记录锁，所以这里会添加 Next-Key Lock 、 Gap Lock、行级共享锁 S 和 表级意向共享锁 IS，锁定 age &#x3D; 25 记录对应的 id &#x3D; 5 和 id &#x3D; 14 的聚簇索引记录，索引 age 上的 Next-Key Lock 范围为（</del>∞, 25]（age 并非唯一索引，所以这里的 Next-Key Lock 并不会退化为行记录锁），索引 age 上的 Gap Lock 范围为（25, 30）。事物 B 在 T6 尝试插入 age &#x3D; 26 的记录导致冲突，操作被阻塞。</p>
<h4 id="下边界插入"><a href="#下边界插入" class="headerlink" title="下边界插入"></a>下边界插入</h4><p>下边界如果是闭区间，则无法修改、删除，有机会插入成功，如果是开区间，则可以修改、删除，有机会插入成功。</p>
<table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE age = 25 LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>INSERT INTO employees (id, name, employee_number, age) VALUES (6, &#39;Frank&#39;, 1050, 30);</code> <strong>(插入成功)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>插入 age &#x3D; 30 的记录一定会成功嘛？不一定都会成功。</p>
<table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE age = 25 LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>INSERT INTO employees (id, name, employee_number, age) VALUES (0, &#39;Frank&#39;, 1050, 30);</code> <strong>(阻塞)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>我们来分析看看为什么事物 B 此时插入的记录被阻塞，上一条的插入却成功了。普通索引是有序存储的，当普通索引值相同时，则会按照聚簇（主键）索引排序，索引 age 的排序情况如下，括号表示事物 A 在 T3 操作添加的 Gap Lock 范围（25, 30）</p>
<table>
<thead>
<tr>
<th><strong>index age</strong></th>
<th>(25</th>
<th>25</th>
<th>30)</th>
<th>32</th>
<th>35</th>
</tr>
</thead>
<tbody><tr>
<td><strong>primary id</strong></td>
<td><strong>( 5</strong></td>
<td><strong>14</strong></td>
<td><strong>1 )</strong></td>
<td><strong>25</strong></td>
<td><strong>13</strong></td>
</tr>
</tbody></table>
<p>我们假设插入 age &#x3D; 30 和 id &#x3D; 0 可以成功，那么这条记录会在<strong>（25, 30）</strong>之间，所以操作是会阻塞的，索引 age 的排序情况应该如下：</p>
<table>
<thead>
<tr>
<th><strong>index age</strong></th>
<th>(25</th>
<th>25</th>
<th>30 ☆</th>
<th>30)</th>
<th>32</th>
<th>35</th>
</tr>
</thead>
<tbody><tr>
<td><strong>primary id</strong></td>
<td><strong>( 5</strong></td>
<td><strong>14</strong></td>
<td><strong>0 ☆</strong></td>
<td><strong>1 )</strong></td>
<td><strong>25</strong></td>
<td><strong>13</strong></td>
</tr>
</tbody></table>
<p>我们假设插入 age &#x3D; 30 和 id &#x3D; 6 可以成功，这条记录是在<strong>（25, 30）</strong>之外的，所以操作是可以成功的，索引 age 的排序情况应该如下：</p>
<table>
<thead>
<tr>
<th><strong>index age</strong></th>
<th>(25</th>
<th>25</th>
<th>30)</th>
<th>30 ☆</th>
<th>32</th>
<th>35</th>
</tr>
</thead>
<tbody><tr>
<td><strong>primary id</strong></td>
<td><strong>( 5</strong></td>
<td><strong>14</strong></td>
<td><strong>1 )</strong></td>
<td><strong>6 ☆</strong></td>
<td><strong>25</strong></td>
<td><strong>13</strong></td>
</tr>
</tbody></table>
<h4 id="上边界插入"><a href="#上边界插入" class="headerlink" title="上边界插入"></a>上边界插入</h4><p>与下边界规则相同</p>
<h4 id="查询无记录-2"><a href="#查询无记录-2" class="headerlink" title="查询无记录"></a>查询无记录</h4><table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE age = 27 LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>INSERT INTO employees (name, employee_number, age) VALUES (&#39;Frank&#39;, 1050, 26);</code> <strong>(被阻塞，因事务A的 Gap Lock)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 age 索引上首先会添加 Next-Key Lock，范围是（25, 30]，由于 age &#x3D; 27 的记录不存在，Next-Key Lock 会退化为 Gap Lock。所以这里会添加 <strong>表级意向共享锁 IS 和 Gap Lock ，索引 age 上的 Gap Lock 范围为（25, 30）</strong>，事物 B 在 T6 尝试插入 age &#x3D; 26 的记录导致冲突，操作被阻塞。</p>
<h3 id="范围查询-1"><a href="#范围查询-1" class="headerlink" title="范围查询"></a>范围查询</h3><table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE age &gt;= 25 AND age &lt; 30 LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>INSERT INTO employees (name, employee_number, age) VALUES (&#39;Frank&#39;, 1050, 26);</code> <strong>(被阻塞，因事务A的 Gap Lock)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>事物 A 在 age 索引上首先会添加 Next-Key Lock，范围是 (-∞, 25]， (25, 30]，由于 age 是非唯一索引，所以 Next-Key Lock 不会退化为 Gap Lock 和 行级锁，这里会添加**Next-Key Lock 和 表级意向共享锁 IS，Next- Key Lock 范围为 (-∞, 25]， (25, 30]**，事物 B 在 T6 尝试插入 age &#x3D; 26 的记录导致冲突，操作被阻塞。</p>
<h2 id="无索引列"><a href="#无索引列" class="headerlink" title="无索引列"></a>无索引列</h2><h3 id="等值查询-3"><a href="#等值查询-3" class="headerlink" title="等值查询"></a>等值查询</h3><h4 id="查询有记录-3"><a href="#查询有记录-3" class="headerlink" title="查询有记录"></a>查询有记录</h4><table>
<thead>
<tr>
<th><strong>时间线</strong></th>
<th><strong>事务A</strong></th>
<th><strong>事务B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td><code>START TRANSACTION;</code></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td><code>SELECT * FROM employees WHERE name = &#39;Bob&#39; LOCK IN SHARE MODE;</code></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><code>UPDATE employees SET name = &#39;Robert&#39; WHERE age = 25;</code> <strong>(阻塞)</strong></td>
</tr>
<tr>
<td>T7</td>
<td><code>COMMIT;</code> <strong>(事务A提交，释放锁)</strong></td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td><code>COMMIT;</code> <strong>(事务B提交)</strong></td>
</tr>
</tbody></table>
<p>事物 A 查询的 name &#x3D; ‘Bob’ 记录是存在的，由于 name 是非索引列，查询会进行全表扫描，所以这里会添加表级**意向共享锁 IS、行级共享锁 S、Next-Key Lock，锁定 id&#x3D;1、5、13、14、25 的聚簇索引记录，每行聚簇索引都会添加 Next-Key Lock，范围分别为 （-∞,1]、（1，5]、（5，13]、（13，14]、（14，25]、（25，+∞]**，整个表被锁住了，事物 B 的更新操作被阻塞。</p>
<h4 id="查询无记录-3"><a href="#查询无记录-3" class="headerlink" title="查询无记录"></a>查询无记录</h4><p>如果事物 A 查询的 name &#x3D; ‘ob’ 记录不存，由于 name 是非索引列，查询也会进行全表扫描，锁添加情况同 name &#x3D; ‘Bob’ 查询到记录的情况一致 。应该避免这种情况发生，这会严重降低整个系统的处理能力。</p>
<h3 id="范围查找-1"><a href="#范围查找-1" class="headerlink" title="范围查找"></a>范围查找</h3><p>同样会进行全部扫描，每行记录都会添加Next-Key Lock，最终锁住整个表。</p>
<h2 id="FOR-UPDATE"><a href="#FOR-UPDATE" class="headerlink" title="FOR UPDATE"></a>FOR UPDATE</h2><p><strong><strong>FOR UPDATE</strong></strong> 在不同列类型的查询条件下，锁定的记录与 <strong><strong>LOCK IN SHARE MODE</strong></strong> 一致，只是锁的类型变成了 IX 和 X。</p>
<h1 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h1><table>
<thead>
<tr>
<th>SQL 语句</th>
<th>锁情况</th>
</tr>
</thead>
<tbody><tr>
<td><code>SELECT * FROM table WHERE column = ?;</code></td>
<td>意向共享锁（IS）<br>和 行级共享锁（S）<br>或 临键锁（Next- Key Lock）<br>或 间隙锁（Gap Lock）</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ?;</code></td>
<td>意向共享锁（IS）<br>和 行级共享锁（S）<br>或 临键锁（Next- Key Lock）<br>或 间隙锁（Gap Lock）</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column = ? LOCK IN SHARE MODE;</code></td>
<td>意向共享锁（IS）<br>和 行级共享锁（S）<br>或 临键锁（Next- Key Lock）<br>或 间隙锁（Gap Lock）</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ? LOCK IN SHARE MODE;</code></td>
<td>意向共享锁（IS）<br>和 行级共享锁（S）<br>或 临键锁（Next- Key Lock）<br>或 间隙锁（Gap Lock）</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column = ? FOR UPDATE;</code></td>
<td>意向排他锁（IX）<br>和 行级排他锁（X）<br>或 临键锁（Next-Key Lock）<br>或 间隙锁（Gap Lock）</td>
</tr>
<tr>
<td><code>SELECT * FROM table WHERE column &lt; ? FOR UPDATE;</code></td>
<td>意向排他锁（IX）<br>和 行级排他锁（X）<br>或 临键锁（Next-Key Lock）<br>或 间隙锁（Gap Lock）</td>
</tr>
</tbody></table>
<p>在 Serializable 隔离级别下，普通查询与显示 LOCK IN SHARE MODE 查询相同，执行不同 SQL 语句下的加锁情况与在 Repeatable Read 隔离级别下类似。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>排序-快速排序（上）</title>
    <url>/2023/02/02/QuickSortOne/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/42.png" class="full-image" />

<p>快速排序算法由 <u><em><strong>TONY HOARE（1934-）</strong></em></u> 在1959年在莫斯科国立大学期间发明，于1961年发布于ACM算法存储库。霍尔的老板曾在工作中要求他实现希尔排序，霍尔认为他有比希尔排序更好的算法，为此他还和老板打赌了六便士，结果是霍尔赢了</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>快速排序是一种不稳定的交换排序算法，它利用分治的思想将一个大的问题分解为若干小问题，然后逐一击破小问题，从而高效的解决最终问题。算法的核心是如何分，常见的分区方案有：<em><strong>Lomuto partition</strong></em> 和 <em><strong>Hoare partition</strong></em>。本文使用的是 Hoare partition 方案</p>
<span id="more"></span>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><a href="https://www.bilibili.com/video/BV1TY4y147XF/?t=0h0m46s">这里有视频图例</a></p>
<ol>
<li>首先选择中间值（PIVOT） </li>
<li>以 PIVOT 分割成两部分（大于和小于）</li>
<li>对 PIVOT 两侧部分别重复1、2操作</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>使用Rust语言实现快速排序算法，Hoare partition 分区方案</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">_hoare_partition</span>&lt;T:<span class="built_in">Ord</span>&gt;(arr:&amp;<span class="keyword">mut</span>[T],lo:<span class="type">isize</span>,hi:<span class="type">isize</span>)<span class="punctuation">-&gt;</span>(<span class="type">isize</span>,<span class="type">isize</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pivot</span> = hi <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lt</span> = lo-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">gt</span> = hi;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        lt +=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> lt &lt;=hi &amp;&amp; arr[lt <span class="keyword">as</span> <span class="type">usize</span>] &lt; arr[pivot] &#123;</span><br><span class="line">            lt +=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gt -=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> gt &gt;=<span class="number">0</span> &amp;&amp; arr[gt <span class="keyword">as</span> <span class="type">usize</span>] &gt; arr[pivot] &#123;</span><br><span class="line">            gt -=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> lt &gt;=gt &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr.<span class="title function_ invoke__">swap</span>(lt <span class="keyword">as</span> <span class="type">usize</span>, gt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="title function_ invoke__">swap</span>(pivot, lt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    (lt-<span class="number">1</span>,lt+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">_quick_recursive</span>&lt;T:<span class="built_in">Ord</span>&gt;(arr:&amp;<span class="keyword">mut</span>[T],lo:<span class="type">isize</span>,hi:<span class="type">isize</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> lo &lt; hi &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">p</span> =_hoare_partition(arr, lo, hi);</span><br><span class="line">        _quick_recursive(arr, lo, p.<span class="number">0</span>);</span><br><span class="line">        _quick_recursive(arr, p.<span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">quick_sort</span>&lt;T:<span class="built_in">Ord</span>&gt;(arr:&amp;<span class="keyword">mut</span>[T])&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hi</span> = arr.<span class="title function_ invoke__">len</span>()-<span class="number">1</span>;</span><br><span class="line">    _quick_recursive(arr, <span class="number">0</span>, hi <span class="keyword">as</span> <span class="type">isize</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/quicksort/on.png" alt="image"></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>来看一组10W个相等整数排序算法的耗时比较</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/quicksort/cp.png" alt="image"></p>
<p>这种情况下快速排序甚至没有冒泡、插入排序快。这个问题会在 <a href="https://whathowhy.com/2023/02/02/QuickSortTwo/">排序-快速排序（下）</a>中优化解决</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ol>
<li>NULL引用的发明者是Tony Hoare</li>
<li>Tony Hoare 与 Edsger W. Dijkstra 一起提出了著名的<u><em><strong>哲学家就餐问题</strong></em></u></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort</a><br><a href="https://www.bilibili.com/video/BV1TY4y147XF">快速排序-上</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>If you put your mind to it, you can accomplish anything. - Doc Brown</p>
<p><a href="https://movie.douban.com/subject/1300555/">Back to the Future</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>排序-快速排序（下）</title>
    <url>/2023/02/02/QuickSortTwo/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/43.png" class="full-image" />

<p>本文主要针对 <a href="https://whathowhy.com/2023/02/02/QuickSortOne/">排序-快速排序（上）</a> 中的问题进行常见优化</p>
<blockquote>
<p>1。重复元素 2。PIVOT选择</p>
</blockquote>
<h1 id="重复元素"><a href="#重复元素" class="headerlink" title="重复元素"></a>重复元素</h1><p><a href="https://whathowhy.com/2023/02/02/QuickSortOne/">排序-快速排序（上）</a>中的快速排序实现，在重复元素情况下效果不佳</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/quicksort/cp.png" alt="image"></p>
<span id="more"></span>

<h2 id="Bentley-Mcilroy’s-3-way"><a href="#Bentley-Mcilroy’s-3-way" class="headerlink" title="Bentley-Mcilroy’s 3-way"></a>Bentley-Mcilroy’s 3-way</h2><p>使用 Bentley-Mcilroy’s 3-way 方式优化 Hoare partition 方案，<a href="https://www.bilibili.com/video/BV1rD4y1p73B/?t=0h0m31s">这里有视频图例</a>，代码实现</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">_hoare_partition</span>&lt;T:<span class="built_in">Ord</span>&gt;(arr:&amp;<span class="keyword">mut</span>[T],lo:<span class="type">isize</span>,hi:<span class="type">isize</span>)<span class="punctuation">-&gt;</span>(<span class="type">isize</span>,<span class="type">isize</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pivot</span> = hi <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lt</span> = lo-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">le_mid</span> = lo-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">gt</span> = hi;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">re_mid</span> = hi;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        lt +=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> lt &lt;=hi &amp;&amp; arr[lt <span class="keyword">as</span> <span class="type">usize</span>] &lt; arr[pivot] &#123;</span><br><span class="line">            lt +=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gt -=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> gt &gt;=<span class="number">0</span> &amp;&amp; arr[gt <span class="keyword">as</span> <span class="type">usize</span>] &gt; arr[pivot] &#123;</span><br><span class="line">            gt -=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> lt &gt;=gt &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr.<span class="title function_ invoke__">swap</span>(lt <span class="keyword">as</span> <span class="type">usize</span>, gt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        <span class="keyword">if</span> arr[lt <span class="keyword">as</span> <span class="type">usize</span>] == arr[pivot <span class="keyword">as</span> <span class="type">usize</span>] &#123;</span><br><span class="line">            le_mid +=<span class="number">1</span>;</span><br><span class="line">            arr.<span class="title function_ invoke__">swap</span>(le_mid <span class="keyword">as</span> <span class="type">usize</span>, lt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> arr[gt <span class="keyword">as</span> <span class="type">usize</span>] == arr[pivot <span class="keyword">as</span> <span class="type">usize</span>] &#123;</span><br><span class="line">            re_mid -=<span class="number">1</span>;</span><br><span class="line">            arr.<span class="title function_ invoke__">swap</span>(re_mid <span class="keyword">as</span> <span class="type">usize</span>,gt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="title function_ invoke__">swap</span>(pivot, lt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    lt = gt+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> lo..le_mid &#123;</span><br><span class="line">        arr.<span class="title function_ invoke__">swap</span>(i <span class="keyword">as</span> <span class="type">usize</span>,gt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        gt -=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> (re_mid+<span class="number">1</span>..hi).<span class="title function_ invoke__">rev</span>()&#123;</span><br><span class="line">        arr.<span class="title function_ invoke__">swap</span>(j <span class="keyword">as</span> <span class="type">usize</span>, lt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        lt +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (gt,lt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后的结果如下</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/quicksort/opt.png" alt="image"></p>
<h1 id="PIVOT选择"><a href="#PIVOT选择" class="headerlink" title="PIVOT选择"></a>PIVOT选择</h1><p>再来看一组10W个有序整数的排序算法耗时情况</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/quicksort/sorted.png" alt="image"></p>
<p>这种情况下快速排序也没有冒泡、插入排序快，同时也比希尔排序差</p>
<blockquote>
<p>PIVOT的选择通常有 1。中位数 2。Tukey’s Ninther 两种方式，文章选择 <u><em><strong>中位数</strong></em></u> 的方式进行选择实现</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">_hoare_partition</span>&lt;T:<span class="built_in">Ord</span>&gt;(arr:&amp;<span class="keyword">mut</span>[T],lo:<span class="type">isize</span>,hi:<span class="type">isize</span>)<span class="punctuation">-&gt;</span>(<span class="type">isize</span>,<span class="type">isize</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pivot</span> = hi <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mid</span> = _median(arr, lo, hi);</span><br><span class="line">    arr.<span class="title function_ invoke__">swap</span>(hi <span class="keyword">as</span> <span class="type">usize</span>, mid <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lt</span> = lo-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">le_mid</span> = lo-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">gt</span> = hi;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">re_mid</span> = hi;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        lt +=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> lt &lt;=hi &amp;&amp; arr[lt <span class="keyword">as</span> <span class="type">usize</span>] &lt; arr[pivot] &#123;</span><br><span class="line">            lt +=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gt -=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> gt &gt;=<span class="number">0</span> &amp;&amp; arr[gt <span class="keyword">as</span> <span class="type">usize</span>] &gt; arr[pivot] &#123;</span><br><span class="line">            gt -=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> lt &gt;=gt &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr.<span class="title function_ invoke__">swap</span>(lt <span class="keyword">as</span> <span class="type">usize</span>, gt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        <span class="keyword">if</span> arr[lt <span class="keyword">as</span> <span class="type">usize</span>] == arr[pivot <span class="keyword">as</span> <span class="type">usize</span>] &#123;</span><br><span class="line">            le_mid +=<span class="number">1</span>;</span><br><span class="line">            arr.<span class="title function_ invoke__">swap</span>(le_mid <span class="keyword">as</span> <span class="type">usize</span>, lt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> arr[gt <span class="keyword">as</span> <span class="type">usize</span>] == arr[pivot <span class="keyword">as</span> <span class="type">usize</span>] &#123;</span><br><span class="line">            re_mid -=<span class="number">1</span>;</span><br><span class="line">            arr.<span class="title function_ invoke__">swap</span>(re_mid <span class="keyword">as</span> <span class="type">usize</span>,gt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="title function_ invoke__">swap</span>(pivot, lt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    lt = gt+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> lo..le_mid &#123;</span><br><span class="line">        arr.<span class="title function_ invoke__">swap</span>(i <span class="keyword">as</span> <span class="type">usize</span>,gt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        gt -=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> (re_mid+<span class="number">1</span>..hi).<span class="title function_ invoke__">rev</span>()&#123;</span><br><span class="line">        arr.<span class="title function_ invoke__">swap</span>(j <span class="keyword">as</span> <span class="type">usize</span>, lt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        lt +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (gt,lt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">_median</span>&lt;T:<span class="built_in">Ord</span>&gt;(arr:&amp;<span class="keyword">mut</span>[T],lo:<span class="type">isize</span>,hi:<span class="type">isize</span>)<span class="punctuation">-&gt;</span><span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mid</span> = lo+(hi-lo+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = &amp;arr[lo <span class="keyword">as</span> <span class="type">usize</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">middle</span> = &amp;arr[mid <span class="keyword">as</span> <span class="type">usize</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">last</span> = &amp;arr[hi <span class="keyword">as</span> <span class="type">usize</span>];</span><br><span class="line">    <span class="keyword">if</span> first &gt; middle &#123;</span><br><span class="line">        <span class="keyword">if</span> middle &gt; last &#123;</span><br><span class="line">            mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> first &lt; last &#123;</span><br><span class="line">            lo</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> middle &lt; last &#123;</span><br><span class="line">            mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> first &gt; last &#123;</span><br><span class="line">            lo</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后的结果如下<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/quicksort/pivotopt.png" alt="image"></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>快速排序完整代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">_hoare_partition</span>&lt;T:<span class="built_in">Ord</span>&gt;(arr:&amp;<span class="keyword">mut</span>[T],lo:<span class="type">isize</span>,hi:<span class="type">isize</span>)<span class="punctuation">-&gt;</span>(<span class="type">isize</span>,<span class="type">isize</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pivot</span> = hi <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mid</span> = _median(arr, lo, hi);</span><br><span class="line">    arr.<span class="title function_ invoke__">swap</span>(hi <span class="keyword">as</span> <span class="type">usize</span>, mid <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lt</span> = lo-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">le_mid</span> = lo-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">gt</span> = hi;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">re_mid</span> = hi;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        lt +=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> lt &lt;=hi &amp;&amp; arr[lt <span class="keyword">as</span> <span class="type">usize</span>] &lt; arr[pivot] &#123;</span><br><span class="line">            lt +=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gt -=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> gt &gt;=<span class="number">0</span> &amp;&amp; arr[gt <span class="keyword">as</span> <span class="type">usize</span>] &gt; arr[pivot] &#123;</span><br><span class="line">            gt -=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> lt &gt;=gt &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr.<span class="title function_ invoke__">swap</span>(lt <span class="keyword">as</span> <span class="type">usize</span>, gt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        <span class="keyword">if</span> arr[lt <span class="keyword">as</span> <span class="type">usize</span>] == arr[pivot <span class="keyword">as</span> <span class="type">usize</span>] &#123;</span><br><span class="line">            le_mid +=<span class="number">1</span>;</span><br><span class="line">            arr.<span class="title function_ invoke__">swap</span>(le_mid <span class="keyword">as</span> <span class="type">usize</span>, lt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> arr[gt <span class="keyword">as</span> <span class="type">usize</span>] == arr[pivot <span class="keyword">as</span> <span class="type">usize</span>] &#123;</span><br><span class="line">            re_mid -=<span class="number">1</span>;</span><br><span class="line">            arr.<span class="title function_ invoke__">swap</span>(re_mid <span class="keyword">as</span> <span class="type">usize</span>,gt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="title function_ invoke__">swap</span>(pivot, lt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    lt = gt+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> lo..le_mid &#123;</span><br><span class="line">        arr.<span class="title function_ invoke__">swap</span>(i <span class="keyword">as</span> <span class="type">usize</span>,gt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        gt -=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> (re_mid+<span class="number">1</span>..hi).<span class="title function_ invoke__">rev</span>()&#123;</span><br><span class="line">        arr.<span class="title function_ invoke__">swap</span>(j <span class="keyword">as</span> <span class="type">usize</span>, lt <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        lt +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (gt,lt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">_quick_recursive</span>&lt;T:<span class="built_in">Ord</span>&gt;(arr:&amp;<span class="keyword">mut</span>[T],lo:<span class="type">isize</span>,hi:<span class="type">isize</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> lo &lt; hi &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">p</span> =_hoare_partition(arr, lo, hi);</span><br><span class="line">        _quick_recursive(arr, lo, p.<span class="number">0</span>);</span><br><span class="line">        _quick_recursive(arr, p.<span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">quick_sort</span>&lt;T:<span class="built_in">Ord</span>&gt;(arr:&amp;<span class="keyword">mut</span>[T])&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hi</span> = arr.<span class="title function_ invoke__">len</span>()-<span class="number">1</span>;</span><br><span class="line">    _quick_recursive(arr, <span class="number">0</span>, hi <span class="keyword">as</span> <span class="type">isize</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">_median</span>&lt;T:<span class="built_in">Ord</span>&gt;(arr:&amp;<span class="keyword">mut</span>[T],lo:<span class="type">isize</span>,hi:<span class="type">isize</span>)<span class="punctuation">-&gt;</span><span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mid</span> = lo+(hi-lo+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = &amp;arr[lo <span class="keyword">as</span> <span class="type">usize</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">middle</span> = &amp;arr[mid <span class="keyword">as</span> <span class="type">usize</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">last</span> = &amp;arr[hi <span class="keyword">as</span> <span class="type">usize</span>];</span><br><span class="line">    <span class="keyword">if</span> first &gt; middle &#123;</span><br><span class="line">        <span class="keyword">if</span> middle &gt; last &#123;</span><br><span class="line">            mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> first &lt; last &#123;</span><br><span class="line">            lo</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> middle &lt; last &#123;</span><br><span class="line">            mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> first &gt; last &#123;</span><br><span class="line">            lo</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort</a><br><a href="https://www.bilibili.com/video/BV1rD4y1p73B">快速排序-下</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>All those moments will be lost in time, like tears in rain. - Roy Batty</p>
<p><a href="https://movie.douban.com/subject/1291839/">Blade Runner</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Cluster</title>
    <url>/2023/03/29/RedisCluster/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/54.png" class="full-image" />

<p>Redis Cluster 是 Redis 的分布式解决方案，它使用哈希槽分片技术将数据分散到不同的 Redis 节点中，实现数据的水平扩展，从而提高系统性能与吞吐量。Redis Cluster 支持主从复制和故障转移，当主节点发生故障时，从节点可以继续为系统提供服务，保证系统的高可用性。Redis Cluster 支持数据自动迁移，可以在节点的新增和删除时，进行数据的自动迁移，并且操作十分简单。在本篇文章中，我们将搭建一个 3主3从 的 Redis Cluster，并演示集群中的基本操作</p>
<span id="more"></span>

<h1 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h1><p>我们使用 Docker 来搭建 Redis 集群</p>
<h2 id="创建-Redis-实例"><a href="#创建-Redis-实例" class="headerlink" title="创建 Redis 实例"></a>创建 Redis 实例</h2><p>创建6个 Redis 实例，并且要求容器之间可以通过服务名称进行网络通信</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker network create -d bridge redis-cluster-net</span><br><span class="line"></span><br><span class="line">docker run -itd --name redis-node-1 --net=redis-cluster-net -v ~/data/redis/cluster/redis-node-1:/data redis --cluster-enabled yes --appendonly yes</span><br><span class="line"></span><br><span class="line">docker run -itd --name redis-node-2 --net=redis-cluster-net -v ~/data/redis/cluster/redis-node-2:/data redis --cluster-enabled yes --appendonly yes</span><br><span class="line"></span><br><span class="line">docker run -itd --name redis-node-3 --net=redis-cluster-net -v ~/data/redis/cluster/redis-node-3:/data redis --cluster-enabled yes --appendonly yes</span><br><span class="line"></span><br><span class="line">docker run -itd --name redis-node-4 --net=redis-cluster-net -v ~/data/redis/cluster/redis-node-4:/data redis --cluster-enabled yes --appendonly yes</span><br><span class="line"></span><br><span class="line">docker run -itd --name redis-node-5 --net=redis-cluster-net -v ~/data/redis/cluster/redis-node-5:/data redis --cluster-enabled yes --appendonly yes</span><br><span class="line"></span><br><span class="line">docker run -itd --name redis-node-6 --net=redis-cluster-net -v ~/data/redis/cluster/redis-node-6:/data redis --cluster-enabled yes --appendonly yes</span><br></pre></td></tr></table></figure>

<h2 id="构建集群节点"><a href="#构建集群节点" class="headerlink" title="构建集群节点"></a>构建集群节点</h2><p>开始构建集群，这里我们使用 redis-node-1 作为操作入口</p>
<ol>
<li>进入 redis-node-1 容器内</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it redis-node-1 /bin/sh</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建集群节点</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create redis-node-1:6379 redis-node-2:6379 redis-node-3:6379 redis-node-4:6379 redis-node-5:6379 redis-node-6:6379 --cluster-replicas 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica redis-node-5:6379 to redis-node-1:6379</span><br><span class="line">Adding replica redis-node-6:6379 to redis-node-2:6379</span><br><span class="line">Adding replica redis-node-4:6379 to redis-node-3:6379</span><br><span class="line">M: 6d088a123c9054e680bb679a4a90dd096c5d6f13 redis-node-1:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 redis-node-2:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 redis-node-3:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d redis-node-4:6379</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">S: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea redis-node-5:6379</span><br><span class="line">   replicates 6d088a123c9054e680bb679a4a90dd096c5d6f13</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 redis-node-6:6379</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line"></span><br><span class="line">   Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes # 这里确认配置</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER MEET messages to <span class="built_in">join</span> the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node redis-node-1:6379)</span></span><br><span class="line">M: 6d088a123c9054e680bb679a4a90dd096c5d6f13 redis-node-1:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">S: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea 172.18.0.5:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 6d088a123c9054e680bb679a4a90dd096c5d6f13</span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查看集群状况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -c #集群客服端进入 </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; cluster info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:479</span><br><span class="line">cluster_stats_messages_pong_sent:524</span><br><span class="line">cluster_stats_messages_sent:1003</span><br><span class="line">cluster_stats_messages_ping_received:519</span><br><span class="line">cluster_stats_messages_pong_received:479</span><br><span class="line">cluster_stats_messages_meet_received:5</span><br><span class="line">cluster_stats_messages_received:1003</span><br><span class="line">total_cluster_links_buffer_limit_exceeded:0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379@16379 slave dc2b88c5dd76c479639a428dbb2a57a34be919e3 0 1680019648000 2 connected</span><br><span class="line">6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379@16379 slave 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 0 1680019647583 3 connected</span><br><span class="line">6d088a123c9054e680bb679a4a90dd096c5d6f13 172.18.0.7:6379@16379 myself,master - 0 1680019649000 1 connected 0-5460</span><br><span class="line">42afc0262d0ebdce755aa1a61e12d70b80ffa9ea 172.18.0.5:6379@16379 slave 6d088a123c9054e680bb679a4a90dd096c5d6f13 0 1680019648626 1 connected</span><br><span class="line">dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379@16379 master - 0 1680019649670 2 connected 5461-10922</span><br><span class="line">7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379@16379 master - 0 1680019648000 3 connected 10923-16383</span><br></pre></td></tr></table></figure>

<p>通过集群信息，我们可以得出当前集群节点的关系分布图</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/redis/cluster.png" alt="imag"></p>
<ol start="4">
<li>指令操作测试</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -c #集群客服端进入 </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [12706] located at 172.18.0.3:6379</span></span><br><span class="line">OK</span><br><span class="line">172.18.0.3:6379&gt; </span><br><span class="line"></span><br><span class="line">172.18.0.3:6379&gt; set k2 v2</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [449] located at 172.18.0.7:6379</span></span><br><span class="line">OK</span><br><span class="line">172.18.0.7:6379&gt; set k3 v3</span><br><span class="line">OK</span><br><span class="line">172.18.0.7:6379&gt; </span><br></pre></td></tr></table></figure>

<ol start="5">
<li>检查 KEY 情况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check redis-node-1:6379 # 集群检查</span><br><span class="line"></span><br><span class="line">redis-node-1:6379 (6d088a12...) -&gt; 2 keys | 5461 slots | 1 slaves.</span><br><span class="line">172.18.0.2:6379 (dc2b88c5...) -&gt; 0 keys | 5462 slots | 1 slaves.</span><br><span class="line">172.18.0.3:6379 (7dceb962...) -&gt; 1 keys | 5461 slots | 1 slaves.</span><br><span class="line">[OK] 3 keys in 3 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node redis-node-1:6379)</span></span><br><span class="line">M: 6d088a123c9054e680bb679a4a90dd096c5d6f13 redis-node-1:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">S: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea 172.18.0.5:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 6d088a123c9054e680bb679a4a90dd096c5d6f13</span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<h1 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h1><p>前面我们搭建了 3主3从 的 Redis 集群，我们来测试一下当集群中某一个 master 节点宕机后，集群中会有什么变化</p>
<ol>
<li>停止 master 节点 redis-node-1</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop redis-node-1 # 停止 redis-node-1</span><br><span class="line"></span><br><span class="line">docker exec -it redis-node-2 /bin/sh # 通过 redis-node-2 与集群交互</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379@16379 master - 0 1680021042893 3 connected 10923-16383</span><br><span class="line">dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379@16379 myself,master - 0 1680021038000 2 connected 5461-10922</span><br><span class="line">42afc0262d0ebdce755aa1a61e12d70b80ffa9ea 172.18.0.5:6379@16379 master - 0 1680021042000 7 connected 0-5460</span><br><span class="line">4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379@16379 slave dc2b88c5dd76c479639a428dbb2a57a34be919e3 0 1680021040000 2 connected</span><br><span class="line">6d088a123c9054e680bb679a4a90dd096c5d6f13 172.18.0.7:6379@16379 master,fail - 1680020721097 1680020718000 1 connected</span><br><span class="line">6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379@16379 slave 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 0 1680021041000 3 connected</span><br></pre></td></tr></table></figure>
<p>可以发现当我们停止 redis-node-1 后，从节点 redis-node-5 会升级为 master 节点</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/redis/failover.png" alt="imag"></p>
<ol start="2">
<li>检查 KEY 情况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check redis-node-2:6379</span><br><span class="line"></span><br><span class="line">Could not connect to Redis at 172.18.0.7:6379: No route to host</span><br><span class="line">redis-node-2:6379 (dc2b88c5...) -&gt; 0 keys | 5462 slots | 1 slaves.</span><br><span class="line">172.18.0.3:6379 (7dceb962...) -&gt; 1 keys | 5461 slots | 1 slaves.</span><br><span class="line">172.18.0.5:6379 (42afc026...) -&gt; 2 keys | 5461 slots | 0 slaves.    # KEY 数量正确</span><br><span class="line">[OK] 3 keys in 3 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node redis-node-2:6379)</span></span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 redis-node-2:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea 172.18.0.5:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>当我们再次启动 redis-node-1 后，redis-node-1 会变为 redis-node-5 的从节点</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/redis/master_change.png" alt="imag"></p>
<ul>
<li>如果集群中的主从节点同时宕机，那么在恢复的时候需要先启动 master，然后再启动 slave</li>
</ul>
<h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p>假设我们的服务遇到了流量高峰，现在需要将 Redis Cluster 扩容至 4主4从，Redis Cluster 的扩容非常简单，我们来试试看该如何扩容</p>
<ol>
<li>新建2个 Redis 实例</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name redis-node-7 --net=redis-cluster-net -v ~/data/redis/cluster/redis-node-7:/data redis --cluster-enabled yes --appendonly yes</span><br><span class="line"></span><br><span class="line">docker run -itd --name redis-node-8 --net=redis-cluster-net -v ~/data/redis/cluster/redis-node-8:/data redis --cluster-enabled yes --appendonly yes</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新 redis-node-7 以 master 节点加入集群</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it redis-node-7 /bin/sh</span><br><span class="line"></span><br><span class="line">redis-cli --cluster add-node redis-node-7:6379 redis-node-5:6379 # 通过 redis-node-5 与集群交互</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Adding node redis-node-7:6379 to cluster redis-node-5:6379</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node redis-node-5:6379)</span></span><br><span class="line">M: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea redis-node-5:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 6d088a123c9054e680bb679a4a90dd096c5d6f13 172.18.0.7:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea</span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Getting <span class="built_in">functions</span> from cluster</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Send FUNCTION LIST to redis-node-7:6379 to verify there is no <span class="built_in">functions</span> <span class="keyword">in</span> it</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Send FUNCTION RESTORE to redis-node-7:6379</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Send CLUSTER MEET to node redis-node-7:6379 to make it <span class="built_in">join</span> the cluster.</span></span><br><span class="line">[OK] New node added correctly.</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>集群检查</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check redis-node-5:6379 # 检查集群情况</span><br><span class="line"></span><br><span class="line">redis-node-5:6379 (42afc026...) -&gt; 2 keys | 5461 slots | 1 slaves.</span><br><span class="line">172.18.0.3:6379 (7dceb962...) -&gt; 1 keys | 5461 slots | 1 slaves.</span><br><span class="line">172.18.0.8:6379 (a26bb6fb...) -&gt; 0 keys | 0 slots | 0 slaves.     # 新加入集群的 master 节点，此时为空槽</span><br><span class="line">172.18.0.2:6379 (dc2b88c5...) -&gt; 0 keys | 5462 slots | 1 slaves.</span><br><span class="line">[OK] 3 keys in 4 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node redis-node-5:6379)</span></span><br><span class="line">M: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea redis-node-5:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: a26bb6fbc64644a4807c13d692247510e10815ff 172.18.0.8:6379</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">S: 6d088a123c9054e680bb679a4a90dd096c5d6f13 172.18.0.7:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea</span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>为新加入的 master 节点分配槽位</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard redis-node-5:6379 # 通过 redis-node-5 与集群交互</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node redis-node-5:6379)</span></span><br><span class="line">M: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea redis-node-5:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: a26bb6fbc64644a4807c13d692247510e10815ff 172.18.0.8:6379 # 新加入的 master 节点</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">S: 6d088a123c9054e680bb679a4a90dd096c5d6f13 172.18.0.7:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea</span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots do you want to move (from 1 to 16384)? </span><br><span class="line"></span><br><span class="line">How many slots do you want to move (from 1 to 16384)? 4096 # 这里我们选择平均分配槽号（16384/4 = 4096）</span><br><span class="line">What is the receiving node ID? a26bb6fbc64644a4807c13d692247510e10815ff # 新加入的 master 节点 ID</span><br><span class="line">Please enter all the source node IDs.</span><br><span class="line">  Type &#x27;all&#x27; to use all the nodes as source nodes for the hash slots.</span><br><span class="line">  Type &#x27;done&#x27; once you entered all the source nodes IDs.</span><br><span class="line">Source node #1: all</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>查看新 master 节点集群状况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check redis-node-5:6379 # 通过 redis-node-5 与集群交互</span><br><span class="line"></span><br><span class="line">redis-node-5:6379 (42afc026...) -&gt; 1 keys | 4096 slots | 1 slaves.</span><br><span class="line">172.18.0.3:6379 (7dceb962...) -&gt; 1 keys | 4096 slots | 1 slaves.</span><br><span class="line">172.18.0.8:6379 (a26bb6fb...) -&gt; 1 keys | 4096 slots | 0 slaves.  # 可以看到 redis-node-5 其中的一个 KEY 分配给了新加入的 master 节点</span><br><span class="line">172.18.0.2:6379 (dc2b88c5...) -&gt; 0 keys | 4096 slots | 1 slaves.</span><br><span class="line">[OK] 3 keys in 4 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node redis-node-5:6379)</span></span><br><span class="line">M: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea redis-node-5:6379</span><br><span class="line">   slots:[1365-5460] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379</span><br><span class="line">   slots:[12288-16383] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: a26bb6fbc64644a4807c13d692247510e10815ff 172.18.0.8:6379</span><br><span class="line">   slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master   # 新加入的 master 节点，槽位分配完成</span><br><span class="line">S: 6d088a123c9054e680bb679a4a90dd096c5d6f13 172.18.0.7:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea</span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379</span><br><span class="line">   slots:[6827-10922] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>新 master 节点 redis-node-8 加入集群后的槽位分布</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/redis/newslot.png" alt="imag"></p>
<ol start="6">
<li>从节点 redis-node-8 加入集群</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node redis-node-8:6379 redis-node-7:6379 --cluster-slave --cluster-master-id a26bb6fbc64644a4807c13d692247510e10815ff</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Adding node redis-node-8:6379 to cluster redis-node-7:6379</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node redis-node-7:6379)</span></span><br><span class="line">M: a26bb6fbc64644a4807c13d692247510e10815ff redis-node-7:6379</span><br><span class="line">   slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master</span><br><span class="line">M: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea 172.18.0.5:6379</span><br><span class="line">   slots:[1365-5460] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379</span><br><span class="line">   slots:[6827-10922] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 6d088a123c9054e680bb679a4a90dd096c5d6f13 172.18.0.7:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379</span><br><span class="line">   slots:[12288-16383] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Send CLUSTER MEET to node redis-node-8:6379 to make it <span class="built_in">join</span> the cluster.</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Configure node as replica of redis-node-7:6379.</span></span><br><span class="line">[OK] New node added correctly.</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>查看新 slave 节点集群状况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check redis-node-5:6379</span><br><span class="line"></span><br><span class="line">redis-node-5:6379 (42afc026...) -&gt; 1 keys | 4096 slots | 1 slaves.</span><br><span class="line">172.18.0.3:6379 (7dceb962...) -&gt; 1 keys | 4096 slots | 1 slaves.</span><br><span class="line">172.18.0.8:6379 (a26bb6fb...) -&gt; 1 keys | 4096 slots | 1 slaves.  # redis-node-7 的从节点加入成功</span><br><span class="line">172.18.0.2:6379 (dc2b88c5...) -&gt; 0 keys | 4096 slots | 1 slaves.</span><br><span class="line">[OK] 3 keys in 4 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node redis-node-5:6379)</span></span><br><span class="line">M: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea redis-node-5:6379</span><br><span class="line">   slots:[1365-5460] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">S: bd3887b976a2d52d3dc70a1ad4d5f6045f08a021 172.18.0.9:6379 # 新加入的从节点</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates a26bb6fbc64644a4807c13d692247510e10815ff</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379</span><br><span class="line">   slots:[12288-16383] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: a26bb6fbc64644a4807c13d692247510e10815ff 172.18.0.8:6379</span><br><span class="line">   slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 6d088a123c9054e680bb679a4a90dd096c5d6f13 172.18.0.7:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea</span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379</span><br><span class="line">   slots:[6827-10922] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>扩容后的集群节点分布情况</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/redis/newcluster.png" alt="imag"></p>
<h1 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h1><p>假设我们的服务过了流量高峰期，现在需要将 Redis Cluster 缩容至 3主3从，Redis Cluster 的缩容也非常简单，我们来试试看该如何缩容</p>
<ol>
<li>先缩容 slave 节点 redis-node-8</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster del-node redis-node-8:6379 bd3887b976a2d52d3dc70a1ad4d5f6045f08a021</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Removing node bd3887b976a2d52d3dc70a1ad4d5f6045f08a021 from cluster redis-node-8:6379</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER RESET SOFT to the deleted node.</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>集群检查</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check redis-node-5:6379</span><br><span class="line"></span><br><span class="line">redis-node-5:6379 (42afc026...) -&gt; 1 keys | 4096 slots | 1 slaves.</span><br><span class="line">172.18.0.3:6379 (7dceb962...) -&gt; 1 keys | 4096 slots | 1 slaves.</span><br><span class="line">172.18.0.8:6379 (a26bb6fb...) -&gt; 1 keys | 4096 slots | 0 slaves.  # 从节点 redis-node-8 不见了</span><br><span class="line">172.18.0.2:6379 (dc2b88c5...) -&gt; 0 keys | 4096 slots | 1 slaves.</span><br><span class="line">[OK] 3 keys in 4 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node redis-node-5:6379)</span></span><br><span class="line">M: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea redis-node-5:6379</span><br><span class="line">   slots:[1365-5460] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379</span><br><span class="line">   slots:[12288-16383] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: a26bb6fbc64644a4807c13d692247510e10815ff 172.18.0.8:6379</span><br><span class="line">   slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master</span><br><span class="line">S: 6d088a123c9054e680bb679a4a90dd096c5d6f13 172.18.0.7:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea</span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379</span><br><span class="line">   slots:[6827-10922] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/redis/delete_slave.png" alt="imag"></p>
<ol start="3">
<li>将 master 节点 redis-node-7 槽清空</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard redis-node-5:6379</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node redis-node-5:6379)</span></span><br><span class="line">M: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea redis-node-5:6379</span><br><span class="line">   slots:[1365-5460] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379</span><br><span class="line">   slots:[12288-16383] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: a26bb6fbc64644a4807c13d692247510e10815ff 172.18.0.8:6379</span><br><span class="line">   slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master</span><br><span class="line">S: 6d088a123c9054e680bb679a4a90dd096c5d6f13 172.18.0.7:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea</span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379</span><br><span class="line">   slots:[6827-10922] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots do you want to move (from 1 to 16384)? </span><br><span class="line"></span><br><span class="line">How many slots do you want to move (from 1 to 16384)? 4096  # 清空 redis-node-7 中的 4096 个槽位</span><br><span class="line">What is the receiving node ID? dc2b88c5dd76c479639a428dbb2a57a34be919e3 # 指定哪个节点接收 redis-node-7 中槽位，这里选择 redis-node-2</span><br><span class="line">Please enter all the source node IDs.</span><br><span class="line">  Type &#x27;all&#x27; to use all the nodes as source nodes for the hash slots.</span><br><span class="line">  Type &#x27;done&#x27; once you entered all the source nodes IDs.</span><br><span class="line">Source node #1: a26bb6fbc64644a4807c13d692247510e10815ff # redis-node-7 的集群 ID</span><br><span class="line">Source node #2: done</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>集群中 KEY 情况检查</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check redis-node-5:6379</span><br><span class="line"></span><br><span class="line">redis-node-5:6379 (42afc026...) -&gt; 1 keys | 4096 slots | 1 slaves.</span><br><span class="line">172.18.0.3:6379 (7dceb962...) -&gt; 1 keys | 4096 slots | 1 slaves.</span><br><span class="line">172.18.0.2:6379 (dc2b88c5...) -&gt; 1 keys | 8192 slots | 2 slaves.  # redis-node-7 中的 KEY 转移到 redis-node-2 中了</span><br><span class="line">[OK] 3 keys in 3 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node redis-node-5:6379)</span></span><br><span class="line">M: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea redis-node-5:6379</span><br><span class="line">   slots:[1365-5460] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379</span><br><span class="line">   slots:[12288-16383] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: a26bb6fbc64644a4807c13d692247510e10815ff 172.18.0.8:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">S: 6d088a123c9054e680bb679a4a90dd096c5d6f13 172.18.0.7:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea</span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379</span><br><span class="line">   slots:[0-1364],[5461-12287] (8192 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/redis/delete_master_slot.png" alt="imag"></p>
<ol start="5">
<li>删除 master 节点 redis-node-7</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster del-node redis-node-7:6379 a26bb6fbc64644a4807c13d692247510e10815ff</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Removing node a26bb6fbc64644a4807c13d692247510e10815ff from cluster redis-node-7:6379</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER RESET SOFT to the deleted node.</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>集群检查</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check redis-node-5:6379</span><br><span class="line"></span><br><span class="line">redis-node-5:6379 (42afc026...) -&gt; 1 keys | 4096 slots | 1 slaves.</span><br><span class="line">172.18.0.3:6379 (7dceb962...) -&gt; 1 keys | 4096 slots | 1 slaves.</span><br><span class="line">172.18.0.2:6379 (dc2b88c5...) -&gt; 1 keys | 8192 slots | 1 slaves.</span><br><span class="line">[OK] 3 keys in 3 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node redis-node-5:6379)</span></span><br><span class="line">M: 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea redis-node-5:6379</span><br><span class="line">   slots:[1365-5460] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 4e95919b1382d9576e11c93be686240d5d639e32 172.18.0.6:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates dc2b88c5dd76c479639a428dbb2a57a34be919e3</span><br><span class="line">M: 7dceb96259a1e2eeece5a15e33250ffcde71aaf0 172.18.0.3:6379</span><br><span class="line">   slots:[12288-16383] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 6d088a123c9054e680bb679a4a90dd096c5d6f13 172.18.0.7:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 42afc0262d0ebdce755aa1a61e12d70b80ffa9ea</span><br><span class="line">M: dc2b88c5dd76c479639a428dbb2a57a34be919e3 172.18.0.2:6379</span><br><span class="line">   slots:[0-1364],[5461-12287] (8192 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 6aaae0c14c2a7bf2517659ff6a2530400b40968d 172.18.0.4:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7dceb96259a1e2eeece5a15e33250ffcde71aaf0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>缩容后的最新槽位分布情况</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/redis/reshard_cluster.png" alt="imag"></p>
<h1 id="MULTIPLE-KEYS"><a href="#MULTIPLE-KEYS" class="headerlink" title="MULTIPLE KEYS"></a>MULTIPLE KEYS</h1><p>一个命令同时操作多个 KEY 的情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">172.18.0.5:6379&gt; mget k1 k2</span><br><span class="line">(error) CROSSSLOT Keys in request don&#x27;t hash to the same slot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行错误，因为 k1 与 k2 分布在不同的槽位上</span></span><br><span class="line"></span><br><span class="line">172.18.0.5:6379&gt; get k1</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [12706] located at 172.18.0.3:6379</span></span><br><span class="line">&quot;v1&quot;</span><br><span class="line"></span><br><span class="line">172.18.0.3:6379&gt; get k2</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [449] located at 172.18.0.2:6379</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以通过 hashtag 将一组相关联的数据存储到同一个槽位中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">172.18.0.2:6379&gt; del k1</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [12706] located at 172.18.0.3:6379</span></span><br><span class="line">(integer) 1</span><br><span class="line">172.18.0.3:6379&gt; del k2</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [449] located at 172.18.0.2:6379</span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">172.18.0.2:6379&gt; set &#123;user.100&#125;.k1 v1</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [13578] located at 172.18.0.3:6379</span></span><br><span class="line">OK</span><br><span class="line">172.18.0.3:6379&gt; set &#123;user.100&#125;.k2 v2</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">172.18.0.3:6379&gt; mget &#123;user.100&#125;.k1 &#123;user.100&#125;.k2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br></pre></td></tr></table></figure>

<h1 id="哈希槽"><a href="#哈希槽" class="headerlink" title="哈希槽"></a>哈希槽</h1><p>Redis Cluster 通过对 KEY 的哈希计算（ CRC16(k1) mod 16384 ）得出槽的范围，从而找到真实的 Redis 节点，实现数据的水平扩展和负载均衡。哈希槽的引入使得 Redis Cluster 能够很灵活的解决数据倾斜问题，通过哈希槽的再分配能够快速的调整集群中数据的负载，并同时完成数据的自动迁移</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust异步编程</title>
    <url>/2021/11/21/RustAsync/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/3.png" class="full-image" />

<p>大部分编程语言都支持异步编程，异步编程作为一种并发编程模型，可以使用少量的操作系统线程完成大量的并发任务。通过多线程也可以提高系统处理任务的效率。本文记录说明他们之间的差异与各自的优势，并会给出一个简单HTTP SERVER（Rust语言实现）多线程版本与异步版本的基准测试</p>
<h1 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h1><p>与常规的顺序编程相比，并发编程不那么标准化，不同语言有各自所支持的并发编程模型，并发性可以由不同的并发编程模型表达。以下为常见并发编程模型</p>
<span id="more"></span>

<h2 id="OS-threads"><a href="#OS-threads" class="headerlink" title="OS threads"></a>OS threads</h2><p>线程适用于少量任务的使用场景，线程通常附带CPU、内存的开销。线程间的切换是有成本的且很昂贵，即使是空闲的线程也在消耗系统资源。线程池可以解决一部分开销问题，但不能完全解决，使用线程不足以支持大量IO绑定型任务，如：服务器、数据库等。多线程对于现有代码的改造不依赖于特定的编程模型，不需要进行大量的代码重构就可以让现有的同步代码支持多线程</p>
<h2 id="Event-driven-programming"><a href="#Event-driven-programming" class="headerlink" title="Event-driven programming"></a>Event-driven programming</h2><p>事件驱动编程与回调结合使用，可以有很好的性能表现，但通常会导致冗长的非线性控制流，很难遵循程序的数据流与错误传播</p>
<h2 id="Coroutines"><a href="#Coroutines" class="headerlink" title="Coroutines"></a>Coroutines</h2><p>协程与线程一样，不需要特定的编程模型，很容易进行代码改造。与异步相似，能够支持处理大量的任务。协程抽象了对系统编程和自定义运行时实现器很重要的低级细节</p>
<h2 id="The-actor-model"><a href="#The-actor-model" class="headerlink" title="The actor model"></a>The actor model</h2><p>参与者模型将所有并发计算划分为称为参与者的单元，这些单元通过会出错的消息传递进行通信，就像在分布式系统中一样。参与者模型可以被高效实现，但它留下了许多实际问题，如流程控制和重试逻辑</p>
<h1 id="Rust中的异步"><a href="#Rust中的异步" class="headerlink" title="Rust中的异步"></a>Rust中的异步</h1><p>异步可以降低CPU、内存开销，尤其对于大量IO绑定型任务的工作负载。同等条件下，可以比多线程处理更多的任务数量级。异步并不意味着一定比多线程好，对于小任务量的工作负载，多线程同样能够胜任。与其他编程语言不同，Rust的异步是惰性的，只有在发生 polled 的时候异步代码才会真正执行。Rust异步支持单线程，也支持多线程</p>
<h1 id="HTTP-SERVER-基准测试"><a href="#HTTP-SERVER-基准测试" class="headerlink" title="HTTP SERVER 基准测试"></a>HTTP SERVER 基准测试</h1><p>使用WRK进行HTTP基准测试 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --rm  8lovelife/wrk -txxx -cxxx -d30 \</span><br><span class="line">--timeout=15 http://host.docker.internal:port</span><br><span class="line"></span><br><span class="line">-t: 线程数</span><br><span class="line">-c: HTTP连接数</span><br><span class="line">-d: 测试持续时间。-d30 表示持续测试30s</span><br><span class="line">N/A: 宕机</span><br></pre></td></tr></table></figure>

<h2 id="ROUND-1"><a href="#ROUND-1" class="headerlink" title="ROUND 1"></a>ROUND 1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程数:10</span><br><span class="line">HTTP链接数:10</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">-</th>
<th align="center">QPS</th>
<th align="center">THROUGHPUT</th>
<th align="center">AVG</th>
<th align="center">MEMORY QUOTA</th>
<th align="center">CPU QUOTA</th>
<th align="center">TIMEOUT</th>
</tr>
</thead>
<tbody><tr>
<td align="left">V1 single-thread</td>
<td align="center">0.63</td>
<td align="center">19</td>
<td align="center">12.23s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V2 multi-thread</td>
<td align="center">6.32</td>
<td align="center">190</td>
<td align="center">1.51s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V3 thread-pool</td>
<td align="center">6.29</td>
<td align="center">189</td>
<td align="center">1.52s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V4 async single-thread</td>
<td align="center">6.32</td>
<td align="center">190</td>
<td align="center">1.51s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V5 async multi-thread</td>
<td align="center">6.32</td>
<td align="center">190</td>
<td align="center">1.51s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h2 id="ROUND-2"><a href="#ROUND-2" class="headerlink" title="ROUND 2"></a>ROUND 2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程数:100</span><br><span class="line">HTTP链接数:100</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">-</th>
<th align="center">QPS</th>
<th align="center">THROUGHPUT</th>
<th align="center">AVG</th>
<th align="center">MEMORY QUOTA</th>
<th align="center">CPU QUOTA</th>
<th align="center">TIMEOUT</th>
</tr>
</thead>
<tbody><tr>
<td align="left">V1 single-thread</td>
<td align="center">0.63</td>
<td align="center">19</td>
<td align="center">16.50s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V2 multi-thread</td>
<td align="center">63.21</td>
<td align="center">1900</td>
<td align="center">1.51s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V3 thread-pool</td>
<td align="center">6.61</td>
<td align="center">199</td>
<td align="center">11.67</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V4 async single-thread</td>
<td align="center">63.22</td>
<td align="center">1900</td>
<td align="center">1.51</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V5 async multi-thread</td>
<td align="center">63.18</td>
<td align="center">1900</td>
<td align="center">1.51</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h2 id="ROUND-3"><a href="#ROUND-3" class="headerlink" title="ROUND 3"></a>ROUND 3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程数:1000</span><br><span class="line">HTTP链接数:1000</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">-</th>
<th align="center">QPS</th>
<th align="center">THROUGHPUT</th>
<th align="center">AVG</th>
<th align="center">MEMORY QUOTA</th>
<th align="center">CPU QUOTA</th>
<th align="center">TIMEOUT</th>
</tr>
</thead>
<tbody><tr>
<td align="left">V1 single-thread</td>
<td align="center">0.63</td>
<td align="center">19</td>
<td align="center">16.50s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V2 multi-thread</td>
<td align="center">NA</td>
<td align="center">N&#x2F;A</td>
<td align="center">N&#x2F;A</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">N&#x2F;A</td>
</tr>
<tr>
<td align="left">V3 thread-pool</td>
<td align="center">6.60</td>
<td align="center">199</td>
<td align="center">15.74s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V4 async single-thread</td>
<td align="center">614.44</td>
<td align="center">18529</td>
<td align="center">1.54s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V5 async multi-thread</td>
<td align="center">615.77</td>
<td align="center">18565</td>
<td align="center">1.54s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h2 id="ROUND-4"><a href="#ROUND-4" class="headerlink" title="ROUND 4"></a>ROUND 4</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程数:3000</span><br><span class="line">HTTP链接数:3000</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">-</th>
<th align="center">QPS</th>
<th align="center">THROUGHPUT</th>
<th align="center">AVG</th>
<th align="center">MEMORY QUOTA</th>
<th align="center">CPU QUOTA</th>
<th align="center">TIMEOUT</th>
</tr>
</thead>
<tbody><tr>
<td align="left">V1 single-thread</td>
<td align="center">0.73</td>
<td align="center">23</td>
<td align="center">16.50s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">5</td>
</tr>
<tr>
<td align="left">V2 multi-thread</td>
<td align="center">NA</td>
<td align="center">N&#x2F;A</td>
<td align="center">N&#x2F;A</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">N&#x2F;A</td>
</tr>
<tr>
<td align="left">V3 thread-pool</td>
<td align="center">6.78</td>
<td align="center">209</td>
<td align="center">13.52s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">10</td>
</tr>
<tr>
<td align="left">V4 async single-thread</td>
<td align="center">673.95</td>
<td align="center">20734</td>
<td align="center">2.72s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V5 async multi-thread</td>
<td align="center">635.85</td>
<td align="center">19738</td>
<td align="center">3.49s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h2 id="ROUND-5"><a href="#ROUND-5" class="headerlink" title="ROUND 5"></a>ROUND 5</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程数:5000</span><br><span class="line">HTTP链接数:5000</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">-</th>
<th align="center">QPS</th>
<th align="center">THROUGHPUT</th>
<th align="center">AVG</th>
<th align="center">MEMORY QUOTA</th>
<th align="center">CPU QUOTA</th>
<th align="center">TIMEOUT</th>
</tr>
</thead>
<tbody><tr>
<td align="left">V1 single thread</td>
<td align="center">0.73</td>
<td align="center">23</td>
<td align="center">16.50s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">5</td>
</tr>
<tr>
<td align="left">V2 multi-thread</td>
<td align="center">N&#x2F;A</td>
<td align="center">N&#x2F;A</td>
<td align="center">N&#x2F;A</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">N&#x2F;A</td>
</tr>
<tr>
<td align="left">V3 thread-pool</td>
<td align="center">7.59</td>
<td align="center">239</td>
<td align="center">15.96s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">40</td>
</tr>
<tr>
<td align="left">V4 async single-thread</td>
<td align="center">593.99</td>
<td align="center">20044</td>
<td align="center">4.64s</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V4 async single-thread</td>
<td align="center">911.34</td>
<td align="center">28938</td>
<td align="center">2.15s</td>
<td align="center">20M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">V5 async multi-thread</td>
<td align="center">N&#x2F;A</td>
<td align="center">N&#x2F;A</td>
<td align="center">N&#x2F;A</td>
<td align="center">10M</td>
<td align="center">2</td>
<td align="center">N&#x2F;A</td>
</tr>
<tr>
<td align="left">V5 async multi-thread</td>
<td align="center">896.92</td>
<td align="center">28978</td>
<td align="center">2.42s</td>
<td align="center">20M</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html">Asynchronous Programming in Rust</a></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3.4&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  webserver_v1:</span><br><span class="line">    image: 8lovelife/webserver:v1</span><br><span class="line">    ports:</span><br><span class="line">      - 17878:7878</span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#x27;2&#x27;</span><br><span class="line">          memory: 10M</span><br><span class="line"></span><br><span class="line">  webserver_v2:</span><br><span class="line">    image: 8lovelife/webserver:v2</span><br><span class="line">    ports:</span><br><span class="line">      - 27878:7878</span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#x27;2&#x27;</span><br><span class="line">          memory: 10M</span><br><span class="line"></span><br><span class="line">  webserver_v3:</span><br><span class="line">    image: 8lovelife/webserver:v3</span><br><span class="line">    ports:</span><br><span class="line">      - 37878:7878</span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#x27;2&#x27;</span><br><span class="line">          memory: 10M</span><br><span class="line"></span><br><span class="line">  webserver_v4:</span><br><span class="line">    image: 8lovelife/webserver:v4</span><br><span class="line">    ports:</span><br><span class="line">      - 47878:7878</span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#x27;2&#x27;</span><br><span class="line">          memory: 20M</span><br><span class="line"></span><br><span class="line">  webserver_v5:</span><br><span class="line">    image: 8lovelife/webserver:v5</span><br><span class="line">    ports:</span><br><span class="line">      - 57878:7878</span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#x27;2&#x27;</span><br><span class="line">          memory: 20M</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> Sometimes you have to sacrifice everything you love to save everything you love. - Murph</p>
<p><a href="https://movie.douban.com/subject/1889243/">Interstellar</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
        <tag>Rust</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Cross Compilation</title>
    <url>/2023/08/08/RustCrossCompilation/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/56.png" class="full-image" />

<p>最近在用Rust语言写一个轻量级的数据同步工具（DP），由于是在MacBook Pro M2上做的开发，通过cargo build –release编译后的执行文件，无法在x86_64架构的Linux系统上运行。虽然rustup提供了交叉编译的能力，但开发环境安装不同架构平台的工具链，很容易导致混乱，于是我决定通过Dockerfile来进行DP的”交叉”编译</p>
<span id="more"></span>


<h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>通过使用x86_64-musl镜像，构建静态链接执行文件</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> messense/rust-musl-cross:x86_64-musl as build</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> USER=root cargo new --bin ep-dp</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /ep-dp</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./Cargo.lock ./Cargo.lock</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./Cargo.toml ./Cargo.toml</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./src ./src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> cargo build --release</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> scratch AS export-stage</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /ep-dp/target/x86_64-unknown-linux-musl/release/ep-dp .</span></span><br></pre></td></tr></table></figure>

<h2 id="导出构建文件"><a href="#导出构建文件" class="headerlink" title="导出构建文件"></a>导出构建文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DOCKER_BUILDKIT=1 docker build -f Dockerfile . --output . &amp;&amp; mv ep-dp ep-dp:musl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译报错如下</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">error: failed to run custom build <span class="built_in">command</span> <span class="keyword">for</span> `openssl-sys v0.9.90`</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">run pkg_config fail: pkg-config has not been configured to support cross-compilation.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Could not find directory of OpenSSL installation, and this `-sys` crate cannot</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">proceed without this knowledge. If OpenSSL is installed and this crate had</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">trouble finding it,  you can <span class="built_in">set</span> the `OPENSSL_DIR` environment variable <span class="keyword">for</span> the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">compilation process.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决方法</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在Cargo.toml中添加 openssl = &#123; version = <span class="string">&quot;0.10&quot;</span>, features = [<span class="string">&quot;vendored&quot;</span>] &#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">on centos</span></span><br><span class="line">[root@m dp]# ldd ep-dp:musl</span><br><span class="line">        statically linked</span><br></pre></td></tr></table></figure>

<h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>直接使用目标平台镜像，构建动态链接执行文件</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> --platform=linux/amd64 centos:<span class="number">7.6</span>.<span class="number">1810</span> as build</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y gcc gcc-c++ openssl-devel pkg-config</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | bash -s -- -y</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/root/.cargo/bin:$&#123;PATH&#125;&quot;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> USER=root cargo new --bin ep-dp</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /ep-dp</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./Cargo.lock ./Cargo.lock</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./Cargo.toml ./Cargo.toml</span></span><br><span class="line"><span class="comment"># 缓存依赖包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> cargo build --release</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> src/*.rs</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./src ./src</span></span><br><span class="line"><span class="comment"># 构建</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> ./target/release/deps/ep_dp*</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> cargo build --release</span></span><br><span class="line"><span class="comment"># 裁剪</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> strip target/release/ep-dp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> scratch AS export-stage</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /ep-dp/target/release/ep-dp .</span></span><br></pre></td></tr></table></figure>

<h2 id="导出构建文件-1"><a href="#导出构建文件-1" class="headerlink" title="导出构建文件"></a>导出构建文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DOCKER_BUILDKIT=1 docker build -f Dockerfile . --output . &amp;&amp; mv ep-dp ep-dp:centos</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">on centos</span></span><br><span class="line">[root@m dp]# ldd ep-dp:centos </span><br><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffd22bc1000)</span><br><span class="line">        libz.so.1 =&gt; /lib64/libz.so.1 (0x00007f7d961fa000)</span><br><span class="line">        libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f7d95fe4000)</span><br><span class="line">        librt.so.1 =&gt; /lib64/librt.so.1 (0x00007f7d95ddc000)</span><br><span class="line">        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f7d95bc0000)</span><br><span class="line">        libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f7d958be000)</span><br><span class="line">        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f7d956ba000)</span><br><span class="line">        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f7d952ed000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f7d96e96000)</span><br></pre></td></tr></table></figure>

<h1 id="DP-Image"><a href="#DP-Image" class="headerlink" title="DP Image"></a>DP Image</h1><p>构建DP镜像</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> messense/rust-musl-cross:x86_64-musl as build</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> USER=root cargo new --bin ep-dp</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /ep-dp</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./Cargo.lock ./Cargo.lock</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./Cargo.toml ./Cargo.toml</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./src ./src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> cargo build --release</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> --platform=linux/amd64 alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /ep-dp/target/x86_64-unknown-linux-musl/release/ep-dp .</span></span><br><span class="line"><span class="keyword">ENV</span> RUST_LOG=ep_dp=info</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /config</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /data</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/ep-dp&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@x dp]# docker image ls | grep ep-dp</span><br><span class="line">ep-dp    latest    5b0e6e989f8b   36 seconds ago   16.3MB</span><br></pre></td></tr></table></figure>


<h1 id="动态链接-VS-静态链接"><a href="#动态链接-VS-静态链接" class="headerlink" title="动态链接 VS 静态链接"></a>动态链接 VS 静态链接</h1><p>静态链接执行文件是一个完整的可执行文件，包含所有的依赖库。动态链接执行文件需要依赖共享库才能正确运行</p>
<h2 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h2><p>静态链接执行文件的size要大于动态链接执行文件的size</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@m dp]# ls -lah ep-dp:musl</span><br><span class="line">-rwxr-xr-x 1 x x 15M Aug  7 09:44 ep-dp:musl</span><br><span class="line">[root@m dp]# ls -lah ep-dp:centos </span><br><span class="line">-rwxr-xr-x 1 x x 8.6M Aug  7 16:04 ep-dp:centos</span><br></pre></td></tr></table></figure>

<h2 id="系统兼容"><a href="#系统兼容" class="headerlink" title="系统兼容"></a>系统兼容</h2><p>静态链接执行文件拥有更好的兼容性，而动态链接执行文件的运行环境需要包含所需依赖库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">on Alpine</span></span><br><span class="line">[root@x dp]# ldd ep-dp:centos</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x7ffffff65000)</span><br><span class="line">        libz.so.1 =&gt; /lib/libz.so.1 (0x7fffff4c5000)</span><br><span class="line">Error loading shared library libgcc_s.so.1: No such file or directory (needed by ep-dp:centos)</span><br><span class="line">        librt.so.1 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7ffffff65000)</span><br><span class="line">        libpthread.so.0 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7ffffff65000)</span><br><span class="line">        libm.so.6 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7ffffff65000)</span><br><span class="line">        libdl.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7ffffff65000)</span><br><span class="line">        libc.so.6 =&gt; /lib64/ld-linux-x86-64.so.2 (0x7ffffff65000)     </span><br><span class="line"></span><br><span class="line">[root@m dp]# ldd ep-dp:musl</span><br><span class="line">        statically linked          </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>排序-希尔排序</title>
    <url>/2023/02/02/ShellSort/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/41.png" class="full-image" />

<p>希尔排序算法由 <u><em><strong>DONALD L. SHELL（1924-2015）</strong></em></u> 发明，于1959年发布于ACM算法存储库，它的算法复杂度取决于间隙序列的选择，当前仍无法确认希尔排序的算法复杂度</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>希尔排序是一种不稳定（<strong>排序后可能会改变相同值的相对位置</strong>）的插入排序算法，它是一种自适应排序算法（<strong>当待排序队列部分有序时，算法执行更快</strong>），它是对插入排序的一种高效改进，通过增量序列使得元素能够快速移动，从而加速整个排序过程。增量序列的选取是希尔排序的关键，选择不当性能甚至会低于插入排序。10W个随机整数排序情况如下</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/shellsort/cp.png" alt="image"></p>
<span id="more"></span>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><a href="https://www.bilibili.com/video/BV1Xa411Y7Yt/?t=0h1m35s">这里有视频图例</a></p>
<ol>
<li>首先排序远距离的元素 </li>
<li>逐渐缩小排序距离</li>
<li>最后变为原始的插入排序</li>
</ol>
<h2 id="间隙序列"><a href="#间隙序列" class="headerlink" title="间隙序列"></a>间隙序列</h2><p>计算机科学家对间隙序列的探索</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/shellsort/gap.png" alt="image"></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>使用Rust语言实现希尔排序算法，间隙选择使用希尔序列</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">shell_sort</span>&lt;T:<span class="built_in">Ord</span> + <span class="built_in">Copy</span>&gt;(arr:&amp;<span class="keyword">mut</span>[T])&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">gap</span> = arr.<span class="title function_ invoke__">len</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..gap &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> ((i+gap)..arr.<span class="title function_ invoke__">len</span>()).<span class="title function_ invoke__">step_by</span>(gap) &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">k</span> = j;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">sorting</span> = arr[k];</span><br><span class="line">                <span class="keyword">while</span> k &gt;= gap &amp;&amp; arr[k-gap] &gt; sorting &#123;</span><br><span class="line">                    arr[k] = arr[k-gap];</span><br><span class="line">                    k -=gap;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[k] = sorting;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/shellsort/on.png" alt="image"></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>希尔排序在数据规模较小的情况下性能更佳，因此也常被用于一些混合排序中的子序列处理。它可以用很少的代码实现，并且不使用调用堆栈，因此针对嵌入式系统的C标准库中qsort函数的一些实现会使用它，例如uClibc库、以及早期Linux的内核中都有希尔排序的身影</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/Shellsort">Shellsort</a><br><a href="https://www.bilibili.com/video/BV1Xa411Y7Yt">神秘的希尔排序</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>The best way to predict the future is to create it. - Vincent<br>There is no gene for the human spirit. - Irene</p>
<p><a href="https://movie.douban.com/subject/1300117/">Gattaca</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例</title>
    <url>/2018/04/21/SingletonPattern/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/26.png" class="full-image" />

<p>记录下单例模式的几种实现</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例类保证在系统中始终只有一份类的实例，单例模式能够节约内存空间，对于整个系统中共性的逻辑可以采用单例模式。分布式系统中ZK就像是整个系统中的”单例”</p>
<h2 id="单例的实现"><a href="#单例的实现" class="headerlink" title="单例的实现"></a>单例的实现</h2><p>单例的实现方式有多种，根据实例化时机可分为饿汉、懒汉模式</p>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static final Singleton singleton = new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单例在类的加载时就完成了类的实例（即使这个类还没被使用）</p>
</blockquote>
<span id="more"></span>

<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (singleton == null) &#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>double check 既保证了类的延迟加载，又降低了synchronize带来的累积性能消耗。但这个单例在多线程环境下存在安全隐患</p>
</blockquote>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>singleton &#x3D; new Singleton(); 这段代码并非原子操作（开辟内存空间-&gt;类的初始化-&gt;引用变量赋值），为了提高性能，程序会进行指令的重排序如（开辟内存空间-&gt;引用变量赋值-&gt;类的初始化），多线程环境下会存在线程拿到未实例完成的类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton singleton;</span><br><span class="line"> </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (singleton == null) &#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>volatile禁止指令重排序</p>
</blockquote>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line">    public static final Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只有在调用getInstance()时才会加载静态内部类SingletonHolder（JVM保证类的加载是线程安全的），从而实例化Singleton</p>
</blockquote>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    Object object;</span><br><span class="line"></span><br><span class="line">    Singleton() &#123;</span><br><span class="line">        object = new Object();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  Object getInstance() &#123;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mac:src mac$ javac -encoding utf-8 Singleton.java </span><br><span class="line">Mac:src mac$ javap -c Singleton.class</span><br><span class="line">Compiled from &quot;Singleton.java&quot;</span><br><span class="line">public final class Singleton extends java.lang.Enum&lt;Singleton&gt; &#123;</span><br><span class="line">  public static final Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">  java.lang.Object object;</span><br><span class="line"></span><br><span class="line">  public static Singleton[] values();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #1                  // Field $VALUES:[LSingleton;</span><br><span class="line">       3: invokevirtual #2                  // Method &quot;[LSingleton;&quot;.clone:()Ljava/lang/Object;</span><br><span class="line">       6: checkcast     #3                  // class &quot;[LSingleton;&quot;</span><br><span class="line">       9: areturn</span><br><span class="line"></span><br><span class="line">  public static Singleton valueOf(java.lang.String);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #4                  // class Singleton</span><br><span class="line">       2: aload_0</span><br><span class="line">       3: invokestatic  #5                  // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span><br><span class="line">       6: checkcast     #4                  // class Singleton</span><br><span class="line">       9: areturn</span><br><span class="line"></span><br><span class="line">  public java.lang.Object getInstance();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #9                  // Field object:Ljava/lang/Object;</span><br><span class="line">       4: areturn</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #4                  // class Singleton</span><br><span class="line">       3: dup</span><br><span class="line">       4: ldc           #10                 // String INSTANCE</span><br><span class="line">       6: iconst_0</span><br><span class="line">       7: invokespecial #11                 // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span><br><span class="line">      10: putstatic     #12                 // Field INSTANCE:LSingleton;</span><br><span class="line">      13: iconst_1</span><br><span class="line">      14: anewarray     #4                  // class Singleton</span><br><span class="line">      17: dup</span><br><span class="line">      18: iconst_0</span><br><span class="line">      19: getstatic     #12                 // Field INSTANCE:LSingleton;</span><br><span class="line">      22: aastore</span><br><span class="line">      23: putstatic     #1                  // Field $VALUES:[LSingleton;</span><br><span class="line">      26: return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;</span><br><span class="line">        implements Comparable&lt;E&gt;, Serializable </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>枚举类的字节码可以看出，枚举在使用的时候（懒加载）触发类的初始化（线程安全），枚举类已经实现了序列化接口</p>
</blockquote>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> Life’s a little bit messy. We all make mistakes. - Judy Hopps</p>
<p><a href="https://movie.douban.com/subject/25662329/">Zootopia</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Design Pattern</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的@Async</title>
    <url>/2019/05/28/SpringAsync/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/14.png" class="full-image" />

<h1 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h1><p>@Async由Spring定义，在方法上添加此注解，方法的执行将会是异步的(在另一个线程中执行)，调用者不需要等待方法执行完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Async &#123;</span><br><span class="line">    // 用于指定异步执行的线程池名称</span><br><span class="line">	String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h1><p>被@Async标记的方法都可以异步执行，注解的方式非常灵活，异步的线程资源可以集中管理</p>
<p><strong>异步执行 BEFORE</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void sayWorld() &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(30);</span><br><span class="line">            System.out.println(&quot;world&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sayHello() &#123;</span><br><span class="line">   sayWorld();</span><br><span class="line">   System.out.println(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>异步执行 AFTER</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Async</span><br><span class="line">public void sayWorld() throws InterruptedException &#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(30);</span><br><span class="line">    System.out.println(&quot;world&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sayHello() &#123;</span><br><span class="line">   sayWorld();</span><br><span class="line">   System.out.println(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h1 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h1><p>@Async如何使用？又是怎么运作的？</p>
<h2 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableAsync</span><br><span class="line">public class AsyncConfigDemo implements AsyncConfigurer &#123;	// 优先级低，相对于 @Async指定异步线程池</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Executor getAsyncExecutor() &#123;</span><br><span class="line">        ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();</span><br><span class="line">        threadPoolTaskExecutor.setCorePoolSize(10);</span><br><span class="line">        threadPoolTaskExecutor.setThreadNamePrefix(&quot;async-&quot;);</span><br><span class="line">        threadPoolTaskExecutor.initialize();</span><br><span class="line">        return threadPoolTaskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123;</span><br><span class="line">        return new SimpleAsyncUncaughtExceptionHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class AsyncDemo &#123;</span><br><span class="line">    @Async(value = &quot;taskScheduler&quot;) // 优先级高</span><br><span class="line">    public void sayWorld() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        System.out.println(&quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private AsyncDemo asyncDemo;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSync() throws IOException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            asyncDemo.sayWorld();</span><br><span class="line">            System.out.println(&quot;hello&quot;);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li><p>AsyncConfigDemo由ConfigurationClassParser进行解析，包括注解@EnableAsync上的<strong>AsyncConfigurationSelector</strong>类</p>
</li>
<li><p>AsyncConfigurationSelector根据@EnableAsync mode()选择代理方式实现，默认为<strong>ProxyAsyncConfiguration</strong></p>
</li>
<li><p>Configuration类ProxyAsyncConfiguration被创建并注入AsyncConfigurer扩展的executor、exceptionHandler，创建<strong>AsyncAnnotationBeanPostProcessor</strong>并通过setBeanFactory方法创建<strong>AsyncAnnotationAdvisor</strong></p>
</li>
<li><p>AsyncAnnotationAdvisor设置advice(<strong>AnnotationAsyncExecutionInterceptor</strong>，设置缺省获取线程池方法getDefaultExecutor，当未扩展AsyncConfigurer的实现则在执行异步的时候getDefaultExecutor会从Spring的上下文中查找<strong>TaskExecutor</strong>的实现类实例)。设置pointcut(@Async的注解类或方法或是自定义的异步注解)</p>
</li>
<li><p>AnnotationAsyncExecutionInterceptor通过determineAsyncExecutor方法确认执行的Executor。getExecutorQualifier方法查找名为@Async指定的value值的Executor，若找到则执行，若无法确认Executor则调用getDefaultExecutor方法查询类型为TaskExecutor的类，若有多个实现则会查找名字为”taskExecutor”的实现Bean，最终都没有找到则创建SimpleAsyncTaskExecutor(每一个异步的方法任务都会创建一个新的线程)</p>
</li>
</ol>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> All you got in life is people. That’s all there is. - Tony</p>
<p><a href="https://movie.douban.com/subject/27060077/">Green Book</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring容器中Bean的生命周期</title>
    <url>/2019/12/26/SpringBeanLifeCycle/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/10.png" class="full-image" />

<p>圣诞节在家整理了一下Spring容器中的Bean到底是怎么诞生的，又是如何毁灭的</p>
<h1 id="容器中Bean的生命周期"><a href="#容器中Bean的生命周期" class="headerlink" title="容器中Bean的生命周期"></a>容器中Bean的生命周期</h1><p>下图为Spring容器中Bean的生命周期</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/SpringBeanLifeCycle/SpringBeanLifeCycle.png" alt="image"></p>
<span id="more"></span>

<h1 id="容器中Bean的创建过程"><a href="#容器中Bean的创建过程" class="headerlink" title="容器中Bean的创建过程"></a>容器中Bean的创建过程</h1><p>下图是Spring容器创建一个Bean大致的过程</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/SpringBeanLifeCycle/SpringBeanCreating.png" alt="image"></p>
<h2 id="MergedBeanDefinitionPostProcessor-postProcessMergedBeanDefinition"><a href="#MergedBeanDefinitionPostProcessor-postProcessMergedBeanDefinition" class="headerlink" title="MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition"></a>MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition</h2><p>下图是 CommonAnnotationBeanPostProcessor &#x2F; AutowiredAnnotationBeanPostProcessor 在此刻做的事情</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/SpringBeanLifeCycle/postProcessMergedBeanDefinition.png" alt="image"></p>
<h3 id="CommonAnnotationBeanPostProcessor-postProcessMergedBeanDefinition"><a href="#CommonAnnotationBeanPostProcessor-postProcessMergedBeanDefinition" class="headerlink" title="CommonAnnotationBeanPostProcessor#postProcessMergedBeanDefinition"></a>CommonAnnotationBeanPostProcessor#postProcessMergedBeanDefinition</h3><ol>
<li>将@PostConstruct方法缓存至lifecycleMetadataCache（LifecycleMetadata的initMethods）</li>
<li>将@PreDestroy方法缓存至lifecycleMetadataCache （LifecycleMetadata的destroyMethods）</li>
<li>将@Resouorce、@WebServiceRef、@EJB 修饰的字段或方法缓存至injectionMetadataCache（ResourceElement&#x2F;WebServiceRefElement&#x2F;EjbRefElement）</li>
</ol>
<h3 id="AutowiredAnnotationBeanPostProcessor-postProcessMergedBeanDefinition"><a href="#AutowiredAnnotationBeanPostProcessor-postProcessMergedBeanDefinition" class="headerlink" title="AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition"></a>AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition</h3><blockquote>
<p>将@Autowired、@Value、@javax.inject.Inject  修饰的字段或方法缓存至 injectionMetadataCache（AutowiredFieldElement&#x2F;AutowiredMethodElement）</p>
</blockquote>
<h2 id="InstantiationAwareBeanPostProcessor-postProcessProperties"><a href="#InstantiationAwareBeanPostProcessor-postProcessProperties" class="headerlink" title="InstantiationAwareBeanPostProcessor#postProcessProperties"></a>InstantiationAwareBeanPostProcessor#postProcessProperties</h2><p>下图是 CommonAnnotationBeanPostProcessor &#x2F; AutowiredAnnotationBeanPostProcessor 在此刻做的事情</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/SpringBeanLifeCycle/postProcessProperties.png" alt="image"></p>
<h3 id="CommonAnnotationBeanPostProcessor-postProcessProperties"><a href="#CommonAnnotationBeanPostProcessor-postProcessProperties" class="headerlink" title="CommonAnnotationBeanPostProcessor#postProcessProperties"></a>CommonAnnotationBeanPostProcessor#postProcessProperties</h3><blockquote>
<p>获取injectionMetadataCache中的InjectedElement（ResourceElement&#x2F;WebServiceRefElement&#x2F;EjbRefElement ）<br>并进行解析注入</p>
</blockquote>
<h3 id="AutowiredAnnotationBeanPostProcessor-postProcessProperties"><a href="#AutowiredAnnotationBeanPostProcessor-postProcessProperties" class="headerlink" title="AutowiredAnnotationBeanPostProcessor#postProcessProperties"></a>AutowiredAnnotationBeanPostProcessor#postProcessProperties</h3><blockquote>
<p>获取injectionMetadataCache中的InjectedElement（AutowiredFieldElement&#x2F;AutowiredMethodElement）<br>并进行解析注入</p>
</blockquote>
<h2 id="BeanPostProcessor-postProcessBeforeInitialization"><a href="#BeanPostProcessor-postProcessBeforeInitialization" class="headerlink" title="BeanPostProcessor#postProcessBeforeInitialization"></a>BeanPostProcessor#postProcessBeforeInitialization</h2><p>下图是 CommonAnnotationBeanPostProcessor 在此刻做的事情</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/SpringBeanLifeCycle/postProcessBeforeInitialization.png" alt="iamge"></p>
<blockquote>
<p>@PostConstruct方法此刻被调用</p>
</blockquote>
<h2 id="AbstractAutowireCapableBeanFactory-invokeAwareMethods"><a href="#AbstractAutowireCapableBeanFactory-invokeAwareMethods" class="headerlink" title="AbstractAutowireCapableBeanFactory#invokeAwareMethods"></a>AbstractAutowireCapableBeanFactory#invokeAwareMethods</h2><p>做的事情如图</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/SpringBeanLifeCycle/invokeAwareMethods.png" alt="iamge"></p>
<ol>
<li>BeanNameAware.setBeanName</li>
<li>BeanClassLoaderAware.setBeanClassLoader</li>
<li>BeanFactoryAware.setBeanFactory</li>
</ol>
<h2 id="AbstractAutowireCapableBeanFactory-invokeInitMethods"><a href="#AbstractAutowireCapableBeanFactory-invokeInitMethods" class="headerlink" title="AbstractAutowireCapableBeanFactory#invokeInitMethods"></a>AbstractAutowireCapableBeanFactory#invokeInitMethods</h2><p>做的事情如图</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/SpringBeanLifeCycle/invokeInitMethods.png" alt="iamge"></p>
<ol>
<li>执行InitializingBean.afterPropertiesSet方法</li>
<li>执行invokeCustomInitMethod，即执行init-method</li>
</ol>
<h2 id="BeanPostProcessor-postProcessAfterInitialization"><a href="#BeanPostProcessor-postProcessAfterInitialization" class="headerlink" title="BeanPostProcessor#postProcessAfterInitialization"></a>BeanPostProcessor#postProcessAfterInitialization</h2><p><a href="https://whathowhy.com/2019/05/28/Spring%E4%B8%AD%E7%9A%84-Async/">Spring中的@Async</a></p>
<h2 id="AbstractBeanFactory-registerDisposableBeanIfNecessary"><a href="#AbstractBeanFactory-registerDisposableBeanIfNecessary" class="headerlink" title="AbstractBeanFactory#registerDisposableBeanIfNecessary"></a>AbstractBeanFactory#registerDisposableBeanIfNecessary</h2><p>做的事情如图</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/SpringBeanLifeCycle/registerDisposableBeanIfNecessary.png" alt="image"></p>
<ol>
<li>DisposableBean类型的Bean（DisposableBeanAdapter）被放至  DefaultSingletonBeanRegistry的disposableBeans中</li>
<li>过滤 DestructionAwareBeanPostProcessor 至 DisposableBeanAdapter的beanPostProcessors</li>
</ol>
<h1 id="容器中Bean的销毁过程"><a href="#容器中Bean的销毁过程" class="headerlink" title="容器中Bean的销毁过程"></a>容器中Bean的销毁过程</h1><p>下图是Spring容器中的Bean销毁过程</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/SpringBeanLifeCycle/SpringBeanDestory.png" alt="image"></p>
<h2 id="AbstractApplicationContext-doClose"><a href="#AbstractApplicationContext-doClose" class="headerlink" title="AbstractApplicationContext#doClose"></a>AbstractApplicationContext#doClose</h2><blockquote>
<p>程序正常退出后，系统会调用此方法</p>
</blockquote>
<h2 id="DestructionAwareBeanPostProcessor-postProcessBeforeDestruction"><a href="#DestructionAwareBeanPostProcessor-postProcessBeforeDestruction" class="headerlink" title="DestructionAwareBeanPostProcessor#postProcessBeforeDestruction"></a>DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</h2><p>下图是CommonAnnotationBeanPostProcessor在此刻做的事情</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/SpringBeanLifeCycle/postProcessBeforeDestruction.png" alt="iamge"></p>
<blockquote>
<p>执行invokeDestroyMethods，即执行@PreDestroy方法</p>
</blockquote>
<h2 id="DisposableBeanAdapter-invokeCustomDestroyMethod"><a href="#DisposableBeanAdapter-invokeCustomDestroyMethod" class="headerlink" title="DisposableBeanAdapter#invokeCustomDestroyMethod"></a>DisposableBeanAdapter#invokeCustomDestroyMethod</h2><blockquote>
<p>执行invokeCustomDestroyMethod，即执行destroy-method方法</p>
</blockquote>
<h1 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BeanPropertyResource &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;BeanPropertyResource Instantiation&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class BeanPropertyAutowired &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;BeanPropertyAutowired Instantiation&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class BeanLifeCycle implements InitializingBean, DisposableBean, BeanNameAware, BeanFactoryAware, BeanClassLoaderAware &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private BeanPropertyResource beanPropertyResource;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BeanPropertyAutowired beanPropertyAutowired;</span><br><span class="line"></span><br><span class="line">    public BeanLifeCycle() &#123;</span><br><span class="line">        System.out.println(&quot;BeanLifeCycle&quot;);</span><br><span class="line">        System.out.println(&quot;without beanPropertyResource: &quot; + beanPropertyResource);</span><br><span class="line">        System.out.println(&quot;without beanPropertyAutowired: &quot; + beanPropertyAutowired);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void postConstructMethod() &#123;</span><br><span class="line">        System.out.println(&quot;with beanPropertyResource: &quot; + beanPropertyResource);</span><br><span class="line">        System.out.println(&quot;with beanPropertyAutowired: &quot; + beanPropertyAutowired);</span><br><span class="line">        System.out.println(&quot;postConstructMethod&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void initMethod() &#123;</span><br><span class="line">        System.out.println(&quot;init-method initMethod&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        System.out.println(&quot;InitializingBean afterPropertiesSet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void preDestroyMethod() &#123;</span><br><span class="line">        System.out.println(&quot;preDestroyMethod&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        System.out.println(&quot;DisposableBean destroy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroyMethod() &#123;</span><br><span class="line">        System.out.println(&quot;destroy-method destroyMethod&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanClassLoader(ClassLoader classLoader) &#123;</span><br><span class="line">        System.out.println(&quot;BeanClassLoaderAware&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;BeanFactoryAware&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanName(String name) &#123;</span><br><span class="line">        System.out.println(&quot;BeanNameAware&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XML中配置</span><br><span class="line"></span><br><span class="line">&lt;bean class=&quot;cn.oyo.trade.starter.BeanLifeCycle&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> I’m not a freak, I’m just different. - Mr. White</p>
<p><a href="https://movie.douban.com/subject/1299603/">Reservoir Dogs</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Orika ClassLoader</title>
    <url>/2024/05/01/SpringOrikaCoFu.md/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/38.png" class="full-image" />

<p>使用了很多年的 Java Bean 对象映射框架 Orika，最近运行报错了，异常出现在某些特定的使用场景下，具体场景在 Spring 容器中使用 CompletableFuture，异步任务中进行一些 Java Bean 的对象映射，异常信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: ma.glasnost.orika.impl.generator.CompilerStrategy$SourceCodeGenerationException: Error compiling ma.glasnost.orika.generated.Orika_XXX_YYY_Mapper383167261886761$<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>本篇博客将分析记录 Orika 使用异常产生的原因，同时回顾一些相关知识</p>
<span id="more"></span>

<h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><p>在程序运行中，ClassLoader 负责动态的按需将字节码加载到 JVM 中，字节码可以是 .java 文件编译后获得的 .class 文件，程序也可以按照字节码的定义规范直接生成字节码，比如通过 ASM，Javassis 字节码生成工具直接编辑字节码。Java 提供了一些内置的 ClassLoader 类型，用户也可以按需定制自己的 ClassLoader</p>
<ol>
<li><p>Buildin ClassLoader</p>
<p> Java 提供了一些内置的 ClassLoader 类型</p>
<ul>
<li><p>BootstrapClassLoader</p>
<p>  由 C++ 编写，负责启动 JVM 以及加载 Java 应用程序所需的核心类，是最顶层的类加载器，在 Java 中的输出为 NULL</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">hashMapListClassLoader</span> <span class="operator">=</span> HashMap.class.getClassLoader();</span><br><span class="line">System.out.println(<span class="string">&quot;HashMap ClassLoader: &quot;</span> + hashMapListClassLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">HashMap ClassLoader: <span class="literal">null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>PlatformClassLoader </p>
<p>  负责加载一些核心类的扩展包，比如供第三方实现的扩展包，如：java.sql.Driver</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">driverManagerClassLoader</span> <span class="operator">=</span> DriverManager.class.getClassLoader();</span><br><span class="line">System.out.println(<span class="string">&quot;DriverManager ClassLoader: &quot;</span> + driverManagerClassLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">DriverManager ClassLoader: jdk.internal.loader.ClassLoaders$PlatformClassLoader@5ca881b5</span><br></pre></td></tr></table></figure>
</li>
<li><p>SystemClassLoader</p>
<p>  用于加载应用级别的类，加载器会从 CLASSPATH（ -classpath, or -cp ） 路径下查找所需加载的类文件</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">orikaClassLoader</span> <span class="operator">=</span> OrikaClassLoaderTest.class.getClassLoader();</span><br><span class="line">System.out.println(<span class="string">&quot;OrikaClassLoaderTest ClassLoader: &quot;</span> + orikaClassLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">OrikaClassLoaderTest ClassLoader: jdk.internal.loader.ClassLoaders$AppClassLoader@5ffd2b27</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Custom ClassLoader</p>
<p> 用户可以按需定制自己的 ClassLoader</p>
<ul>
<li>从远程服务器、自定义路径下加载字节码（如：Spring 中的 LaunchedURLClassLoader）</li>
<li>实现同名同包的不同 Class 定义（如：Tomcat 中的 WebappX ClassLoader）</li>
</ul>
</li>
<li><p>加载模块</p>
<p> Java SE 17 中各内置加载器负责加载的模块</p>
<table>
<thead>
<tr>
<th align="left">BootstrapClassLoader</th>
<th align="left">PlatformClassLoader</th>
<th align="left">SystemClassLoader</th>
</tr>
</thead>
<tbody><tr>
<td align="left">java.base</td>
<td align="left">java.compiler</td>
<td align="left">jdk.attach</td>
</tr>
<tr>
<td align="left">java.datatransfer</td>
<td align="left">java.net.http</td>
<td align="left">jdk.compiler</td>
</tr>
<tr>
<td align="left">java.desktop</td>
<td align="left">java.scripting</td>
<td align="left">jdk.editpad</td>
</tr>
<tr>
<td align="left">java.instrument</td>
<td align="left">java.security.jgss</td>
<td align="left">jdk.internal.ed</td>
</tr>
<tr>
<td align="left">java.logging</td>
<td align="left">java.smartcardio</td>
<td align="left">jdk.internal.jvmstat</td>
</tr>
<tr>
<td align="left">java.management</td>
<td align="left">java.sql</td>
<td align="left">jdk.internal.le</td>
</tr>
<tr>
<td align="left">java.management.rmi</td>
<td align="left">java.sql.rowset</td>
<td align="left">jdk.internal.opt</td>
</tr>
<tr>
<td align="left">java.naming</td>
<td align="left">java.transaction.xa</td>
<td align="left">jdk.jartool</td>
</tr>
<tr>
<td align="left">java.prefs</td>
<td align="left">java.xml.crypto</td>
<td align="left">jdk.javadoc</td>
</tr>
<tr>
<td align="left">java.rmi</td>
<td align="left">jdk.accessibility</td>
<td align="left">jdk.jconsole</td>
</tr>
<tr>
<td align="left">java.security.sasl</td>
<td align="left">jdk.charsets</td>
<td align="left">jdk.jdeps</td>
</tr>
<tr>
<td align="left">java.xml</td>
<td align="left">jdk.crypto.cryptoki</td>
<td align="left">jdk.jdi</td>
</tr>
<tr>
<td align="left">jdk.jfr</td>
<td align="left">jdk.crypto.ec</td>
<td align="left">jdk.jdwp.agent</td>
</tr>
<tr>
<td align="left">jdk.management</td>
<td align="left">jdk.dynalink</td>
<td align="left">jdk.jlink</td>
</tr>
<tr>
<td align="left">jdk.management.agent</td>
<td align="left">jdk.httpserver</td>
<td align="left">jdk.jpackage</td>
</tr>
<tr>
<td align="left">jdk.management.jfr</td>
<td align="left">jdk.jsobject</td>
<td align="left">jdk.jshell</td>
</tr>
<tr>
<td align="left">jdk.naming.rmi</td>
<td align="left">jdk.localedata</td>
<td align="left">jdk.jstatd</td>
</tr>
<tr>
<td align="left">jdk.net</td>
<td align="left">jdk.naming.dns</td>
<td align="left">jdk.random</td>
</tr>
<tr>
<td align="left">jdk.nio.mapmode</td>
<td align="left">jdk.security.auth</td>
<td align="left">jdk.unsupported.desktop</td>
</tr>
<tr>
<td align="left">jdk.sctp</td>
<td align="left">jdk.security.jgss</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">jdk.unsupported</td>
<td align="left">jdk.xml.dom</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">jdk.zipfs</td>
<td align="left"></td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="ClassLoader-准则"><a href="#ClassLoader-准则" class="headerlink" title="ClassLoader 准则"></a>ClassLoader 准则</h2><ol>
<li><p>委托机制</p>
<p> 当前 ClassLoader 加载 Class 调用  java.lang.ClassLoader.loadClass() 方法，首先会确定此 Class 是否已经被加载，避免重复加载，如果 Class 未被加载过，则会委托 Parent ClassLoader 进行此 Class 的加载 java.lang.ClassLoader.loadClass()，递归进行，一直到 loadClass() 成功返回 Class。如果未成功返回 Class，则 Child ClassLoader 会调用 java.net.URLClassLoader.findClass() 查找字节码并通过 defineClass() 方法将字节码转换成 Class 对象，成功则返回，否则加载失败抛出 java.lang.NoClassDefFoundError 或 java.lang.ClassNotFoundException 异常。核心方法：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ClassLoader.loadClass()</span><br><span class="line">java.net.URLClassLoader.findClass()</span><br><span class="line">java.net.URLClassLoader.defineClass()</span><br><span class="line"></span><br><span class="line">类加载器的父子关系: </span><br><span class="line">CustomClassLoader -&gt; SystemClassLoader -&gt; SystemClassLoader -&gt; BootstrapClassLoader</span><br></pre></td></tr></table></figure>
</li>
<li><p>类的可见性</p>
<p> Child ClassLoader 可以看到所有 Parent ClassLoader 加载的 Class，相反的 Parent ClassLoader 看不到 Child ClassLoader 所加载的 Class</p>
</li>
<li><p>类的唯一性</p>
<p> 确保 Class 不被重复加载，由于 Class 加载的委托机制，很容易保证 Class 的唯一性</p>
</li>
</ol>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>SPI 是 Service Provider Interface 的简称，用于方便的扩展第三方实现，此功能包含在 Java SE 6 及以后的版本中。最让人熟知的是 java.sql.Driver 接口，通过 ServiceLoader 方法就可以加载 Driver 的实现，如：mysql driver 、clickhouse driver 等。先来看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">serviceLoaderClassLoader</span> <span class="operator">=</span> ServiceLoader.class.getClassLoader();</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">mysqlClassLoader</span> <span class="operator">=</span> com.mysql.cj.jdbc.Driver.class.getClassLoader();</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">sqlClassLoader</span> <span class="operator">=</span> Driver.class.getClassLoader();</span><br><span class="line">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(java.sql.Driver.class);</span><br><span class="line"><span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> loadedDrivers.findFirst().get();</span><br><span class="line">System.out.println(<span class="string">&quot;Loaded Driver is &quot;</span> + driver);</span><br><span class="line">System.out.println(<span class="string">&quot;Sql Driver ClassLoader is &quot;</span> + sqlClassLoader);</span><br><span class="line">System.out.println(<span class="string">&quot;Mysql Driver ClassLoader is &quot;</span> + mysqlClassLoader);</span><br><span class="line">System.out.println(<span class="string">&quot;ServiceLoader ClassLoader: &quot;</span> + serviceLoaderClassLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Loaded Driver is com.mysql.cj.jdbc.Driver@34a245ab</span><br><span class="line">Sql Driver ClassLoader is jdk.internal.loader.ClassLoaders$PlatformClassLoader@24d46ca6</span><br><span class="line">Mysql Driver ClassLoader is jdk.internal.loader.ClassLoaders$AppClassLoader@5ffd2b27</span><br><span class="line">ServiceLoader ClassLoader: <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>Mysql Driver 通过 ServiceLoader 的 load 方法被成功加载，但这里是不是违背了 ClassLoader 准则中类的可见性？ServiceLoader.class 是由 BootstrapClassLoader 加载的，java.sql.Driver.class 是由 PlatformClassLoader 加载的，com.mysql.cj.jdbc.Driver.class 是由 AppClassLoader 加载的，加载路线 BootstrapClassLoader -&gt; PlatformClassLoader -&gt; AppClassLoader，与类的可见性矛盾。如何解决 SPI 类加载可见性的矛盾？答案是：<strong>线程上下文类加载器</strong></p>
<h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>查看 ServiceLoader#load(..) 方法的实现可以发现，ServiceLoader 使用的是线程上下文加载器来加载 SPI 实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceLoader</span>&lt;&gt;(Reflection.getCallerClass(), service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">contextClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">System.out.println(<span class="string">&quot;Thread Context ClassLoader: &quot;</span> + contextClassLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Thread Context ClassLoader: jdk.internal.loader.ClassLoaders$AppClassLoader@5ffd2b27</span><br></pre></td></tr></table></figure>

<p>这里的线程上下文加载器是 SystemClassLoader 通过 SystemClassLoader 的委托机制可以成功加载 com.mysql.cj.jdbc.Driver</p>
<h1 id="Orika"><a href="#Orika" class="headerlink" title="Orika"></a>Orika</h1><p>Orika 是一个 Java Bean 映射框架，可以快速、高效的将一个对象映射到另一个对象，使用起来也非常简单。Orika 通过生成字节码的方式使得 Java Bean 之间的映射速度与手动 setXXX 速度相当，生成字节码部分使用了 Javassist 框架</p>
<ol>
<li><p>使用方式</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MapperFactory</span> <span class="variable">mapperFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMapperFactory</span>.    Builder().build();</span><br><span class="line">mapperFactory.classMap(A.class, B.class)</span><br><span class="line">        .field(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">        .byDefault()</span><br><span class="line">        .register();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用 </span></span><br><span class="line"><span class="type">MapperFacade</span> <span class="variable">mapperFacade</span> <span class="operator">=</span> mapperFactory.getMapperFacade();</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> mapperFacade.map(b, A.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p>字节码生成</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JavassistCompilerStrategy#compileClass(...)&#123;</span><br><span class="line">            ...</span><br><span class="line">compiledClass = byteCodeClass.toClass(Thread.currentThread().getContextClassLoader(), <span class="built_in">this</span>.getClass().getProtectionDomain    ());</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在程序运行中，Javassist 会生成字节码并编译为类似如下 Class 对象，并进行 mapping 操作</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orika_B_A_Mapper347584518546208$0</span> <span class="keyword">extends</span> <span class="title class_">ma</span>.glasnost.orika.impl.GeneratedMapperBase &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mapAtoB</span><span class="params">(java.lang.Object a, java.lang.Object b, ma.glasnost.orika.MappingContext mappingContext)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">super</span>.mapAtoB(a, b, mappingContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sourceType: A</span></span><br><span class="line">orika.<span class="type">A</span> <span class="variable">source</span> <span class="operator">=</span> ((orika.A)a); </span><br><span class="line"><span class="comment">// destinationType: B</span></span><br><span class="line">orika.<span class="type">B</span> <span class="variable">destination</span> <span class="operator">=</span> ((orika.B)b); </span><br><span class="line"></span><br><span class="line">destination.setB(((java.lang.String)source.getA())); </span><br><span class="line">		<span class="keyword">if</span>(customMapper != <span class="literal">null</span>) &#123; </span><br><span class="line">			 customMapper.mapAtoB(source, destination, mappingContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B_A_ObjectFactory7711776903783377242228996375$1</span> <span class="keyword">extends</span> <span class="title class_">ma</span>.glasnost.orika.impl.GeneratedObjectFactory &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">create</span><span class="params">(Object s, ma.glasnost.orika.MappingContext mappingContext)</span> </span><br><span class="line">&#123;<span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.lang.IllegalArgumentException(<span class="string">&quot;source object must be not null&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (s <span class="keyword">instanceof</span> orika.A) &#123;</span><br><span class="line">orika.<span class="type">A</span> <span class="variable">source</span> <span class="operator">=</span> (orika.A) s;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    java.lang.<span class="type">String</span> <span class="variable">arg0</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    arg0 = ((java.lang.String)source.getA()); </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">orika</span>.B(arg0);</span><br><span class="line">&#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (RuntimeException)e;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.lang.RuntimeException(<span class="string">&quot;Error while constructing new B instance&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">orika</span>.B();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Spring-集成"><a href="#Spring-集成" class="headerlink" title="Spring 集成"></a>Spring 集成</h2><ol>
<li><p>引入依赖</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;ma.glasnost.orika:orika-core:1.5.4&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用方式</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanCopyConfig</span> <span class="keyword">extends</span> <span class="title class_">ConfigurableMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(MapperFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(factory);</span><br><span class="line">        factory.classMap(A.class, B.class)</span><br><span class="line">                .field(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">                .byDefault()</span><br><span class="line">                .register();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> MapperFacade mapperFacade;</span><br><span class="line"></span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> mapperFacade.map(b, A.class);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>将一个大任务拆分为多个小任务，并且使各个小任务并行异步执行，是常见的性能优化形式，Java 并发包中的 CompletableFuture 能够帮助程序很方便的实现这一优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;CompletableFuture&lt;Void&gt;&gt; completableFutures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (:) &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; doSomething())</span><br><span class="line">            .exceptionally(ex -&gt; &#123;</span><br><span class="line">                log.error(<span class="string">&quot;something wrong&quot;</span>, ex);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">    completableFutures.add(completableFuture);</span><br><span class="line">&#125;</span><br><span class="line">CompletableFuture.allOf(completableFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Orika 在 CompletableFuture 中使用</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> MapperFacade mapperFacade;</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> mapperFacade.map(b, A.class);</span><br><span class="line">&#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">    log.error(<span class="string">&quot;something wrong&quot;</span>, ex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>异常</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: ma.glasnost.orika.impl.generator.CompilerStrategy$SourceCodeGenerationException: Error compiling ma.glasnost.    orika.generated.Orika_XXX_YYY_Mapper383167261886761$<span class="number">8</span></span><br><span class="line">        at ma.glasnost.orika.impl.generator.JavassistCompilerStrategy.compileClass(JavassistCompilerStrategy.java:<span class="number">253</span>)</span><br><span class="line">        at ma.glasnost.orika.impl.generator.SourceCodeContext.compileClass(SourceCodeContext.java:<span class="number">228</span>)</span><br><span class="line">        at ma.glasnost.orika.impl.generator.SourceCodeContext.getInstance(SourceCodeContext.java:<span class="number">244</span>)</span><br><span class="line">        at ma.glasnost.orika.impl.generator.MapperGenerator.build(MapperGenerator.java:<span class="number">73</span>)</span><br><span class="line">        ... <span class="number">17</span> common frames omitted</span><br><span class="line">Caused by: javassist.CannotCompileException: by java.lang.reflect.InvocationTargetException</span><br><span class="line">        at javassist.util.proxy.DefineClassHelper$JavaOther.defineClass(DefineClassHelper.java:<span class="number">220</span>)</span><br><span class="line">        at javassist.util.proxy.DefineClassHelper$Java11.defineClass(DefineClassHelper.java:<span class="number">52</span>)</span><br><span class="line">        at javassist.util.proxy.DefineClassHelper.toClass(DefineClassHelper.java:<span class="number">260</span>)</span><br><span class="line">        at javassist.ClassPool.toClass(ClassPool.java:<span class="number">1240</span>)</span><br><span class="line">        at javassist.CtClass.toClass(CtClass.java:<span class="number">1392</span>)</span><br><span class="line">        at ma.glasnost.orika.impl.generator.JavassistCompilerStrategy.compileClass(JavassistCompilerStrategy.java:<span class="number">246</span>)</span><br><span class="line">        ... <span class="number">20</span> common frames omitted</span><br><span class="line">Caused by: java.lang.reflect.InvocationTargetException: <span class="literal">null</span></span><br><span class="line">        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">77</span>)</span><br><span class="line">        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        at java.base/java.lang.reflect.Method.invoke(Method.java:<span class="number">568</span>)</span><br><span class="line">        at javassist.util.proxy.DefineClassHelper$JavaOther.defineClass(DefineClassHelper.java:<span class="number">214</span>)</span><br><span class="line">        ... <span class="number">25</span> common frames omitted</span><br><span class="line">Caused by: java.lang.NoClassDefFoundError: ma/glasnost/orika/impl/GeneratedMapperBase</span><br><span class="line">        at java.base/java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">        at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">1012</span>)</span><br><span class="line">        ... <span class="number">30</span> common frames omitted</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: ma.glasnost.orika.impl.GeneratedMapperBase</span><br><span class="line">        at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:<span class="number">641</span>)</span><br><span class="line">        at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:<span class="number">188</span>)</span><br><span class="line">        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">520</span>)</span><br><span class="line">        ... <span class="number">32</span> common frames omitted</span><br></pre></td></tr></table></figure>
</li>
<li><p>JarLauncher</p>
<p> Spring 应用被打包为 FatJar 的形式，并通过 JarLauncher 来启动 FatJar 应用，JarLauncher 自定义了类加载器 org.springframework.boot.    loader.LaunchedURLClassLoader@25f38edc，其 Parent ClassLoader 被设置为 SystemClassLoader</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JarLauncher#launch(..)</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isExploded()) &#123;</span><br><span class="line">                JarFile.registerUrlProtocolHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> createClassLoader(getClassPathArchivesIterator());</span><br><span class="line">        <span class="type">String</span> <span class="variable">jarMode</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;jarmode&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">launchClass</span> <span class="operator">=</span> (jarMode != <span class="literal">null</span> &amp;&amp; !jarMode.isEmpty()) ? JAR_MODE_LAUNCHER : getMainClass();</span><br><span class="line">        launch(args, launchClass, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> ClassLoader <span class="title function_">createClassLoader</span><span class="params">(URL[] urls)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LaunchedURLClassLoader</span>(isExploded(), getArchive(), urls, getClass().getClassLoader());</span><br><span class="line">        <span class="comment">// Parent ClassLoader 是 getClass().getClassLoader()，即 SystemClassLoader</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ForkJoinPool</p>
<p> CompletableFuture 默认使用的是 ForkJoinPool 线程池，线程上下文加载器为 SystemClassLoader</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ForkJoinWorkerThread(ThreadGroup group, ForkJoinPool pool,</span><br><span class="line">                        <span class="type">boolean</span> useSystemClassLoader, <span class="type">boolean</span> isInnocuous) &#123;</span><br><span class="line">    <span class="built_in">super</span>(group, <span class="literal">null</span>, pool.nextWorkerThreadName(), <span class="number">0L</span>);</span><br><span class="line">    <span class="type">UncaughtExceptionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (<span class="built_in">this</span>.pool = pool).ueh;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>.WorkQueue(<span class="built_in">this</span>, isInnocuous);</span><br><span class="line">    <span class="built_in">super</span>.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">super</span>.setUncaughtExceptionHandler(handler);</span><br><span class="line">    <span class="keyword">if</span> (useSystemClassLoader)</span><br><span class="line">        <span class="built_in">super</span>.setContextClassLoader(ClassLoader.getSystemClassLoader()); <span class="comment">// 线程上下文加载器被设置为 SystemClassLoader</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原因</strong></p>
<p> Orika 中的 Javassist 使用 ForkJoinPool 线程上下文加载器 SystemClassLoader 加载 Java Bean，而 Java Bean 是由 Spring 自定义的 LaunchedURLClassLoader 加载，类加载路线：SystemClassLoader -&gt; LaunchedURLClassLoader，违反了加载器类的可见性</p>
</li>
<li><p>解决</p>
<p> 使用 ThreadPoolTaskExecutor 线程池运行 CompletableFuture</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(name = &quot;asyncServiceExecutor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Executor <span class="title function_">asyncServiceExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;-async-&quot;</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Executor asyncServiceExecutor;</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> mapperFacade.map(b, A.class);</span><br><span class="line">&#125;,asyncServiceExecutor).exceptionally(ex -&gt; &#123;</span><br><span class="line">    log.error(<span class="string">&quot;something wrong&quot;</span>, ex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTQ5MTYwNTI1XX0=
-->
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>多线程</tag>
        <tag>JVM</tag>
        <tag>异步</tag>
        <tag>Orika</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的@Retryable</title>
    <url>/2019/07/25/SpringRetryable/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/13.png" class="full-image" />

<h1 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h1><p>@Retryable由spring-retry模块提供，在方法或类上添加@Retryable注解可以实现方法调用失败的重试。可以指定失败重试的次数、fallback方法</p>
<h2 id="Retryable"><a href="#Retryable" class="headerlink" title="@Retryable"></a>@Retryable</h2><p>设置重试的次数、指定需要重试的异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Retryable &#123;</span><br><span class="line">    // 指定拦截方法</span><br><span class="line">    String interceptor() default &quot;&quot;;</span><br><span class="line">    // 指定需要重试异常，若未指定异常则重试异常为 Exception.class</span><br><span class="line">    Class&lt;? extends Throwable&gt;[] value() default &#123;&#125;;</span><br><span class="line">    // 最大尝试次数（包含第一次</span><br><span class="line">    int maxAttempts() default 3;</span><br><span class="line">        Class&lt;? extends Throwable&gt;[] include() default &#123;&#125;;</span><br><span class="line">    Class&lt;? extends Throwable&gt;[] exclude() default &#123;&#125;;</span><br><span class="line">    String label() default &quot;&quot;;</span><br><span class="line">    boolean stateful() default false;</span><br><span class="line">    String maxAttemptsExpression() default &quot;&quot;;</span><br><span class="line">    Backoff backoff() default @Backoff();</span><br><span class="line">    String exceptionExpression() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="Backoff"><a href="#Backoff" class="headerlink" title="@Backoff"></a>@Backoff</h2><p>设置重试的时间间隔，不同值的组合会确定不同的计算间隔方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Import(RetryConfiguration.class)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Backoff &#123;</span><br><span class="line">    long value() default 1000;</span><br><span class="line">    // 若delay=0未配置，则delay=value</span><br><span class="line">    long delay() default 0;</span><br><span class="line">    long maxDelay() default 0;</span><br><span class="line">    double multiplier() default 0;</span><br><span class="line">    String delayExpression() default &quot;&quot;;</span><br><span class="line">    String maxDelayExpression() default &quot;&quot;;</span><br><span class="line">    String multiplierExpression() default &quot;&quot;;</span><br><span class="line">    boolean random() default false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Recover"><a href="#Recover" class="headerlink" title="@Recover"></a>@Recover</h2><p>重试失败后会进入@Recover注解的方法</p>
<h1 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h1><p>在项目中假设调用的外部服务发生网络异常、服务器故障、死机状况，在这些情况下通常会重试几次调用，假如最终还是失败则会返回特定的内容。如果可能在后续的尝试中会成功，则有重试的必要。你可能会写一段循环代码然后计数来实现重试功能，@Retryable提供了更便捷的方式来实现错误重试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEFORE:</span><br><span class="line">    int retries = 0;</span><br><span class="line">    long wait = 1;</span><br><span class="line">            while (retries &lt; maxRetries) &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(wait);</span><br><span class="line">        // 处理任务</span><br><span class="line">        wait *= 2;</span><br><span class="line">        ++retries;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">AFTER:</span><br><span class="line">    @Retryable(maxAttempts = 3, backoff = @Backoff(delay = 1000,multiplier = 1.5,maxDelay = 3000))</span><br><span class="line">    String retryForError();</span><br><span class="line">    @Recover</span><br><span class="line">    String recoverResponse(Exception e);</span><br></pre></td></tr></table></figure>

<h1 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h1><p>@Retryable如何使用？怎么实现的？</p>
<ul>
<li>Requirements<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface RetryService &#123;</span><br><span class="line"></span><br><span class="line">    @Retryable(maxAttempts = 3,</span><br><span class="line">               backoff = @Backoff(delay = 1000,multiplier = 1.5,maxDelay = 3000),</span><br><span class="line">               value = ArithmeticException.class)</span><br><span class="line">    String retryForError();</span><br><span class="line"></span><br><span class="line">    @Recover</span><br><span class="line">    String recoverResponse(ArithmeticException e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RetryServiceImpl implements RetryService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String retryForError() &#123;</span><br><span class="line">        System.out.println(&quot;retryForError&quot;);</span><br><span class="line">        int a = 10 / 0;</span><br><span class="line">        return &quot;Success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String recoverResponse(ArithmeticException e) &#123;</span><br><span class="line">        return &quot;RecoverResponse Success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class RetryController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RetryService retryService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/retry&quot;)</span><br><span class="line">    public String retryService() &#123;</span><br><span class="line">        return retryService.retryForError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>AOP</p>
<ol>
<li>RetryConfiguration 创建pointcut（Retryable注解）, 创建Advice（AnnotationAwareRetryOperationsInterceptor）</li>
<li>AnnotationAwareRetryOperationsInterceptor 委托给默认的 RetryOperationsInterceptor</li>
</ol>
<h3 id="BackOffPolicy"><a href="#BackOffPolicy" class="headerlink" title="BackOffPolicy"></a>BackOffPolicy</h3><p>@Backoff</p>
<ol>
<li>multiplier &gt; 0 and random &#x3D; false<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">initialInterval = delay</span><br><span class="line">maxInterval = maxDelay &gt; initialInterval ? maxDelay : ExponentialBackOffPolicy.DEFAULT_MAX_INTERVAL(30000毫秒)</span><br><span class="line">        public synchronized long getSleepAndIncrement() &#123;</span><br><span class="line">            long sleep = this.interval;</span><br><span class="line">            if (sleep &gt; maxInterval) &#123;</span><br><span class="line">                sleep = maxInterval;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                this.interval = getNextInterval();</span><br><span class="line">            &#125;</span><br><span class="line">            return sleep;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"> protected long getNextInterval() &#123;</span><br><span class="line">            return (long) (this.interval * this.multiplier);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li>multiplier &gt; 0 and random &#x3D; true<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized long getSleepAndIncrement() &#123;</span><br><span class="line">    // 1 中方法</span><br><span class="line">    long next = super.getSleepAndIncrement();</span><br><span class="line">    next = (long) (next * (1 + r.nextFloat() * (getMultiplier() - 1)));</span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>maxDelay &gt; initialInterval<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long delta = maxDelay==initialInterval ? 0 : random.nextInt((int) (maxDelay - minBackOffPeriod));</span><br><span class="line">sleeper.sleep(minBackOffPeriod + delta );</span><br></pre></td></tr></table></figure></li>
<li>其他<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sleeper.sleep(delay);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>@Recover只对同类中的@Retryable生效</li>
<li>多个@Recover方法，同一种异常参数。相当于讲这些方法（Method）放在Set中，取出的第一个@Recover方法将会是fallback方法</li>
<li>多个@Recover方法，不同种异常参数。若@Recover方法参数距离@Retryable方法抛出的异常最近（根据重试的最后一次抛出的异常作为查找依据）则此@Recover方法将会是fallback方法。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RecoverAnnotationRecoveryHandler.findClosestMatch</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> If you find that one thing that keeps you going, you’ve got to hold onto it. - Red</p>
<p><a href="https://movie.douban.com/subject/1292052/">The Shawshank Redemption</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的@Scheduled</title>
    <url>/2019/05/16/SpringScheduled/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/15.png" class="full-image" />

<h1 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h1><p>@Scheduled 由Spring定义，用于将方法设置为调度任务。如：方法每隔十秒钟被执行、方法在固定时间点被执行等</p>
<ol>
<li><p>@Scheduled(fixedDelay &#x3D; 1000)<br>上一个任务结束到下一个任务开始的时间间隔为固定的1秒，任务的执行总是要先等到上一个任务的执行结束</p>
</li>
<li><p>@Scheduled(fixedRate &#x3D; 1000)<br>每间隔1秒钟就会执行任务（如果任务执行的时间超过1秒，则下一个任务在上一个任务结束之后立即执行）</p>
</li>
<li><p>@Scheduled(fixedDelay &#x3D; 1000, initialDelay &#x3D; 2000)<br>第一次执行的任务将会延迟2秒钟后才会启动</p>
</li>
<li><p>@Scheduled(cron &#x3D; “0 15 10 15 * ?”)<br>Cron表达式，每个月的15号上午10点15开始执行任务</p>
</li>
<li><p>在配置文件中配置任务调度的参数</p>
<blockquote>
<p>@Scheduled(fixedDelayString &#x3D; “${fixedDelay.in.milliseconds}”)<br>@Scheduled(fixedRateString &#x3D; “${fixedRate.in.milliseconds}”)<br>@Scheduled(cron &#x3D; “${cron.expression}”)</p>
</blockquote>
</li>
</ol>
<span id="more"></span>

<h1 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h1><p>@Scheduled使用方便，不需要自己去写复杂的任务调度。注解的方式非常灵活，只需要在方法上添加@Scheduled注解就能定义调度的任务，任何无参的方法都可以瞬间成为供调度的任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 关闭线程池中超过空闲时间的线程</span><br><span class="line"> * @param poolingConnectionManager</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public Runnable idleConnectionMonitor(final PoolingHttpClientConnectionManager poolingConnectionManager) &#123;</span><br><span class="line">    return new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        @Scheduled(fixedDelay = 10000, initialDelay = 1000)</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (poolingConnectionManager != null) &#123;</span><br><span class="line">                    log.info(&quot;run IdleConnectionMonitor - Closing expired and idle connections...&quot;);</span><br><span class="line">                    poolingConnectionManager.closeExpiredConnections();</span><br><span class="line">                    poolingConnectionManager.closeIdleConnections(properties.getCloseIdleConnectionWaitTimeSecs(), TimeUnit.SECONDS);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    log.info(&quot;run IdleConnectionMonitor - Http Client Connection manager is not initialised&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.error(&quot;run IdleConnectionMonitor - Exception occurred. msg=&#123;&#125;, e=&#123;&#125;&quot;, e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h1><p>Spring是如何实现如此简洁的任务调度定义的？怎么使用@Scheduled？</p>
<ul>
<li>Requirements</li>
</ul>
<ol>
<li>Spring容器中需要创建 Bean: <strong>ScheduledAnnotationBeanPostProcessor</strong></li>
<li>Spring容器中需要有<strong>TaskScheduler</strong>实现类的实例</li>
<li>无参方法添加@<strong>Scheduled</strong>注解</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>扩展有两种方式</p>
<ul>
<li>实现SchedulingConfigurer接口<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    // 优先级高</span><br><span class="line">    @Configuration</span><br><span class="line">    public class SchedulerConfig implements SchedulingConfigurer &#123;          </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;</span><br><span class="line">        taskRegistrar.setTaskScheduler(threadPoolTaskScheduler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(destroyMethod = &quot;shutdown&quot;)</span><br><span class="line">    public ThreadPoolTaskScheduler threadPoolTaskScheduler() &#123;</span><br><span class="line">        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();</span><br><span class="line">        scheduler.setThreadNamePrefix(&quot;poolmary&amp;mark&quot;);</span><br><span class="line">        scheduler.setPoolSize(50);</span><br><span class="line">        return scheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建TaskScheduler的实现Bean<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 相对实现SchedulingConfigurer接口的方式，优先级低</span><br><span class="line">@Bean</span><br><span class="line">public TaskScheduler taskScheduler() &#123;              </span><br><span class="line">    ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();</span><br><span class="line">    scheduler.setThreadNamePrefix(&quot;poolScheduler&quot;);</span><br><span class="line">    scheduler.setPoolSize(50);</span><br><span class="line">    return scheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li><strong>ScheduledAnnotationBeanPostProcessor</strong>的<strong>postProcessAfterInitialization</strong>方法将@<strong>Scheduled</strong>的方法包装为指定的task添加到<strong>ScheduledTaskRegistrar</strong>中</li>
<li><strong>ScheduledAnnotationBeanPostProcessor</strong>会监听Spring的容器初始化事件，在Spring容器初始化完成后进行<strong>TaskScheduler</strong>实现类实例的查找，若发现有<strong>SchedulingConfigurer</strong>的实现类实例，则跳过3</li>
<li>查找<strong>TaskScheduler</strong>的实现类实例默认是通过类型查找，若有多个实现则会查找名字为”taskScheduler”的实现Bean，若没有找到则在 <strong>ScheduledTaskRegistrar</strong>调度任务的时候会创建一个<strong>newSingleThreadScheduledExecutor</strong>，将<strong>TaskScheduler</strong>的实现类实例设置到<strong>ScheduledTaskRegistrar</strong>属性中</li>
<li><strong>ScheduledTaskRegistrar</strong>的<strong>scheduleTasks</strong>方法触发任务调度</li>
<li>真正调度任务的类是<strong>TaskScheduler</strong>实现类中的<strong>ScheduledExecutorService</strong>，由<strong>J.U.C</strong>提供</li>
</ol>
<h2 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class SchedulerConfigDemo &#123;</span><br><span class="line"></span><br><span class="line">    private final static SimpleDateFormat sdf = new SimpleDateFormat(&quot;hh:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    private final static Logger log = LoggerFactory.getLogger(SchedulerConfigDemo.class);</span><br><span class="line"></span><br><span class="line">    @Scheduled(fixedRate = 2000, initialDelay = 1000)</span><br><span class="line">    public void testScheduler() &#123;</span><br><span class="line">        log.info(&quot;start &#123;&#125;&quot;, sdf.format(new Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TaskScheduler taskScheduler() &#123;</span><br><span class="line">        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();</span><br><span class="line">        scheduler.setThreadNamePrefix(&quot;poolScheduler&quot;);</span><br><span class="line">        scheduler.setPoolSize(10);</span><br><span class="line">        return scheduler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> Music is the strongest form of magic. - 1900</p>
<p><a href="https://movie.douban.com/subject/1292001/">La leggenda del pianista sull’oceano</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Stack</title>
    <url>/2023/02/06/Stack/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/47.png" class="full-image" />

<p>Stack 是一种非常重要的数据类型，在运算表达式的实现、DFS算法、进制转换中都会用到 Stack</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Klaus Samelson 和 Friedrich L. Bauer 在1955年提出了 <strong>栈</strong> 的概念，并在1957年申请了专利，Klaus Samelson 在1988年3月去世时，Friedrich L. Bauer 因发明了栈原理而获得IEEE计算机先锋奖。其实早在1946年 Alan M. Turing 就提出过这种数据堆叠的方式，图灵使用 “bury” 和 “unbury” 表示子程序的调用与返回</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>栈是一种抽象的数据类型，它是一种后进先出（LIFO）的数据组织方式，核心操作包括 push 、pop。具体表现如下</p>
<span id="more"></span>

<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>新增元素<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DS/stackimage.png" alt="imag"></p>
<h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p>删除元素<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/DS/popstackimage.png" alt="imag"></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>栈的底层数据结构可以基于数组或链表实现，因此栈是一种 <strong>线性</strong><sup>元素之间有着固定的顺序关系</sup> 数据结构。这里我们使用 Rust 中的 <strong>Vec</strong><sup>底层是动态数组</sup> 实现 Stack。由于底层使用数组实现，所以 push 和 pop 的操作时间复杂度都是 O(1)，效率高于链表实现</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;T&gt; &#123;</span><br><span class="line">    top: <span class="type">usize</span>,</span><br><span class="line">    data: <span class="type">Vec</span>&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Stack&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Stack &#123;</span><br><span class="line">            top: <span class="number">0</span>,</span><br><span class="line">            data: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, val: T) &#123;</span><br><span class="line">        <span class="keyword">self</span>.data.<span class="title function_ invoke__">push</span>(val);</span><br><span class="line">        <span class="keyword">self</span>.top += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">pop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.top == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.top -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.data.<span class="title function_ invoke__">pop</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">peek</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;T&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.top == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.data.<span class="title function_ invoke__">get</span>(<span class="keyword">self</span>.top - <span class="number">1</span>) <span class="comment">// 只查看，不删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_empty</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.top == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">size</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.top</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>Stack 的应用非常广泛，包括但不限于</p>
<ul>
<li>数制转换：将十进制数转换为二进制、八进制或十六进制</li>
<li>括号匹配：检查括号是否匹配</li>
<li>函数调用：保存和恢复函数状态</li>
<li>运算表达式：前缀、中、后缀表达式求值</li>
<li>编辑器的Undo&#x2F;Redo操作</li>
<li>。。。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Stack</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>You got a dream… You gotta protect it. - Chris Gardner</p>
<p><a href="https://movie.douban.com/subject/1849031/">The Pursuit of Happyness</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>The Clean Coder</title>
    <url>/2023/02/03/TheCleanCoder/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/45.png" class="full-image" />

<p>如何提升程序员的职业素养？<br><i class="fa fa-arrow-down" aria-hidden="true"></i><br>试试如下几点！</p>
<blockquote>
<ol>
<li>编码：<a href="https://whathowhy.com/2023/02/03/CleanCode/">编写高质量代码</a></li>
<li>是&#x2F;否：尽己所能，承诺的事情一定要兑现，无法承诺的事情要敢于说不</li>
<li>沟通：与团队、利益相关方进行有效沟通与互助交流</li>
<li>责任：对代码、项目、工作质量承担个人责任</li>
<li>预估：通过有效的方法提供可信的预估结果。如：PERT计算方法等</li>
<li>时间：管理好自己的时间和注意力。如：任务优先级、分辨并拒绝无效会议等</li>
<li>压力：学习如何应对压力。如：避免产生压力、寻求帮助等</li>
<li>学习：对自己负责。持续学习，提升技能，不断成长</li>
</ol>
</blockquote>
<p><strong>推荐书籍</strong>：<a href="https://book.douban.com/subject/11614538/">程序员的职业素养</a></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure. - Conway’s law</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>使用RestTemplate</title>
    <url>/2019/11/01/UseRestTemplate/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/9.png" class="full-image" />

<p>记录如何使用Spring中的RestTemplate(with apache.httpcomponents)发起 REST API请求</p>
<h1 id="REQUIREMENTS"><a href="#REQUIREMENTS" class="headerlink" title="REQUIREMENTS"></a>REQUIREMENTS</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.5.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="SETTING-UP"><a href="#SETTING-UP" class="headerlink" title="SETTING UP"></a>SETTING UP</h1><h2 id="HttpConfigProperties"><a href="#HttpConfigProperties" class="headerlink" title="HttpConfigProperties"></a>HttpConfigProperties</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Data</span><br><span class="line">public class HttpConfigProperties &#123;</span><br><span class="line"></span><br><span class="line">    private Integer maxTotalConnections = 200;</span><br><span class="line">    private Integer maxPerRoute = 100;</span><br><span class="line">    /**</span><br><span class="line">     * 等待连接建立的超时时间 5秒</span><br><span class="line">     */</span><br><span class="line">    private Integer connectTimeout = 5000;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 等待数据传输的超时时间 15秒</span><br><span class="line">     */</span><br><span class="line">    private Integer socketTimeout = 15000;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 等待请求连接池的超时时间 5秒</span><br><span class="line">     */</span><br><span class="line">    private Integer connectionRequestTimeout = 5000;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 允许连接idle的时间 10秒</span><br><span class="line">     */</span><br><span class="line">    private Integer keeAliveTimeMillis = 10000;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * idle最大时间</span><br><span class="line">     */</span><br><span class="line">    private Integer closeIdleConnectionWaitTimeSecs = 20;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HttpClientPoolingConfig"><a href="#HttpClientPoolingConfig" class="headerlink" title="HttpClientPoolingConfig"></a>HttpClientPoolingConfig</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableScheduling</span><br><span class="line">@Slf4j</span><br><span class="line">public class HttpClientPoolingConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private HttpConfigProperties properties;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;poolingConnectionManager&quot;)</span><br><span class="line">    public PoolingHttpClientConnectionManager poolingConnectionManager() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            LayeredConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(SSLContext.getDefault());</span><br><span class="line">            Registry&lt;ConnectionSocketFactory&gt; socketFactoryRegistry = RegistryBuilder.&lt;ConnectionSocketFactory&gt;create()</span><br><span class="line">                    .register(&quot;https&quot;, sslsf)</span><br><span class="line">                    .register(&quot;http&quot;, new PlainConnectionSocketFactory())</span><br><span class="line">                    .build();</span><br><span class="line">            PoolingHttpClientConnectionManager poolingConnectionManager = new PoolingHttpClientConnectionManager(socketFactoryRegistry);</span><br><span class="line">            poolingConnectionManager.setMaxTotal(properties.getMaxTotalConnections());</span><br><span class="line">            poolingConnectionManager.setDefaultMaxPerRoute(properties.getMaxPerRoute());</span><br><span class="line">            return poolingConnectionManager;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;Pooling Connection Manager Initialisation failure because of &quot; + e.getMessage(), e);</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;connectionKeepAliveStrategy&quot;)</span><br><span class="line">    public ConnectionKeepAliveStrategy connectionKeepAliveStrategy() &#123;</span><br><span class="line">        return (response, context) -&gt; &#123;</span><br><span class="line">            HeaderElementIterator it = new BasicHeaderElementIterator</span><br><span class="line">                    (response.headerIterator(HTTP.CONN_KEEP_ALIVE));</span><br><span class="line">            while (it.hasNext()) &#123;</span><br><span class="line">                HeaderElement he = it.nextElement();</span><br><span class="line">                String param = he.getName();</span><br><span class="line">                String value = he.getValue();</span><br><span class="line"></span><br><span class="line">                if (value != null &amp;&amp; param.equalsIgnoreCase(&quot;timeout&quot;)) &#123;</span><br><span class="line">                    return Long.parseLong(value) * 1000;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return properties.getKeeAliveTimeMillis();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;httpClient&quot;)</span><br><span class="line">    public CloseableHttpClient httpClient(@Qualifier(value = &quot;connectionKeepAliveStrategy&quot;) ConnectionKeepAliveStrategy connectionKeepAliveStrategy) &#123;</span><br><span class="line">        RequestConfig requestConfig = RequestConfig.custom()</span><br><span class="line">                .setConnectionRequestTimeout(properties.getConnectionRequestTimeout())</span><br><span class="line">                .setConnectTimeout(properties.getConnectTimeout())</span><br><span class="line">                .setSocketTimeout(properties.getSocketTimeout()).build();</span><br><span class="line"></span><br><span class="line">        return HttpClients.custom()</span><br><span class="line">                .setDefaultRequestConfig(requestConfig)</span><br><span class="line">                .setConnectionManager(poolingConnectionManager())</span><br><span class="line">                .setKeepAliveStrategy(connectionKeepAliveStrategy)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Runnable idleConnectionMonitor(@Qualifier(value = &quot;poolingConnectionManager&quot;) PoolingHttpClientConnectionManager poolingConnectionManager) &#123;</span><br><span class="line">        return new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            @Scheduled(fixedDelay = 10000, initialDelay = 1000)</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (poolingConnectionManager != null) &#123;</span><br><span class="line">                        log.info(&quot;run IdleConnectionMonitor - Closing expired and idle connections...&quot;);</span><br><span class="line">                        poolingConnectionManager.closeExpiredConnections();</span><br><span class="line">                        poolingConnectionManager.closeIdleConnections(properties.getCloseIdleConnectionWaitTimeSecs(), TimeUnit.SECONDS);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        log.info(&quot;run IdleConnectionMonitor - Http Client Connection manager is not initialised&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;run IdleConnectionMonitor - Exception occurred. msg=&#123;&#125;, e=&#123;&#125;&quot;, e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RestTemplateConfig"><a href="#RestTemplateConfig" class="headerlink" title="RestTemplateConfig"></a>RestTemplateConfig</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Slf4j</span><br><span class="line">public class RestTemplateConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate(@Qualifier(value = &quot;httpClient&quot;) CloseableHttpClient httpClient) &#123;</span><br><span class="line">        HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);</span><br><span class="line">        RestTemplate restTemplate = new RestTemplate(clientHttpRequestFactory);</span><br><span class="line">        List&lt;ClientHttpRequestInterceptor&gt; interceptors</span><br><span class="line">                = restTemplate.getInterceptors();</span><br><span class="line">        if (CollectionUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        interceptors.add(new RestTemplateLogInterceptor());</span><br><span class="line">        restTemplate.setInterceptors(interceptors);</span><br><span class="line">        restTemplate.getMessageConverters().add(0, new StringHttpMessageConverter(Charset.forName(&quot;UTF-8&quot;)));</span><br><span class="line">        return restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RestTemplateLogInterceptor"><a href="#RestTemplateLogInterceptor" class="headerlink" title="RestTemplateLogInterceptor"></a>RestTemplateLogInterceptor</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class RestTemplateLogInterceptor implements ClientHttpRequestInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException &#123;</span><br><span class="line">        ClientHttpResponse response = execution.execute(request, body);</span><br><span class="line">        if (response.getStatusCode() != HttpStatus.OK) &#123;</span><br><span class="line">            log.error(&quot;RESTful api error, request is &#123;&#125; ,response is &#123;&#125;&quot;, request.getURI(), response.getStatusCode());</span><br><span class="line">        &#125;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h1><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Spring/getProductById.png" alt="image"></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Spring/getProductByProduct.png" alt="image"></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Spring/getProductList.png" alt="image"></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Spring/addProduct.png" alt="image"></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Spring/addProductFormData.png" alt="image"></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> I’m just a girl, standing in front of a boy, asking him to love her. - Allie</p>
<p><a href="https://movie.douban.com/subject/1309163/">The Notebook</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-访问者模式</title>
    <url>/2023/03/24/VisitorDesign/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/53.png" class="full-image" />

<p>访问者模式是一种行为型设计模式，它可以将相关操作分离并组织在一起，该设计模式允许你在不更改现有代码的情况下很容易就可以添加新的操作，从而提高代码的可维护性和可扩展性。访问者模式是一种强大的设计模式，可以帮助你更好的组织和管理复杂的对象结构。在本篇博客中我们以单据快照为例，来说明访问者模式的特点</p>
<span id="more"></span>

<h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><p>假设我们的系统中存在多种类型的单据信息，现要求为所有的单据类型创建 HTML 快照</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/visitor/trans.png" alt="imag"></p>
<p>我们可以为系统中每个单据类创建快照方法，但这种方式违反了 <strong>SRP</strong> 设计原则，并且如果快照的生成方式有所变化，我们需要找到所有不同的单据类，修改其中的快照实现，这是一个很大的工作量</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/visitor/trans_extend.png" alt="imag"></p>
<p>既然这种做法违反了 <strong>SRP</strong> 原则，那我们尝试把导出快照功能从不同单据类中分离出来</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/visitor/trans_snapshot.png" alt="imag"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;TransRecord&gt; transRecordList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">transRecordList.add(<span class="keyword">new</span> <span class="title class_">AfterSaleTransRecord</span>());</span><br><span class="line">transRecordList.add(<span class="keyword">new</span> <span class="title class_">InsuranceTransRecord</span>());</span><br><span class="line">transRecordList.add(<span class="keyword">new</span> <span class="title class_">MaintainTransRecord</span>());</span><br><span class="line">transRecordList.add(<span class="keyword">new</span> <span class="title class_">OrderTransRecord</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">TransHtml</span> <span class="variable">noramal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NormalTransHtml</span>();</span><br><span class="line"><span class="type">TransHtml</span> <span class="variable">special</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpecialTransHtml</span>();</span><br><span class="line"><span class="keyword">for</span> (TransRecord transRecord : transRecordList) &#123;</span><br><span class="line">    noramal.snapshot(transRecord); <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 不支持双分派，如代码中的 <strong>TransHtml</strong> 在运行时会推断出对象的类型为 <strong>NormalTransHtml</strong>，然后调用具体方法，但是无法通过参数 <strong>TransRecord</strong> 的类型推导出应该正确调用的方法</p>
<blockquote>
<p>双分派：根据涉及的两个对象的运行时类型来决定调用的具体函数</p>
</blockquote>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>访问者模式中主要有以下角色</p>
<ol>
<li>Element: 它定义了 <strong>accept()</strong> 方法，接受一个 Visitor 对象作为参数，以便可以对其访问</li>
<li>ConcreteElement: 实现 Element 接口，并将自己作为参数传递给 Visitor</li>
<li>Visitor: 定义了访问对象结构中元素的新操作方式</li>
<li>ConcreteVisitor: 实现 Visitor 接口，具体操作实现</li>
<li>ObjectStructure: 元素结合，以便访问者可以访问其中的元素</li>
</ol>
<p>我们通过访问者模式为不同单据类型实现 HTML 快照导出功能</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/visitor/trans_visitor.png" alt="imag"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTransRecord</span> <span class="keyword">extends</span> <span class="title class_">TransRecord</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long useId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(TransHtml visitor)</span> &#123;</span><br><span class="line">        visitor.snapshot(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">List&lt;Accessible&lt;TransHtml&gt;&gt; transRecordList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">transRecordList.add(<span class="keyword">new</span> <span class="title class_">AfterSaleTransRecord</span>());</span><br><span class="line">transRecordList.add(<span class="keyword">new</span> <span class="title class_">InsuranceTransRecord</span>());</span><br><span class="line">transRecordList.add(<span class="keyword">new</span> <span class="title class_">MaintainTransRecord</span>());</span><br><span class="line">transRecordList.add(<span class="keyword">new</span> <span class="title class_">OrderTransRecord</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">TransHtml</span> <span class="variable">noramal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NormalTransHtml</span>();</span><br><span class="line"><span class="comment">// TransHtml special = new SpecialTransHtml();</span></span><br><span class="line"><span class="keyword">for</span> (Accessible&lt;TransHtml&gt; accessible : transRecordList) &#123;</span><br><span class="line">    accessible.accept(noramal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>以下是访问者设计模式常见应用场景</p>
<ol>
<li>GUI框架中，遍历组件层次结构并执行操作，如：计算布局</li>
<li>游戏中，遍历游戏中的对象并执行操作，如：渲染</li>
<li>数据库系统中，遍历数据并执行操作，如：聚合</li>
</ol>
]]></content>
      <categories>
        <category>Design Pattern</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器与主机监控</title>
    <url>/2021/06/19/docker-host-monitor/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/8.png" class="full-image" />

<h1 id="监控-Docker"><a href="#监控-Docker" class="headerlink" title="监控 Docker"></a>监控 Docker</h1><p>容器的优势让越来越多的应用开始容器化，如何监控容器的健康越来越重要。文章记录如何围绕主机与容器的CPU、内存、磁盘、网络等指标建立Docker应用监控系统</p>
<h2 id="组件准备"><a href="#组件准备" class="headerlink" title="组件准备"></a>组件准备</h2><p>文章目的是建立Docker的监控系统，所以系统中除了如下组件要求，还需要监控的系统中安装并使用了Docker</p>
<ol>
<li>node-exporter</li>
<li>cAdvisor</li>
<li>prometheus</li>
<li>grafana</li>
</ol>
<span id="more"></span>

<h2 id="node-exporter"><a href="#node-exporter" class="headerlink" title="node-exporter"></a>node-exporter</h2><p>node-exporter 用于获取主机HOST的系统指标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动 node-exporter</span><br><span class="line"></span><br><span class="line">docker run -d --name=node-exporter -p 9100:9100 \</span><br><span class="line">-v &quot;/proc:/host/proc&quot; \</span><br><span class="line">-v &quot;/sys:/host/sys&quot; \</span><br><span class="line">-v &quot;/:/rootfs&quot; \</span><br><span class="line">prom/node-exporter \</span><br><span class="line">--path.procfs /host/proc \</span><br><span class="line">--path.sysfs /host/sys</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证指标数据，浏览器打开 http://localhost:9100/metrics</span><br><span class="line"></span><br><span class="line"># HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.</span><br><span class="line"># TYPE go_gc_duration_seconds summary</span><br><span class="line">go_gc_duration_seconds&#123;quantile=&quot;0&quot;&#125; 8.54e-05</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h2><p>cAdvisor 是 Container Advisor 的缩写，用于获取运行中容器的系统指标，指标默认在本地保存2分钟</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动 cAdvisor</span><br><span class="line"></span><br><span class="line">docker run -d --name=cadvisor  -p 8080:8080 \</span><br><span class="line">  -v /:/rootfs:ro \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock:rw \</span><br><span class="line">  -v /sys:/sys:ro \</span><br><span class="line">  -v /var/lib/docker/:/var/lib/docker:ro \</span><br><span class="line">  -v /dev/disk/:/dev/disk:ro \</span><br><span class="line">  --privileged \</span><br><span class="line">  --device=/dev/kmsg \</span><br><span class="line">  google/cadvisor</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证指标数据，浏览器打开 http://localhost:8080/</span><br><span class="line"></span><br><span class="line">/</span><br><span class="line">root</span><br><span class="line">Docker Containers</span><br><span class="line">Subcontainers</span><br><span class="line">/000-dhcpcd</span><br><span class="line">/001-sysfs</span><br><span class="line">/002-sysctl</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>prometheus 是一个可以实时将搜集到的指标数据存储到时间序列数据库（TSDB）中的监控应用，指标数据默认存储在本地磁盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prometheus.yml内容如下</span><br><span class="line"></span><br><span class="line">global:</span><br><span class="line">  scrape_interval:     120s # By default, scrape targets every 15 seconds.</span><br><span class="line">  evaluation_interval: 120s # By default, scrape targets every 15 seconds.</span><br><span class="line">  # scrape_timeout is set to the global default (10s).</span><br><span class="line"></span><br><span class="line">  # Attach these labels to any time series or alerts when communicating with</span><br><span class="line">  # external systems (federation, remote storage, Alertmanager).</span><br><span class="line">  external_labels:</span><br><span class="line">      monitor: &#x27;prometheus-test&#x27;</span><br><span class="line"></span><br><span class="line"># Load and evaluate rules in this file every &#x27;evaluation_interval&#x27; seconds.</span><br><span class="line">rule_files:</span><br><span class="line">  # - &quot;alert.rules&quot;</span><br><span class="line">  # - &quot;first.rules&quot;</span><br><span class="line">  # - &quot;second.rules&quot;</span><br><span class="line"></span><br><span class="line"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class="line"># Here it&#x27;s Prometheus itself.</span><br><span class="line">scrape_configs:</span><br><span class="line">  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    scrape_interval: 30s</span><br><span class="line">    static_configs:</span><br><span class="line">         - targets: [&#x27;host_ip:9090&#x27;,&#x27;host_ip:8080&#x27;,&#x27;host_ip:9100&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动 prometheus</span><br><span class="line"></span><br><span class="line">docker run -d --name prometheus -p 9090:9090  \</span><br><span class="line">-v ~/prometheus/config/prometheus.yml:/etc/prometheus/prometheus.yml \</span><br><span class="line">prom/prometheus</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证指标数据，浏览器打开 http://localhost:9090/  搜索 machine_cpu_cores</span><br><span class="line"></span><br><span class="line">machine_cpu_cores&#123;instance=&quot;172.17.0.1:8080&quot;, job=&quot;prometheus&quot;&#125;  2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>使用Grafana将搜集的指标数据图表化，数据源使用Prometheus。Grafana的使用可以参考 <a href="https://whathowhy.com/2019/01/30/MonitorBaseOnDocker/">Docker搭建监控系统</a></p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Monitoring/grafana_monitor.jpg" alt="这里写图片描述"># 附录</p>
<h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><p><a href="https://whathowhy.com/2019/09/18/Docker-Compose/">使用 Docker Compose</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">    prometheus_data:</span><br><span class="line">networks:</span><br><span class="line">    monitor-net:</span><br><span class="line">        driver: bridge</span><br><span class="line">        </span><br><span class="line">services: </span><br><span class="line">    prometheus:</span><br><span class="line">        image: prom/prometheus</span><br><span class="line">        container_name: prometheus_service</span><br><span class="line">        volumes:</span><br><span class="line">            - ~/Projects/monitor/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml</span><br><span class="line">            - prometheus_data:/prometheus</span><br><span class="line">        ports: </span><br><span class="line">            - 9090:9090</span><br><span class="line">        networks: </span><br><span class="line">            - monitor-net</span><br><span class="line">        labels:</span><br><span class="line">            org.label-schema.group: &quot;monitoring&quot;</span><br><span class="line"></span><br><span class="line">    cAdvisor:</span><br><span class="line">        image: google/cadvisor</span><br><span class="line">        container_name: cAdvisor_service</span><br><span class="line">        # Could not configure a source for OOM detection, disabling OOM events: open /dev/kmsg: operation not permitted</span><br><span class="line">        privileged: true</span><br><span class="line">        volumes:</span><br><span class="line">            - /:/rootfs:ro</span><br><span class="line">                        # - /var/run:/var/run:ro # failed to get docker info: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">            - /var/run/docker.sock:/var/run/docker.sock:rw</span><br><span class="line">            - /sys:/sys:ro</span><br><span class="line">            - /var/lib/docker/:/var/lib/docker:ro</span><br><span class="line">            - /dev/disk/:/dev/disk:ro</span><br><span class="line">        devices: </span><br><span class="line">            - /dev/kmsg:/dev/kmsg</span><br><span class="line">        ports: </span><br><span class="line">            - 8080:8080</span><br><span class="line">        networks: </span><br><span class="line">            - monitor-net</span><br><span class="line">        labels:</span><br><span class="line">            org.label-schema.group: &quot;monitoring&quot;</span><br><span class="line"></span><br><span class="line">    node-exporter:</span><br><span class="line">        image: prom/node-exporter</span><br><span class="line">        container_name: node_exporter_service</span><br><span class="line">        volumes:</span><br><span class="line">            - /proc:/host/proc</span><br><span class="line">            - /sys:/host/sys</span><br><span class="line">            - /:/rootfs</span><br><span class="line">        command: </span><br><span class="line">            - &#x27;--path.procfs=/host/proc&#x27;</span><br><span class="line">            - &#x27;--path.sysfs=/host/sys&#x27;</span><br><span class="line">            - &#x27;--path.rootfs=/rootfs&#x27;</span><br><span class="line">        ports: </span><br><span class="line">            - 9100:9100</span><br><span class="line">        networks: </span><br><span class="line">            - monitor-net</span><br><span class="line">        labels:</span><br><span class="line">            org.label-schema.group: &quot;monitoring&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="prometheus-yml"><a href="#prometheus-yml" class="headerlink" title="prometheus.yml"></a>prometheus.yml</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval:     120s # By default, scrape targets every 15 seconds.</span><br><span class="line">  evaluation_interval: 120s # By default, scrape targets every 15 seconds.</span><br><span class="line">  # scrape_timeout is set to the global default (10s).</span><br><span class="line"></span><br><span class="line">  # Attach these labels to any time series or alerts when communicating with</span><br><span class="line">  # external systems (federation, remote storage, Alertmanager).</span><br><span class="line">  external_labels:</span><br><span class="line">      monitor: &#x27;monitoring&#x27;</span><br><span class="line"></span><br><span class="line"># Load and evaluate rules in this file every &#x27;evaluation_interval&#x27; seconds.</span><br><span class="line">rule_files:</span><br><span class="line">  # - &quot;alert.rules&quot;</span><br><span class="line">  # - &quot;first.rules&quot;</span><br><span class="line">  # - &quot;second.rules&quot;</span><br><span class="line"></span><br><span class="line"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class="line"># Here it&#x27;s Prometheus itself.</span><br><span class="line">scrape_configs:</span><br><span class="line">  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    scrape_interval: 30s</span><br><span class="line">    static_configs:</span><br><span class="line">         - targets: [&#x27;localhost:9090&#x27;,&#x27;cAdvisor_service:8080&#x27;,&#x27;node_exporter_service:9100&#x27;]</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> Life is like a roll of toilet paper. The closer it gets to the end, the faster it goes. - Forrest</p>
<p><a href="https://movie.douban.com/subject/1292720/">Forrest Gump</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>监控</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Mutex</title>
    <url>/2018/09/07/mutex/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/21.png" class="full-image" />

<p>记录下多线程情况下，如何避免资源竞争带来的问题</p>
<h1 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h1><p>多线程在运行期间，若存在数据的共享，不同线程对资源的争抢会造成彼方线程的处理错乱。下面是两个线程将数值从零累加10次的例子（预计结果为10）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Count implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  private int countResult = 0;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">      count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void  count() &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      Thread.sleep(10);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    int temp = countResult;</span><br><span class="line">    countResult++;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; Count Before &quot; + temp + &quot;, Count After &quot;</span><br><span class="line">        + countResult);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public  void countResult() &#123;</span><br><span class="line">    System.out.println(&quot;The result of count is &quot; + countResult);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Count count = new Count();</span><br><span class="line">Thread t1 = new Thread(count, &quot;T1&quot;);</span><br><span class="line">Thread t2 = new Thread(count, &quot;T2&quot;);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">count.countResult();</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">T1 Count Before 0, Count After 1</span><br><span class="line">T2 Count Before 1, Count After 2</span><br><span class="line">T1 Count Before 2, Count After 3</span><br><span class="line">T2 Count Before 3, Count After 4</span><br><span class="line">T2 Count Before 5, Count After 6</span><br><span class="line">T1 Count Before 4, Count After 6</span><br><span class="line">T2 Count Before 6, Count After 7</span><br><span class="line">T1 Count Before 7, Count After 8</span><br><span class="line">T1 Count Before 8, Count After 9</span><br><span class="line">T2 Count Before 8, Count After 9</span><br><span class="line">The result of count is 9   // 并非是预期的结果 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/MulTRC.png" alt="image"></p>
<blockquote>
<p>当线程或进程依赖某一资源（代码中的countResult），会发生资源竞争。使针对资源的操作互斥，能够解决资源竞争带来的结果不可预测</p>
</blockquote>
<span id="more"></span>

<h1 id="关键字synchronized"><a href="#关键字synchronized" class="headerlink" title="关键字synchronized"></a>关键字synchronized</h1><p>Java中提供了Synchronize关键字来解决资源竞争问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private synchronized void count() &#123;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    Thread.sleep(10);</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  int temp = countResult;</span><br><span class="line">  countResult++;</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + &quot; Count Before &quot; + temp + &quot;, Count After &quot;</span><br><span class="line">      + countResult);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将资源依赖的代码方法上加上 synchronized 关键字，问题得到解决</span><br><span class="line"></span><br><span class="line">  T1 Count Before 0, Count After 1</span><br><span class="line">  T1 Count Before 1, Count After 2</span><br><span class="line">  T1 Count Before 2, Count After 3</span><br><span class="line">  T1 Count Before 3, Count After 4</span><br><span class="line">  T1 Count Before 4, Count After 5</span><br><span class="line">  T2 Count Before 5, Count After 6</span><br><span class="line">  T2 Count Before 6, Count After 7</span><br><span class="line">  T2 Count Before 7, Count After 8</span><br><span class="line">  T2 Count Before 8, Count After 9</span><br><span class="line">  T2 Count Before 9, Count After 10</span><br><span class="line">  The result of count is 10</span><br></pre></td></tr></table></figure>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/MulSync.png" alt="image"></p>
<h2 id="synchronized方法与方法块"><a href="#synchronized方法与方法块" class="headerlink" title="synchronized方法与方法块"></a>synchronized方法与方法块</h2><p>线程想进入synchronized修饰的代码的前提是先获得对象的监视器锁</p>
<ol>
<li>synchronized修饰方法，则需要先获得当前实例对象的监视器锁</li>
<li>synchronized修饰代码块，则需要先获得synchronized所指定对象的监视器锁(修饰代码块更方便控制同步的范围)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SynchronizedTest &#123;</span><br><span class="line"></span><br><span class="line">  public synchronized void syncMethod() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      syncBlock();</span><br><span class="line">      TimeUnit.SECONDS.sleep(10);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void noSyncMethod() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(10);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void syncBlock() &#123;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + &quot;:I am in syncBlock&quot;);</span><br><span class="line">      try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(10);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SynchronizedTest synchronizedTest = new SynchronizedTest();</span><br><span class="line"></span><br><span class="line">Thread tOne = new Thread(() -&gt; synchronizedTest.syncMethod(), &quot;One&quot;);</span><br><span class="line">tOne.start(); // 获取对象实例（synchronizedTest）监视器锁,并可重入监视器锁（可以执行syncBlock）</span><br><span class="line"></span><br><span class="line">Thread tTwo = new Thread(() -&gt; synchronizedTest.syncMethod(), &quot;Two&quot;);</span><br><span class="line">tTwo.start(); // 等待tOne释放对象监视器锁，BLOCKED状态</span><br><span class="line"></span><br><span class="line">Thread tThree = new Thread(() -&gt; synchronizedTest.noSyncMethod(), &quot;Three&quot;);</span><br><span class="line">tThree.start(); // 不需要对象监视器锁即可执行</span><br><span class="line"></span><br><span class="line">Thread tFour = new Thread(() -&gt; synchronizedTest.syncBlock(), &quot;Four&quot;);</span><br><span class="line">tFour.start(); // 等待释放对象监视器锁，BLOCKED状态</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;One will be TIMED_WAITING: &quot; + tOne.getState());</span><br><span class="line">System.out.println(&quot;Two will be BLOCKED: &quot; + tTwo.getState());</span><br><span class="line">System.out.println(&quot;Three will be TIMED_WAITING: &quot; + tThree.getState());</span><br><span class="line">System.out.println(&quot;Four will be BLOCKED: &quot; + tFour.getState());</span><br><span class="line">tOne.join();</span><br><span class="line">tTwo.join();</span><br><span class="line">tThree.join();</span><br><span class="line">tFour.join();</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">One:I am in syncBlock</span><br><span class="line">One will be TIMED_WAITING: TIMED_WAITING</span><br><span class="line">Two will be BLOCKED: BLOCKED</span><br><span class="line">Three will be TIMED_WAITING: TIMED_WAITING</span><br><span class="line">Four will be BLOCKED: BLOCKED</span><br><span class="line">Four:I am in syncBlock</span><br><span class="line">Two:I am in syncBlock</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多个线程同时阻塞等待进入同步块，当锁持有者离开同步块，这些等待的线程谁能进入同步块是不确定的，因为同步是不公平的（先来的不一定先进入同步块），这种不公平可能导致<a href="http://whathowhy.com/2018/08/20/Java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">Thread Starvation</a></p>
</blockquote>
<h2 id="监视器锁"><a href="#监视器锁" class="headerlink" title="监视器锁"></a>监视器锁</h2><p>synchronized到底是什么？为啥可以控制资源竞争。先看看编译后的字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:ThreadExamples mac$ javac SynchronizedMethodBlock.java</span><br><span class="line">Mac:ThreadExamples mac$ javap -c SynchronizedMethodBlock.class</span><br><span class="line"></span><br><span class="line">Compiled from &quot;SynchronizedMethodBlock.java&quot;</span><br><span class="line">public class dmztest.ThreadExamples.SynchronizedMethodBlock &#123;</span><br><span class="line">  public dmztest.ThreadExamples.SynchronizedMethodBlock();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public synchronized void syncMethod();  // 关键字synchronized用在方法上，则由JVM级别实现同步</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #3                  // String I am sync Method !</span><br><span class="line">       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line"></span><br><span class="line">  public void syncBlock();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: dup</span><br><span class="line">       2: astore_1</span><br><span class="line">       // 尝试获得对象的监视器 ，每个对象都拥有一个监视器</span><br><span class="line">       // 当monitor为0说明monitorenter能够获得监视器，线程获得监视器后将monitor+1,该线程为对象monitor所有者</span><br><span class="line">       // 具有monitor所有者的线程能够重新进入监视器monitor+1。如果非monitor持有者的线程尝试monitorenter将会阻塞，直到monitor=0后获取monitor拥有权</span><br><span class="line">       3: monitorenter </span><br><span class="line">       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       7: ldc           #5                  // String I am sync Block !</span><br><span class="line">       9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      12: aload_1</span><br><span class="line">      13: monitorexit   // 释放monitor所有权,只有拥有monitor的线程才可以释放,释放后monitor-1,monitor为0时则线程失去monitor所有权   </span><br><span class="line">      14: goto          22</span><br><span class="line">      17: astore_2</span><br><span class="line">      18: aload_1</span><br><span class="line">      19: monitorexit   // 当代码块中出现异常则会释放monitor拥有权</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: athrow</span><br><span class="line">      22: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           4    14    17   any</span><br><span class="line">          17    20    17   any</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关键字synchronized在方法上与在代码块上的功能是一样的，方法上的synchronized成为JVM对此方法上的访问标志，方法块上的synchronized会填充一系列字节码到class中</p>
</blockquote>
<h2 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h2><p>synchronized是互斥锁（重量级锁），互斥会带来用户态到内核态的线程切换的性能问题。在JDK1.6以后对synchronized进行了优化，synchronized的同步来自JVM的实现，由C++实现CAS，利用CPU指令执行原子操作（cmpxchg汇编指令，当多核CPU情况下会加lock）</p>
<ol>
<li>锁粗化：将多个连续的锁扩展为范围更大的锁，减少频繁的互斥同步导致的性能开销</li>
<li>锁消除：JVM即时编译器在运行时，通过逃逸分析出”如果一段代码中堆数据永远不会被其他线程访问”则将锁取消</li>
<li>轻量级锁：在没有多线程竞争的情况下，避免重量级的互斥锁，通过CAS完成锁的获取与释放</li>
<li>偏向锁：消除数据在无竞争的情况下执行同步，若下一次同一线程进入，则偏向该线程，无需任何同步操作</li>
<li>适应性自旋：避免线程频繁切换的消耗，使用自旋的方式。适应性自旋的时间会根据上一次获取锁自旋的时间动态变化</li>
</ol>
<h2 id="不适合synchronized的应用场景"><a href="#不适合synchronized的应用场景" class="headerlink" title="不适合synchronized的应用场景"></a>不适合synchronized的应用场景</h2><ol>
<li>中断阻塞在获取监控锁的线程</li>
<li>公平的获得监视器锁</li>
</ol>
<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p>Lock相比synchronized更加灵活，synchronized无法解决的场景Lock可以解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ThreadWithInterrupt &#123;</span><br><span class="line"></span><br><span class="line">  private Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">  public void write() &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">      lock.lock();</span><br><span class="line">      long startTime = System.currentTimeMillis();</span><br><span class="line">      System.out.println(&quot;写数据。。。&quot;);</span><br><span class="line"></span><br><span class="line">      for (; ; ) &#123;</span><br><span class="line">        if (System.currentTimeMillis() - startTime &gt; 10000) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;数据写完了！&quot;);</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void read() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;等待数据读。。。&quot;);</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;数据读完了。&quot;);</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ThreadWithInterrupt threadWithInterrupt = new ThreadWithInterrupt();</span><br><span class="line">Thread write = new Thread(() -&gt; threadWithInterrupt.write());</span><br><span class="line">Thread read = new Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    threadWithInterrupt.read();</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    System.out.println(&quot;数据未读。&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">write.start();</span><br><span class="line">read.start();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">  long startTime = System.currentTimeMillis();</span><br><span class="line">  for (;;) &#123;</span><br><span class="line">    if (System.currentTimeMillis() - startTime &gt; 500) &#123;</span><br><span class="line">      System.out.println(&quot;写的太慢了，不读了。&quot;);</span><br><span class="line">      read.interrupt();</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">写数据。。。</span><br><span class="line">等待数据读。。。</span><br><span class="line">写的太慢了，不读了。</span><br><span class="line">数据未读。</span><br><span class="line">数据写完了！</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>可重入锁，当前线程持有lock后可再次获得此锁。重入锁包括公平锁与不公平锁，公平锁保证先发起的lock请求会先获得锁，后发起的lock请求后获得锁，非公平锁则不能保证“先来先锁”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ThreadLockFairOrNon &#123;</span><br><span class="line"></span><br><span class="line">  private Lock lock;</span><br><span class="line"></span><br><span class="line">  private Integer concurrency;</span><br><span class="line"></span><br><span class="line">  public ThreadLockFairOrNon(Boolean isFair, Integer concurrency) &#123;</span><br><span class="line"></span><br><span class="line">    this.lock = new ReentrantLock(isFair);</span><br><span class="line">    this.concurrency = concurrency;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Boolean isSeqSorted(List&lt;String&gt; seqs) &#123;</span><br><span class="line"></span><br><span class="line">    if (!String.valueOf(concurrency).equals(seqs.get(concurrency))) &#123;</span><br><span class="line"></span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Boolean lockSequence() &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; seqs = new ArrayList&lt;&gt;();</span><br><span class="line">    CountDownLatch waitForFirstThreadCount = new CountDownLatch(1);</span><br><span class="line">    CountDownLatch waitForAllThreadCount = new CountDownLatch(concurrency + 1);</span><br><span class="line">    CountDownLatch waitForSeqThreadCount = new CountDownLatch(concurrency - 1);</span><br><span class="line">    try &#123;</span><br><span class="line">      new Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">          lock.lock();</span><br><span class="line">          waitForFirstThreadCount.countDown();</span><br><span class="line">          seqs.add(Thread.currentThread().getName());</span><br><span class="line">          waitForSeqThreadCount.await();</span><br><span class="line">          lock.unlock();</span><br><span class="line">          waitForAllThreadCount.countDown();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;, &quot;0&quot;).start();</span><br><span class="line"></span><br><span class="line">      waitForFirstThreadCount.await();</span><br><span class="line"></span><br><span class="line">      for (int j = 1; j &lt;= concurrency - 1; j++) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">          waitForSeqThreadCount.countDown();</span><br><span class="line">          lock.lock();</span><br><span class="line">          seqs.add(Thread.currentThread().getName());</span><br><span class="line">          lock.unlock();</span><br><span class="line">          waitForAllThreadCount.countDown();</span><br><span class="line"></span><br><span class="line">        &#125;, &quot;&quot; + j).start();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      waitForSeqThreadCount.await();</span><br><span class="line"></span><br><span class="line">      // 准备争抢</span><br><span class="line">      new Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">          lock.lock();</span><br><span class="line">          seqs.add(Thread.currentThread().getName());</span><br><span class="line">          lock.unlock();</span><br><span class="line">          waitForAllThreadCount.countDown();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;, &quot;&quot; + concurrency).start();</span><br><span class="line"></span><br><span class="line">      waitForAllThreadCount.await();</span><br><span class="line"></span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return isSeqSorted(seqs);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h3><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/FairnessLock.png" alt="image"></p>
<ol>
<li>事例</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer wrongSeqs = 0;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">  Boolean isSeqsSorted = new ThreadLockFairOrNon(true, 100).lockSequence();</span><br><span class="line"></span><br><span class="line">  if (!isSeqsSorted) &#123;</span><br><span class="line">    wrongSeqs++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out</span><br><span class="line">    .println(&quot;1000 samples cause wrong seqs :&quot; + wrongSeqs + &quot; times&quot;);</span><br><span class="line">    </span><br><span class="line">// 输出</span><br><span class="line">1000 samples cause wrong seqs :0 times</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>源码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">final Thread current = Thread.currentThread();</span><br><span class="line">int c = getState();</span><br><span class="line">if (c == 0) &#123;</span><br><span class="line">    if (!hasQueuedPredecessors() &amp;&amp;  ## 排队等待，很公平</span><br><span class="line">        compareAndSetState(0, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    int nextc = c + acquires;</span><br><span class="line">    if (nextc &lt; 0)</span><br><span class="line">        throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h3><p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/%E5%B9%B6%E5%8F%91/unFairnessLock.png" alt="image"></p>
<ol>
<li>事例</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer wrongSeqs = 0;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">  Boolean isSeqsSorted = new ThreadLockFairOrNon(false, 100).lockSequence();</span><br><span class="line"></span><br><span class="line">  if (!isSeqsSorted) &#123;</span><br><span class="line">    wrongSeqs++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out</span><br><span class="line">    .println(&quot;1000 samples cause wrong seqs :&quot; + wrongSeqs + &quot; times&quot;);</span><br><span class="line">    </span><br><span class="line">// 输出</span><br><span class="line">1000 samples cause wrong seqs :950 times</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>源码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))   ## 插队！不公平</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">final Thread current = Thread.currentThread();</span><br><span class="line">int c = getState();</span><br><span class="line">if (c == 0) &#123;</span><br><span class="line">    if (compareAndSetState(0, acquires)) &#123;  ## 插队！不公平</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    int nextc = c + acquires;</span><br><span class="line">    if (nextc &lt; 0) // overflow</span><br><span class="line">        throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> I have lived my life in a dream. - Puyi</p>
<p><a href="https://movie.douban.com/subject/1293172/">The Last Emperor</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>A/B testing, Canary release, Blue–green deployment, Gray-box testing</title>
    <url>/2024/07/11/software-lifecycle/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/26.png" class="full-image" />

<p>你是否对 A&#x2F;B testing, Canary release, Blue–green deployment, Gray-box testing 感到困惑？理解并有效利用这些策略，对提升软件质量和用户满意度有很大的帮助。本篇博客将会带大家了解这些策略背后的细节。</p>
<span id="more"></span>

<h1 id="A-B-testing"><a href="#A-B-testing" class="headerlink" title="A&#x2F;B testing"></a>A&#x2F;B testing</h1><p>A&#x2F;B 测试也被称为分拆测试，将用户分成两组或多组，分别访问不同版本应用，观察哪个版本的体验更好，转换率更高，通过数据来驱动软件优化。A&#x2F;B testing 是一种用于提升用户体验的研究方法。</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/abtesting.png" alt="imag"></p>
<h1 id="Canary-release"><a href="#Canary-release" class="headerlink" title="Canary release"></a>Canary release</h1><p>1900年英国矿工会带着金丝雀一起去开采煤炭，因为金丝雀能快速察觉矿山中的有毒气体，通过观察金丝雀是否产生痛苦迹象，矿工可以确定环境是否危险。别担心，矿工会随身携带小氧气瓶救活一氧化碳中毒的金丝雀，1986年金丝雀被淘汰使用。金丝雀发布也被称为金丝雀部署，是一种渐进式的发布策略，将新版本先提供给一小部分用户使用，若新版本存在问题可以快速定位和回滚，只会影响一小部分用户，这样可以避免产生大范围影响。</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/canaryrelease.png" alt="imag"></p>
<h1 id="Blue–green-deployment"><a href="#Blue–green-deployment" class="headerlink" title="Blue–green deployment"></a>Blue–green deployment</h1><p>蓝绿发布是一种应用发布模型，需要提供两套几乎相同的系统环境，通过反向代理设置网络流量走向，实现零停机的新版本平滑迁移能力，如果新版本出现问题，可以修改网络流量走向进行快速回滚。</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/bluegreenrelease.png" alt="imag"></p>
<h1 id="Gray-box-testing"><a href="#Gray-box-testing" class="headerlink" title="Gray-box testing"></a>Gray-box testing</h1><p>灰盒测试是介于白盒测试和黑盒测试之间的一种测试方法，从软件的内部结构和用户视角出发进行应用测试。</p>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/CICD/graybox.png" alt="imag"></p>
]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title>Vector With ClickHouse</title>
    <url>/2021/07/18/vector-with-clickhouse/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/4.png" class="full-image" />

<p>文章主要记录我是如何使用Vector获取系统观测数据，并将观测数据存储到Clickhouse中</p>
<h1 id="Clickhouse"><a href="#Clickhouse" class="headerlink" title="Clickhouse"></a>Clickhouse</h1><p>Clickhouse由C++语言实现，是一种快速的面向列存储的OLAP数据库管理系统，支持通过SQL查询并实时生成分析报表</p>
<span id="more"></span>

<h2 id="Clickhouse-Server"><a href="#Clickhouse-Server" class="headerlink" title="Clickhouse Server"></a>Clickhouse Server</h2><p>创建 Clickhouse Server，docker-compose.yml 内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">volumes: </span><br><span class="line">    clickhouse_data:</span><br><span class="line">    clickhouse_conf:</span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external: true</span><br><span class="line">    name: monitor_monitor-net</span><br><span class="line"></span><br><span class="line">services: </span><br><span class="line">    server:</span><br><span class="line">        image: yandex/clickhouse-server</span><br><span class="line">        container_name: clickhouse_service</span><br><span class="line">        volumes: </span><br><span class="line">            - clickhouse_conf:/etc/clickhouse-server</span><br><span class="line">            - clickhouse_data:/var/lib/clickhouse</span><br><span class="line">        ports: </span><br><span class="line">            - 8123:8123</span><br><span class="line">        ulimits: </span><br><span class="line">            nofile:</span><br><span class="line">                soft: &quot;262144&quot;</span><br><span class="line">                hard: &quot;262144&quot;</span><br></pre></td></tr></table></figure>

<h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><p>创建数据存储所需表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --rm  --network monitor_monitor-net \</span><br><span class="line">yandex/clickhouse-client -h clickhouse_service --port 9000</span><br><span class="line"></span><br><span class="line">CREATE TABLE host_metrics_memory (</span><br><span class="line">  namespace String,</span><br><span class="line">  name String,</span><br><span class="line">  host String,</span><br><span class="line">  kind String,</span><br><span class="line">  collector String,</span><br><span class="line">  metric_name String,</span><br><span class="line">  metric_type String,</span><br><span class="line">  metric_value Float64,</span><br><span class="line">  timestamp Datetime64</span><br><span class="line">)ENGINE=MergeTree()</span><br><span class="line">ORDER BY timestamp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>Vector由Rust语言实现，用于构建可观测数据的轻量级工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --network monitor_monitor-net \</span><br><span class="line">-v ~/Projects/compose/vector/host_metrics.vector.toml:/etc/vector/vector.toml:ro \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">--name host_metrics timberio/vector:latest-debian</span><br></pre></td></tr></table></figure>

<h1 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h1><p>使用Grafana将搜集的指标数据图表化，数据源使用Clickhouse</p>
<ul>
<li>Grafana 默认未安装 Clickhouse 数据源<blockquote>
<p>GF_INSTALL_PLUGINS&#x3D;vertamedia-clickhouse-datasource 用于安装 clickhouse 数据源，插件地址：<a href="https://storage.googleapis.com/plugins-community/vertamedia-clickhouse-datasource/release/2.3.1/vertamedia-clickhouse-datasource-2.3.1.zip">https://storage.googleapis.com/plugins-community/vertamedia-clickhouse-datasource/release/2.3.1/vertamedia-clickhouse-datasource-2.3.1.zip</a></p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">    grafana_data:</span><br><span class="line">    grafana_conf:</span><br><span class="line">    grafana_log:</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external: true</span><br><span class="line">    name: monitor_monitor-net</span><br><span class="line"></span><br><span class="line">services: </span><br><span class="line">    grafana:</span><br><span class="line">        image: grafana/grafana</span><br><span class="line">        container_name: grafana_service</span><br><span class="line">        volumes:</span><br><span class="line">            - grafana_data:/var/lib/grafana</span><br><span class="line">            - grafana_conf:/etc/grafana</span><br><span class="line">            - grafana_log:/var/log/grafana</span><br><span class="line">        environment: </span><br><span class="line">            - GF_INSTALL_PLUGINS=vertamedia-clickhouse-datasource</span><br><span class="line">        ports: </span><br><span class="line">            - 3000:3000</span><br><span class="line">        labels: </span><br><span class="line">            org.label-schema.group: &quot;monitoring&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/Monitoring/host_metrics_clickhouse.png"></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="host-metrics-vector-toml"><a href="#host-metrics-vector-toml" class="headerlink" title="host_metrics.vector.toml"></a>host_metrics.vector.toml</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[sources.host_metrics]</span><br><span class="line">  type = &quot;host_metrics&quot;</span><br><span class="line">  collectors = [&quot;cpu&quot;, &quot;disk&quot;, &quot;filesystem&quot;, &quot;load&quot;, &quot;host&quot;, &quot;memory&quot;, &quot;network&quot;]</span><br><span class="line">  scrape_interval_secs = 60</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[transforms.metrics_to_logs]</span><br><span class="line">  type = &quot;metric_to_log&quot;</span><br><span class="line">  inputs = [&quot;host_metrics&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[transforms.remap]</span><br><span class="line">  type = &quot;remap&quot;</span><br><span class="line">  inputs = [&quot;metrics_to_logs&quot;]</span><br><span class="line">  source = &#x27;&#x27;&#x27;</span><br><span class="line">  ts,_= format_timestamp(.timestamp, &quot;%F %T&quot;)</span><br><span class="line">  .metric_value = .gauge.value</span><br><span class="line">  .metric_type = &quot;gauge&quot;</span><br><span class="line">  del(.gauge)</span><br><span class="line">  if .metric_value == null &#123;</span><br><span class="line">      .metric_value = .counter.value</span><br><span class="line">      .metric_type = &quot;counter&quot;</span><br><span class="line">      del(.counter)</span><br><span class="line">  &#125;</span><br><span class="line">  .metric_name = del(.name)</span><br><span class="line">  .timestamp = ts</span><br><span class="line">  .collector = .tags.collector</span><br><span class="line">  if .tags.collector == &quot;cpu&quot; &#123;</span><br><span class="line">    .cpu= .tags.cpu</span><br><span class="line">    .mode= .tags.mode</span><br><span class="line">  &#125; else if (.tags.collector == &quot;filesystem&quot;)&#123;</span><br><span class="line">    .filesystem= .tags.filesystem</span><br><span class="line">    .device = .tags.device</span><br><span class="line">  &#125; else if (.tags.collector == &quot;network&quot; || .tags.collector == &quot;disk&quot;)&#123;</span><br><span class="line">    .device = .tags.device</span><br><span class="line">  &#125;</span><br><span class="line">  del(.tags)</span><br><span class="line">  &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">[transforms.metrics_router]</span><br><span class="line">  type = &quot;route&quot;</span><br><span class="line">  inputs = [&quot;remap&quot;]</span><br><span class="line">  route.host=&#x27;.collector == &quot;host&quot;&#x27;</span><br><span class="line">  route.memory=&#x27;.collector == &quot;memory&quot;&#x27;</span><br><span class="line">  route.cpu=&#x27;.collector == &quot;cpu&quot;&#x27;</span><br><span class="line">  route.network=&#x27;.collector == &quot;network&quot;&#x27;</span><br><span class="line">  route.filesystem=&#x27;.collector == &quot;filesystem&quot;&#x27;</span><br><span class="line">  route.disk=&#x27;.collector == &quot;disk&quot;&#x27;</span><br><span class="line"></span><br><span class="line">[sinks.memory_clickhouse]</span><br><span class="line">type = &quot;clickhouse&quot;</span><br><span class="line">inputs = [&quot;metrics_router.memory&quot;]</span><br><span class="line">compression = &quot;gzip&quot;</span><br><span class="line">endpoint = &quot;http://clickhouse_service:8123&quot;</span><br><span class="line">table = &quot;host_metrics_memory&quot;</span><br><span class="line">batch.timeout_secs = 5</span><br><span class="line"></span><br><span class="line">[sinks.cpu_clickhouse]</span><br><span class="line">type = &quot;clickhouse&quot;</span><br><span class="line">inputs = [&quot;metrics_router.cpu&quot;]</span><br><span class="line">compression = &quot;gzip&quot;</span><br><span class="line">endpoint = &quot;http://clickhouse_service:8123&quot;</span><br><span class="line">table = &quot;host_metrics_cpu&quot;</span><br><span class="line">batch.timeout_secs = 5</span><br><span class="line"></span><br><span class="line">[sinks.host_clickhouse]</span><br><span class="line">type = &quot;clickhouse&quot;</span><br><span class="line">inputs = [&quot;metrics_router.host&quot;]</span><br><span class="line">compression = &quot;gzip&quot;</span><br><span class="line">endpoint = &quot;http://clickhouse_service:8123&quot;</span><br><span class="line">table = &quot;host_metrics_host&quot;</span><br><span class="line">batch.timeout_secs = 5</span><br><span class="line"></span><br><span class="line">[sinks.network_clickhouse]</span><br><span class="line">type = &quot;clickhouse&quot;</span><br><span class="line">inputs = [&quot;metrics_router.network&quot;]</span><br><span class="line">compression = &quot;gzip&quot;</span><br><span class="line">endpoint = &quot;http://clickhouse_service:8123&quot;</span><br><span class="line">table = &quot;host_metrics_network&quot;</span><br><span class="line">batch.timeout_secs = 5</span><br><span class="line"></span><br><span class="line">[sinks.filesystem_clickhouse]</span><br><span class="line">type = &quot;clickhouse&quot;</span><br><span class="line">inputs = [&quot;metrics_router.filesystem&quot;]</span><br><span class="line">compression = &quot;gzip&quot;</span><br><span class="line">endpoint = &quot;http://clickhouse_service:8123&quot;</span><br><span class="line">table = &quot;host_metrics_filesystem&quot;</span><br><span class="line">batch.timeout_secs = 5</span><br><span class="line"></span><br><span class="line">[sinks.disk_clickhouse]</span><br><span class="line">type = &quot;clickhouse&quot;</span><br><span class="line">inputs = [&quot;metrics_router.disk&quot;]</span><br><span class="line">compression = &quot;gzip&quot;</span><br><span class="line">endpoint = &quot;http://clickhouse_service:8123&quot;</span><br><span class="line">table = &quot;host_metrics_disk&quot;</span><br><span class="line">batch.timeout_secs = 5</span><br></pre></td></tr></table></figure>

<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>host、cpu、filesystem、network、disk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE host_metrics_host (</span><br><span class="line">  namespace String,</span><br><span class="line">  name String,</span><br><span class="line">  host String,</span><br><span class="line">  kind String,</span><br><span class="line">  collector String,</span><br><span class="line">  metric_name String,</span><br><span class="line">  metric_type String,</span><br><span class="line">  metric_value Float64,</span><br><span class="line">  timestamp Datetime64</span><br><span class="line">)ENGINE=MergeTree()</span><br><span class="line">ORDER BY timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE host_metrics_cpu (</span><br><span class="line">  namespace String,</span><br><span class="line">  name String,</span><br><span class="line">  host String,</span><br><span class="line">  kind String,</span><br><span class="line">  collector String,</span><br><span class="line">  cpu String,</span><br><span class="line">  mode String,</span><br><span class="line">  metric_name String,</span><br><span class="line">  metric_type String,</span><br><span class="line">  metric_value Float64,</span><br><span class="line">  timestamp Datetime64</span><br><span class="line">)ENGINE=MergeTree()</span><br><span class="line">ORDER BY timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE host_metrics_filesystem (</span><br><span class="line">  namespace String,</span><br><span class="line">  name String,</span><br><span class="line">  host String,</span><br><span class="line">  kind String,</span><br><span class="line">  collector String,</span><br><span class="line">  filesystem String,</span><br><span class="line">  device String,</span><br><span class="line">  metric_name String,</span><br><span class="line">  metric_type String,</span><br><span class="line">  metric_value Float64,</span><br><span class="line">  timestamp Datetime64</span><br><span class="line">)ENGINE=MergeTree()</span><br><span class="line">ORDER BY timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE host_metrics_network (</span><br><span class="line">  namespace String,</span><br><span class="line">  name String,</span><br><span class="line">  host String,</span><br><span class="line">  kind String,</span><br><span class="line">  collector String,</span><br><span class="line">  device String,</span><br><span class="line">  metric_name String,</span><br><span class="line">  metric_type String,</span><br><span class="line">  metric_value Float64,</span><br><span class="line">  timestamp Datetime64</span><br><span class="line">)ENGINE=MergeTree()</span><br><span class="line">ORDER BY timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE host_metrics_disk (</span><br><span class="line">  namespace String,</span><br><span class="line">  name String,</span><br><span class="line">  host String,</span><br><span class="line">  kind String,</span><br><span class="line">  collector String,</span><br><span class="line">  device String,</span><br><span class="line">  metric_name String,</span><br><span class="line">  metric_type String,</span><br><span class="line">  metric_value Float64,</span><br><span class="line">  timestamp Datetime64</span><br><span class="line">)ENGINE=MergeTree()</span><br><span class="line">ORDER BY timestamp;</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> There’s nothing left to do but tell stories. - Noodles</p>
<p><a href="https://movie.douban.com/subject/1292262/">Once Upon a Time in America</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTcwMTU2MDMzNF19
-->]]></content>
      <categories>
        <category>监控</category>
      </categories>
      <tags>
        <tag>ClickHouse</tag>
        <tag>Docker</tag>
        <tag>运维</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile</title>
    <url>/2018/05/15/volatile/</url>
    <content><![CDATA[<img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/photos/25.png" class="full-image" />

<h1 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h1><p>线程间的通信方式有：共享内存和消息传递</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>多个线程通过读写内存中的共享对象来隐式的进行通信。如Java中的对象</p>
<h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>线程间通过发送消息显示的进行通信。如Java中的wait()&#x2F;notify()</p>
<h1 id="线程间共享内存"><a href="#线程间共享内存" class="headerlink" title="线程间共享内存"></a>线程间共享内存</h1><p>线程间共享的对象都在主存中，每个线程都会有一块私有的本地内存称为栈，线程栈中存储了共享对象的副本</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>线程安全包括几个方面的内容：<sup>1。</sup><strong>原子性</strong>  <sup>2。</sup><strong>可见性</strong> <sup>3。</sup><strong>有序性</strong></p>
<h2 id="原子性-执行控制-代码顺序"><a href="#原子性-执行控制-代码顺序" class="headerlink" title="原子性(执行控制-代码顺序)"></a>原子性(执行控制-代码顺序)</h2><p>原子性提供了多线程间代码指令的互斥访问。如:Synchronized、Lock</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>一个线程对共享内存数据的修改是否会立刻被其他线程感知到？多线程间的共享数据访问会由于缓存的不一致性导致数据错乱<br><img src="https://8lovelife-1256398294.cos.ap-shanghai.myqcloud.com/JVM/Volatile_MultiThread.png" alt="image"></p>
<span id="more"></span>

<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>编译器或处理器为了优化指令的执行效率，无数据依赖关系的指令执行顺序会被重新排序(在单线程环境下，指令重排序执行的最终结果应该与其在顺序执行下的效果一致，即 as-if-serial semantics)。然而多线程下会因为不同的执行顺序 ，导致不同的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String content;</span><br><span class="line">boolean isReadable;</span><br><span class="line"></span><br><span class="line">void write()&#123;</span><br><span class="line">    content = &quot;Some Contents&quot;;</span><br><span class="line">    isReadable = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void doWork()&#123;         </span><br><span class="line">    while(isReadable)&#123;</span><br><span class="line">        System.out.println(content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设线程A运行的write()方法中代码顺序进行了重排序，则线程B运行的doWrok()中并不一定能够读到更改后的content！</p>
</blockquote>
<h3 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h3><p>存在数据依赖的语句不会被重排序，如下图的数据依赖关系</p>
<table>
<thead>
<tr>
<th align="left">数据依赖</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">写后读</td>
<td align="center">x &#x3D; 10 ; y&#x3D;x</td>
</tr>
<tr>
<td align="left">写后写</td>
<td align="center">x&#x3D;10 ; x&#x3D;20</td>
</tr>
<tr>
<td align="left">读后写</td>
<td align="center">y&#x3D;x ; x&#x3D;5</td>
</tr>
</tbody></table>
<h3 id="JMM中确保的有序性"><a href="#JMM中确保的有序性" class="headerlink" title="JMM中确保的有序性"></a>JMM中确保的有序性</h3><p>如果两个操作的执行顺序无法从happens-before原则推导出来，那么就不能保证操作的有序性，JVM可以对它们进行随意的重排序。happens-before原则如下：</p>
<ul>
<li>程序次序规则：单线程内，按照代码顺序执行，书写在前的代码先发生于书写在后的代码</li>
<li>锁定规则：一个unLock操作先发生于后面的lock操作之前</li>
<li>volatile原则：一个volatile变量的写操作先发生于后面对这个变量的读操作</li>
<li>传递原则：A操作先发生于B操作，B操作先发生于C操作 ，则A操作先发生于C操作</li>
<li>Thread启动原则：Thread的start()操作先发生于此线程的其他操作</li>
<li>Thread中断原则：Thread的interrupt()操作先发生于代码对线程中断事件的检测</li>
<li>Thread终止原则：Thread的所以操作都先发生于线程的终止检测</li>
<li>对象终结原则：对象的初始化完成先发生于对象的finalize()方法的开始</li>
</ul>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>如果字段被声明为volatile，JMM确保所有线程看到这个变量的值是一致的。JMM通过volatile声明来隐藏处理针对不同处理器下的数据缓存一致性问题,使用Lock前缀或者内存屏障。计算机中的缓存一致性方案有两种：总线锁机制和MESI协议（缓存一致性协议）</p>
<h2 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h2><ul>
<li>禁止指令重排序</li>
<li>强制将缓存的修改立即写入主存</li>
<li>如果是写操作，将导致其他CPU对应的缓存行无效<blockquote>
<p>volatile不能保证执行的原子性，无法保证原子性的操作都不能保证线程的安全</p>
</blockquote>
</li>
</ul>
<h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><ol>
<li>在执行volatile读写操作语句时，在此之前的语句全部已经进行，且结果已经对后面的操作可见</li>
<li>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行</li>
</ol>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p> Why do we accept the love we think we deserve? - Truman Burbank</p>
<p><a href="https://movie.douban.com/subject/1292064/">The Truman Show</a></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
</search>
